<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Mint</title><description>blog</description><link>https://minthana.github.io/</link><language>zh_CN</language><item><title>操作指南</title><link>https://minthana.github.io/blog/posts/%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/</link><guid isPermaLink="true">https://minthana.github.io/blog/posts/%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/</guid><description>这是一个快速指南</description><pubDate>Mon, 17 Nov 2025 00:00:00 GMT</pubDate><content:encoded>&lt;ol&gt;
&lt;li&gt;启动本地开发服务器&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;pnpm dev
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;创建文章md&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;# 方式1：直接指定文件名（自动转为小写连字符格式）
pnpm new-post my-first-article
# 方式2：直接指定文章标题（支持空格，自动生成对应文件名）
pnpm new-post &quot;我的第一篇博客&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;修改文章属性&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;description: &apos;&apos;  # 文章概述
tags: []     # 分类标签
category: &apos;&apos;  # 文章分类
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;wordpress转md&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;git clone https://github.com/lonekorean/wordpress-export-to-markdown.git #安装
cd wordpress-export-to-markdown
npm install

npx wordpress-export-to-markdown # 运行 。将xml文件放入其中，命名为export.xml
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;添加评论区&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a href=&quot;https://www.luogu.com.cn/article/dxovmb51&quot;&gt;在 Fuwari 中使用 Giscus 评论系统 - 洛谷专栏&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.imxizhen.asia/posts/%E6%95%99%E7%A8%8B/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/#1-giscus%E9%85%8D%E7%BD%AE&quot;&gt;搭建个人博客教程与优化记录 - imxizhenのBlog&lt;/a&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;代码高亮以及相关操作&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.cmtyx.top/posts/fuwari-cheatsheet/&quot;&gt;Fuwari 主题 Markdown 速查表与高级用法 - 璨梦踏月の小窝&lt;/a&gt;&lt;/p&gt;
&lt;h1&gt;参考&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://lorenzofeng.top/posts/blog-guide/&quot;&gt;国内自动化静态博客搭建 - Lorenzo Feng&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://kerrynotes.com/wordpress-export-to-markdown/&quot;&gt;如何把 WordPress 导出为 Markdown - Kerry的学习笔记&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/gitblog_00633/article/details/141411141&quot;&gt;WordPress 导出到 Markdown 教程-CSDN博客&lt;/a&gt;&lt;/p&gt;
</content:encoded></item><item><title>MaxKB实现DataBase数据查询分析与AI问答功能</title><link>https://minthana.github.io/blog/posts/maxkb/</link><guid isPermaLink="true">https://minthana.github.io/blog/posts/maxkb/</guid><description>MaxKB安装部署教程</description><pubDate>Mon, 10 Nov 2025 21:32:00 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;p&gt;本文讲通过讲述如何使用MaxKB，完成构建适合自己项目的AI模型并实现网站部署。同时讲述一些所遇到的坑。&lt;/p&gt;
&lt;p&gt;技术与环境：Deepseek chat API；MaxKB；Mysql；Docker；Windows11&lt;/p&gt;
&lt;p&gt;前置要求：安装docker&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1&gt;什么是MaxKB？&lt;/h1&gt;
&lt;p&gt;MaxKB是一个强大易用的企业级智能体平台。秉承“开箱即用，伴随成长”的设计理念，MaxKB支持企业快速接入主流大模型，高效构建专属知识库，并且提供从基础知识问答（RAG）、复杂业务流程自动化（Workflow，工作流）到智能体（Agent）的渐进式升级路径。&lt;/p&gt;
&lt;h2&gt;快速接入主流的大模型&lt;/h2&gt;
&lt;p&gt;支持对接各种大语言模型，包括本地私有大模型（DeepSeek/Qwen/Llama等）、国内公共大模型（通义千问/腾讯混元/字节豆包/百度千帆/智谱/Kimi）和国外公共大模型（OpenAI/Claude/Gemini等）。&lt;/p&gt;
&lt;h2&gt;高效构建专属 AI 知识库&lt;/h2&gt;
&lt;p&gt;支持直接上传文档 / 自动爬取在线文档，支持文本自动拆分、向量化，通过 RAG 检索增强生成有效减少大模型幻觉，提升问答效果。&lt;/p&gt;
&lt;h2&gt;零代码实现 AI 工作流编排&lt;/h2&gt;
&lt;p&gt;内置强大的工作流引擎、函数库和 MCP 工具调用能力，满足复杂业务场景下的各种需求。&lt;/p&gt;
&lt;h2&gt;快速嵌入各类系统&lt;/h2&gt;
&lt;p&gt;支持零编码快速嵌入到网站、办公系统（企业微信 / 钉钉 / 飞书）和第三方业务系统，让已有系统快速拥有智能问答能力，提高用户满意度。&lt;/p&gt;
&lt;h1&gt;MaxKB下载&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://docker.aityp.com/image/docker.io/1panel./maxkb:v1.10.3-lts&quot;&gt;官网镜像文档：https://docker.aityp.com/image/docker.io/1panel./maxkb:v1.10.3-lts&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;官方提供不同历史版本的MaxKB，这里选择官方提供Mysql内置连接函数的&lt;strong&gt;v1.10.3-lts&lt;/strong&gt;版本&lt;/p&gt;
&lt;p&gt;&amp;lt;figure&amp;gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202511/maxkb/image-2-1024x545.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;center style=&quot;color:#808080; font-size:15px;&quot;&amp;gt;支持MySQL和PgSQL&amp;lt;/center&amp;gt;&lt;/p&gt;
&lt;h2&gt;安装步骤&lt;/h2&gt;
&lt;p&gt;安装步骤分为拉取镜像，创建卷柜，生成容器&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;①拉取镜像（docker shell 或 CMD）
docker pull swr.cn-north-4.myhuaweicloud.com/ddn-k8s/docker.io/1panel./maxkb:v1.10.3-lts

②创建存储地址（卷柜，用于保存数据持久化）
docker volume create maxkb-data

③运行
docker run -d --name maxkb -p 8080:8080 -v maxkb-data:/var/lib/postgresql/data swr.cn-north-4.myhuaweicloud.com/ddn-k8s/docker.io/1panel./maxkb:v1.10.3-lts

④查看：docker start maxkb    查看运行状态：docker ps
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202511/maxkb/image-3-1024x543.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;访问MaxKb后台&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;地址：127.0.0.1:8080&lt;/li&gt;
&lt;li&gt;账号：admin&lt;/li&gt;
&lt;li&gt;密码：MaxKB@123..&lt;/li&gt;
&lt;/ol&gt;
&lt;h1&gt;DeepSeek API获取&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://platform.deepseek.com/sign_in&quot;&gt;DeepSeek开放平台：https://platform.deepseek.com/sign_in&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202511/maxkb/image-1-1024x421.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;center style=&quot;color:#808080; font-size:15px;&quot;&amp;gt;充值获取API Key，如需免费可使用智谱AI(限时免费)&amp;lt;/center&amp;gt;&lt;/p&gt;
&lt;h1&gt;构建模型&lt;/h1&gt;
&lt;p&gt;在MaxKB后台-系统设置-模型设置中，创建模型&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202511/maxkb/image-5-1024x540.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;center style=&quot;color:#808080; font-size:15px;&quot;&amp;gt;选择模型类型并填写API Key&amp;lt;/center&amp;gt;&lt;/p&gt;
&lt;h1&gt;构建智能体应用&lt;/h1&gt;
&lt;p&gt;在MaxKB后台-应用-创建应用-高级编程-空白应用。创建工作流程台&lt;/p&gt;
&lt;p&gt;流程如下图所示：SQL生成-Mysql查询-AI对话（通过添加组件获取）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202511/maxkb/image-6-1024x484.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;提示词设置&lt;/h2&gt;
&lt;h3&gt;SQL生成&lt;/h3&gt;
&lt;h4&gt;提示词&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;# 数据表结构
# 表 1: 农业气候评估表（ads_agriculture_assessment）

### 表说明
记录各城市农业气候适宜性评估结果，包括适宜性评分、等级、高适宜天数、生长季温度、降水量和种植建议等信息。

### DDL语句
## 农业气候评估表（ads_agriculture_assessment）

CREATE TABLE `ads_agriculture_assessment` (
`id` bigint(20) NOT NULL AUTO_INCREMENT,
`city` varchar(100) COLLATE utf8mb4_unicode_ci NOT NULL,
`year` int(11) NOT NULL,
`suitability_score` double NOT NULL,
`suitability_level` varchar(20) COLLATE utf8mb4_unicode_ci NOT NULL,
`high_suitability_days` int(11) NOT NULL,
`growing_season_temp` double NOT NULL,
`annual_precipitation` double NOT NULL,
`planting_recommendation` varchar(200) COLLATE utf8mb4_unicode_ci NOT NULL,
`update_time` datetime(6) NOT NULL,
PRIMARY KEY (`id`),
UNIQUE KEY `ads_agriculture_assessment_city_year_dc62b076_uniq` (`city`,`year`)
) ENGINE=InnoDB AUTO_INCREMENT=276 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

# 用户问题：
{{开始.question}}

# 回答要求：
– 生成的SQL语句必须符合MYSQL数据库的语法规范。
– 不要使用 Markerdown 和 SQL 语法格式输出，禁止添加语法标准、备注、说明等信息。
– 直接输出符合MySQL标准的SQL语句，用txt纯文本格式展示即可。
– 当前数据库中的时间类字段（如 update_time）均为 DateTime 类型，无需额外转换格式；且生成的 SQL 语句中禁止包含 update_time 字段，不允许对其进行读取或用于筛选等任何操作。
– 生成的 SQL 语句中涉及的城市默认仅为数据库中已存在的粤港澳地区 11 个城市（即香港、澳门、广州、深圳、珠海、佛山、惠州、东莞、中山、江门、肇庆）。
– 禁止查询模型中不存在的字段（如各表中仅包含代码中定义的字段，不可出现未声明的字段名）。
– 数据库中所有数据的年份范围为 2000-2024 年，若需按年份筛选，year字段的取值需在 2000 到 2024 之间（包含首尾年份），例如：WHERE year BETWEEN 2000 AND 2024 或 WHERE year = 2020。
– 生成的查询SQL语句中，所有数值型字段转化为字符串类型。
– 回答的内容不要脱离用户原意。
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;系统角色&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;# 角色
你是一位资深的MYSQL数据库SQL专家，具备深厚的专业知识和丰富的实践经验。你能够精准理解用户的文本描述，并生成准确可执行的SQL语句。

## 技能
### 技能1: 生成SQL语句
1. 仔细分析用户提供的文本描述，明确用户需求。
2. 根据对用户需求的理解，生成符合MYSQL数据库语法的准确可执行的SQL语句。
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;AI对话&lt;/h3&gt;
&lt;h4&gt;提示词&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;# 已经执行的SQL和查询出的SQL结果
{{MySQL 查询.result}}

# 回答要求：
– 根据返回的结果内容，结合用户的问题，按照用户的原意通俗易懂的讲解
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;系统角色&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;#系统角色  
你是一个气象分析专家，可以将sql查询结果用通俗的语言描述出来
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;调试发布&lt;/h2&gt;
&lt;p&gt;记得保存&lt;/p&gt;
&lt;h2&gt;内嵌到网页&lt;/h2&gt;
&lt;p&gt;MaxKB后台-应用-选择创建的应用-概览-嵌入第三方&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202511/maxkb/image-7-1024x510.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h1&gt;问题&lt;/h1&gt;
&lt;p&gt;在整个搭建过程中也是折腾了很久，遇到了如下问题&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;最新版本download下来发现没有Mysql内置函数库&lt;/li&gt;
&lt;li&gt;容器搭建没有进行持久化导致数据丢失&lt;/li&gt;
&lt;li&gt;智能体搭建调试阶段发现，MaxKB调用Mysql返回数据给AI生成最终结果时发现返回的是JSON格式，出现Exception：Object of type Decimal is not JSON serializable；在论坛找到方法是可以通过添加类型转化避免该现象（在SQL生成提示词中加入规则：生成的查询SQL语句中，所有数值型字段转化为字符串类型。）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;参考内容：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/stx_stx/article/details/147135393&quot;&gt;docker本地部署Maxkb（Windows版）_maxkb docker部署-CSDN博客&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/taogumo/article/details/149074392&quot;&gt;就业分析智能体案例(MaxKB+MySQL+函数)_maxkb mysql-CSDN博客&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://bbs.fit2cloud.com/t/topic/12250&quot;&gt;Object of type Decimal is not JSON serializable - MaxKB - 社区论坛 - FIT2CLOUD 飞致云&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最后更新时间：2025/11/10 21:32&lt;/p&gt;
</content:encoded></item><item><title>Lftp断点续传—云服务器后台挂载下载ftp文件</title><link>https://minthana.github.io/blog/posts/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%90%8E%E5%8F%B0%E6%8C%82%E8%BD%BD%E4%B8%8B%E8%BD%BDftp%E6%96%87%E4%BB%B6/</link><guid isPermaLink="true">https://minthana.github.io/blog/posts/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%90%8E%E5%8F%B0%E6%8C%82%E8%BD%BD%E4%B8%8B%E8%BD%BDftp%E6%96%87%E4%BB%B6/</guid><description>断点续传下载ftp文件内容，以国家青藏高原科技数据中心为例</description><pubDate>Sat, 27 Sep 2025 23:07:00 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;p&gt;用于Linux环境（云服务器）下ftp模式文件下载，支持断点续传&lt;/p&gt;
&lt;p&gt;应用场景：下载数据量大，下载速度慢，需要后台挂起&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;Lftp&lt;/h2&gt;
&lt;p&gt;前置工具下载&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 安装lftp（推荐，支持被动模式、批量下载）
yum install lftp -y

# 安装screen（用于创建后台会话，断开连接不中断任务）
yum install screen -y

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;一、连接ftp并下载数据&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 1. 先创建一个后台会话（避免断开连接后任务中断）
screen -S ftp_single  # 会话名可自定义，如ftp_single

# 2. 进入会话后，连接对方FTP服务器
lftp ftp://账号:密码@对方FTP地址:端口
# 示例：lftp ftp://download_4545878:17766766@ftp2.tpdc.ac.cn:6201

# 3. （可选）切换到远程文件所在目录（若文件在根目录可跳过）
cd /remote/path/to/file  # 例如：cd /data/docs

# 4. 下载单个文件到云服务器的本地目录
get 远程文件名 -O /本地保存路径/
# 参数说明：
# - get：lftp的单个文件下载命令
# 远程文件名：如report.pdf、data.zip（需确认远程存在该文件）
# -O：指定本地保存路径（需提前创建，如mkdir -p /local/downloads）
# 示例：get 2023Q1_report.pdf -O /local/downloads/

# 5. 挂起后台会话：按 Ctrl+A → 再按 D（此时任务在后台运行，可断开连接）
 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;二、查看进度 / 恢复会话&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;screen -ls  # 查看所有会话
screen -r ftp_single  # 恢复会话查看下载进度

&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;IDM加速&lt;/h1&gt;
&lt;p&gt;下载IDM之后，利用IDM进行加速下载&lt;/p&gt;
&lt;p&gt;批量导入规则，例如&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;ftp://download_4545878@ftp2.tpdc.ac.cn:6201/Data_forcing_01dy_010deg/shum_CMFD_V0200_B-01_01dy_010deg_20*01-20*12.nc&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;./guide/public/lftp.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</content:encoded></item><item><title>Github 访问失败解决方法</title><link>https://minthana.github.io/blog/posts/github-%E8%AE%BF%E9%97%AE%E5%A4%B1%E8%B4%A5%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</link><guid isPermaLink="true">https://minthana.github.io/blog/posts/github-%E8%AE%BF%E9%97%AE%E5%A4%B1%E8%B4%A5%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</guid><description>修改本机host文件</description><pubDate>Sat, 23 Aug 2025 22:47:00 GMT</pubDate><content:encoded>&lt;ul&gt;
&lt;li&gt;下载host文件&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//raw.hellogithub.com/hosts&quot;&gt;https://link.zhihu.com/?target=https%3A//raw.hellogithub.com/hosts&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用记事本打开复制其中内容&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;./guide/public/githubhosts.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;修改本机host文件 路径地址为（C:\Windows\System32\drivers\etc）&lt;/li&gt;
&lt;li&gt;将本机host文件拖入至桌面（host无法在文件夹内修改）&lt;/li&gt;
&lt;li&gt;将之前复制的内容粘贴到本机host文件中&lt;/li&gt;
&lt;li&gt;保存并将本机host文件放回原来的位置&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;[alert]方法时而有效，虽保持相对稳定的访问，但偶尔仍然会出现无法访问的情况[/alert]&lt;/p&gt;
</content:encoded></item><item><title>Github Pages 搭建静态网页</title><link>https://minthana.github.io/blog/posts/github-pages-%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E7%BD%91%E9%A1%B5/</link><guid isPermaLink="true">https://minthana.github.io/blog/posts/github-pages-%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E7%BD%91%E9%A1%B5/</guid><description>使用Hexo静态架构</description><pubDate>Sat, 23 Aug 2025 22:37:00 GMT</pubDate><content:encoded>&lt;h1&gt;普通网页内容&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;创建账户&lt;/li&gt;
&lt;li&gt;创建仓库：仓库命名格式为 username.github.io  例如rongwu651.github.io&lt;/li&gt;
&lt;li&gt;创建index.html文件&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;./guide/public/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2025-08-23-220441.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;启动Pages服务：仓库-Settings-Pages&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;./guide/public/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2025-08-23-220523.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;等待几分钟，访问网页 &lt;a href=&quot;https://rongwu651.github.io&quot;&gt;https://rongwu651.github.io&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;./guide/public/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2025-08-23-221121.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h1&gt;搭建Hexo博客网站&lt;/h1&gt;
&lt;h2&gt;相关操作&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;hexo new &quot;new blog&quot; # 创建新博客文章(md格式)
hexo generate # 生成静态文件 (可写为 hexo g)
hexo s # 启动本地服务器查看 (http://localhost:4000/)

hexo clean # 清理缓存文件 
hexo ghexo deploy # 部署到 GitHub(可写为 hexo d)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;安装Git并配置账户&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;安装Git&lt;/li&gt;
&lt;li&gt;桌面右键鼠标-显示更多选项-Open Git Bash here&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;./guide/public/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2025-08-23-222135.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;配置账户Github信息&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;# 配置用户名和邮箱
git config --global user.name &quot;github 用户名&quot;
git config --global user.email &quot;github 注册邮箱&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;安装Node.Js&lt;/h2&gt;
&lt;p&gt;安装地址：&lt;a href=&quot;https://nodejs.org/en/download&quot;&gt;https://nodejs.org/en/download&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Windows选择x64 .msi文件，下载后按照指引安装内容（直接下一步）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;./guide/public/nodejsdownload.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;确认是否安装成功（重新打开一个新的Git Bash)&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;# 查询版本
node -v  # 例如：v22.18.0npm -v   # 10.9.3
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;安装Hexo&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;安装客户端至文件所需存放的位置&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;cd D:
mkdir blog # 创建文件夹
cd blog
npm i hexo-cli -g # 安装hexo客户端
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;在上述路径下，初始化Hexo&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;hexo init .
npm install
ls # 查询文件树
 .
├── _config.yml # 网站配置信息
├── package.json # 应用程序信息
├── scaffolds # 模板文件夹
├── source # 存放用户资源
| ├── _drafts
| └── _posts
└── themes # 主题文件夹
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;配置hexo目录下的_config.yml的github账户&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;deploy:
  type: &apos;git&apos;
  repo: https://github.com/username/username.github.io.git  #替换username
  branch: main
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;查看内容&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;./guide/public/hexoweb.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</content:encoded></item><item><title>基于链家网的二手房数据采集清洗与可视化分析</title><link>https://minthana.github.io/blog/posts/%E5%9F%BA%E4%BA%8E%E9%93%BE%E5%AE%B6%E7%BD%91%E7%9A%84%E4%BA%8C%E6%89%8B%E6%88%BF%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86%E6%B8%85%E6%B4%97%E4%B8%8E%E5%8F%AF%E8%A7%86%E5%8C%96%E5%88%86%E6%9E%90/</link><guid isPermaLink="true">https://minthana.github.io/blog/posts/%E5%9F%BA%E4%BA%8E%E9%93%BE%E5%AE%B6%E7%BD%91%E7%9A%84%E4%BA%8C%E6%89%8B%E6%88%BF%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86%E6%B8%85%E6%B4%97%E4%B8%8E%E5%8F%AF%E8%A7%86%E5%8C%96%E5%88%86%E6%9E%90/</guid><description>基于Selenium的链家网数据爬虫、清洗与可视化分析</description><pubDate>Mon, 30 Jun 2025 14:02:00 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;p&gt;个人学习内容笔记，仅供参考。&lt;/p&gt;
&lt;p&gt;项目链接：&lt;a href=&quot;https://gitee.com/rongwu651/lianjia&quot;&gt;https://gitee.com/rongwu651/lianjia&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1&gt;研究内容&lt;/h1&gt;
&lt;p&gt;该课题的主要目的是通过将二手房网站上的存量与已销售房源，构建一个二手房市场行情情况与房源特点的可视化平台。该平台通过HTML架构和Echarts完成可视化的搭建。因此，该课题的主要研究内容就是如何利用相关技术设计并实现这样的平台。&lt;/p&gt;
&lt;p&gt;主要研究的内容如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;相关理论和技术的研究。即对于构建这样的平台需要的理论知识与技术的研究，以及对于搭建该平台的框架认识与了解。并且考虑后续系统所可能的扩展。&lt;/li&gt;
&lt;li&gt;数据爬取与清洗。通过Python开发语言、爬虫和页面解析软件包，结合链家网的页面结构和数据分布情况，对数据进行采集和数据清洗，为可视化提供有效的数据支撑。&lt;/li&gt;
&lt;li&gt;可视化的需求分析。根据最终清洗的数据，从房源特点和客户关注度角度出发，详细分析平台所应当拥有的可视化模块。&lt;/li&gt;
&lt;li&gt;平台的设计与实现。在对平台进行需求分析后，需要对平台进行整体的架构设计，应当考虑到如何用HTML和Echarts完成架构和不同可视化模块的设计&lt;/li&gt;
&lt;/ol&gt;
&lt;h1&gt;相关理论和技术&lt;/h1&gt;
&lt;h2&gt;Selenium与Xpath爬虫模块&lt;/h2&gt;
&lt;p&gt;网络爬虫的核心是模拟用户行为，从目标网站自动提取数据。然而，链家网作为专业房产平台，为保护数据权益和服务器资源，设计了多层反爬机制，主要包括：动态内容渲染，用户行为检测，登录人机验证等。&lt;/p&gt;
&lt;p&gt;针对链家网的反爬特性，本课题选择Selenium 自动化测试框架模拟真实浏览器行为，结合XPath 路径表达式定位动态内容。通过浏览器模拟，手动登录验证，用户行为模仿（滑动滚动、随机等待）规避爬虫风险。通过Xpath定位元素标签，获取页面元素内容。&lt;/p&gt;
&lt;h2&gt;Pandas数据清洗模块&lt;/h2&gt;
&lt;p&gt;爬虫采集的原始数据通常存在大量噪声，直接用于可视化会导致结论偏差。数据清洗的核心目标是通过缺失值处理、异常值修正、格式统一等操作，提升数据质量。&lt;/p&gt;
&lt;p&gt;Pandas 是 Python 生态中专门用于数据处理的库，其DataFrame数据结构支持高效的表格数据操作，针对二手房数据清洗的核心功能包括缺失值处理、异常值检测与修正、数据转换与格式化。&lt;/p&gt;
&lt;h2&gt;Echarts数据可视化模块&lt;/h2&gt;
&lt;p&gt;可视化的核心目标是将清洗后的二手房数据（如价格、面积、区域分布）转化为直观的图表，帮助用户快速发现规律（如 “不同小区的在售房源数量与价格比对”）、识别趋势（如 “市场对房源关注的时间序列趋势”）。&lt;/p&gt;
&lt;p&gt;ECharts 是百度开源的可视化库，支持 100 + 图表类型（柱状图、折线图、热力图、词云等），拥有丰富美观的图表类型、强大的动态交互功能、高度的定制化能力。&lt;/p&gt;
&lt;h1&gt;系统架构&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202506/images/image-47.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;center style=&quot;color:#808080; font-size:15px;&quot;&amp;gt;数据可视化平台结构设计图&amp;lt;/center&amp;gt;&lt;/p&gt;
&lt;h2&gt;爬虫模块&lt;/h2&gt;
&lt;p&gt;爬虫模块用于采集链家网二手房成交数据，包含编号、小区等 12 项字段。技术实现采用 Selenium 驱动 Edge 浏览器，结合 lxml 解析 HTML 与正则表达式提取数据。反爬策略包括随机切换 User-Agent、模拟浏览器尺寸、设置滚动行为及请求间隔，遇验证码时支持人工干预。流程为初始化浏览器后访问列表页，解析房源列表项，提取单条数据并写入 CSV 文件。支持 1-100 页循环爬取，遇异常自动跳过并继续执行，确保数据采集连续性。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202506/images/image-45.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;center style=&quot;color:#808080; font-size:15px;&quot;&amp;gt;爬虫模块流程图&amp;lt;/center&amp;gt;&lt;/p&gt;
&lt;h2&gt;数据清洗和存储模块&lt;/h2&gt;
&lt;p&gt;以在售房源数据清洗存储为例&lt;/p&gt;
&lt;p&gt;1.读取多城市在售数据，检测缺失值（填充NULL），删除重复记录，确保数据唯一性。&lt;/p&gt;
&lt;p&gt;2.格式规范：提取面积、总价、单价的数值（正则匹配）转换为数值类型；发布时间转天数。&lt;/p&gt;
&lt;p&gt;3.拆分户型为 “室”“厅”，对楼层、关注、发布时间、价格、朝向、面积户型等进行分类映射（如楼层等级 关注等级），生成新分析的分类字段。&lt;/p&gt;
&lt;p&gt;4.分类存储：保存各城市 TOP50、全省 TOP100 房源（按关注人数排序）至 CSV，以 JSON 存储不同城市字段分类统计结果，辅助可视化。&lt;/p&gt;
&lt;p&gt;5.数据合并：整合多城市数据，按指定列顺序排列，保存为全省在售数据集（CSV），支持跨城市综合分析。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202506/images/image-46.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;center style=&quot;color:#808080; font-size:15px;&quot;&amp;gt;数据清洗和存储模块流程图&amp;lt;/center&amp;gt;&lt;/p&gt;
&lt;h2&gt;核心数据概览与多维交互模块&lt;/h2&gt;
&lt;p&gt;该需求是可视化平台的 “入口级功能” 与 “核心交互中枢”，通过全局数据概览快速建立用户对二手房市场的整体认知，通过多维筛选与可视化展示引导用户深入探索细分数据，目标是提升用户首次访问的留存率与使用时长，满足 “快速了解→精准筛选→深度分析” 的全链路需求。&lt;/p&gt;
&lt;p&gt;用户进入平台后 5 秒内通过概览数据（如 “深圳当前在售房源 12 万套，平均单价 6.8 万元 /㎡”）快速掌握市场热度；&lt;/p&gt;
&lt;p&gt;数据呈现支持列表 / 地图 / 图表多视图切换，满足不同用户的信息获取习惯（如买家偏好价格区间找房，刚需用户偏好列表对比）；&lt;/p&gt;
&lt;p&gt;支持 10 + 维度交叉筛选（区域 / 价格 / 户型等），实时反馈匹配房源量（如 “南山区 + 3 房 + 500-800 万：匹配 235 套”），降低用户信息检索成本。&lt;/p&gt;
&lt;h2&gt;整体页面架构模块&lt;/h2&gt;
&lt;p&gt;展示层，以数据直观呈现 + 用户友好交互为核心，采用响应式布局适配 PC / 平板 / 手机多端，集成暗黑模式提升视觉舒适度，通过图表组件与交互控件实现数据深度探索。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;响应式设计：基于 Bootstrap 网格系统实现布局自适应，大屏 4 列展示图表、中屏 2 列、小屏 1 列，配合媒体查询动态调整字体大小、统计卡片排列方向（水平→垂直）及图表容器高度，确保不同设备下的内容完整性。&lt;/li&gt;
&lt;li&gt;暗黑模式：通过 CSS 变量定义双主题样式，亮色模式以浅灰为背景、深色为文本，暗黑模式切换为深灰背景、亮白文本；顶部固定切换按钮集成 Bootstrap 图标（月亮 / 太阳），点击后通过data-theme属性 +localStorage实现状态持久化，同时触发 ECharts 图表颜色动态适配。&lt;/li&gt;
&lt;li&gt;动态交互：提供下拉式选择器，提供用户多城市数据切换展示，异步加载json文件内容。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;逻辑层，聚焦数据整合 - 计算 - 渲染流程，通过模块化函数实现数据清洗、图表初始化及主题适配，确保前端展示与用户操作的高效联动。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;图表智能渲染：initCharts函数统一处理 8 类图表（折线图 / 柱状图 / 饼图 / 词云等）的初始化逻辑，动态绑定城市数据（如成交时间生成折线图坐标），支持多图表类型的差异化配置（如词云图shape: &apos;circle&apos;、雷达图indicator动态计算最大值）&lt;/li&gt;
&lt;li&gt;主题动态适配 ：通过html元素的data-theme属性（light/dark）触发全局样式切换，图表组件通过getAttribute(&apos;data-theme&apos;)实时获取主题状态，动态调整 ECharts 配置（如坐标轴文本色、背景色、词云颜色策略），确保视觉一致性。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;数据层，以结构化存储 + 高效传输为目标，支持多城市、多维度成交数据的存储与分发，保障前端可视化的数据源可靠性。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;数据存储：采用 JSON 文件存储各城市成交分类统计结果（如广州_成交分类统计结果.json），包含成交时间、价格区间、户型分布等 10 + 核心字段，支持快速读取与增量更新&lt;/li&gt;
&lt;li&gt;数据流管理：通过静态文件服务提供数据访问接口，fetch请求直接调用目录下的 JSON 文件，避免复杂后端逻辑，降低部署成本&lt;/li&gt;
&lt;li&gt;数据校验：JSON 文件遵循统一格式规范（如成交时间为{日期: 数量}对象、top10小区为包含小区/成交数量等字段的数组），确保initCharts函数可通用解析，减少前端数据清洗成本。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1&gt;可视化结果&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202506/images/image-48-707x1024.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;center style=&quot;color:#808080; font-size:15px;&quot;&amp;gt;首页界面图&amp;lt;/center&amp;gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202506/images/image-49.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;center style=&quot;color:#808080; font-size:15px;&quot;&amp;gt;在售内容部分界面图&amp;lt;/center&amp;gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202506/images/image-50.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;center style=&quot;color:#808080; font-size:15px;&quot;&amp;gt;成交内容部分界面图&amp;lt;/center&amp;gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;参考文章：&lt;a href=&quot;https://blog.csdn.net/qq_46256922/article/details/119087591&quot;&gt;https://blog.csdn.net/qq_46256922/article/details/119087591&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</content:encoded></item><item><title>博客网站流量日志分析系统</title><link>https://minthana.github.io/blog/posts/%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%E6%B5%81%E9%87%8F%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E7%B3%BB%E7%BB%9F/</link><guid isPermaLink="true">https://minthana.github.io/blog/posts/%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%E6%B5%81%E9%87%8F%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E7%B3%BB%E7%BB%9F/</guid><description>实时计算项目</description><pubDate>Mon, 30 Jun 2025 13:26:00 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;p&gt;前言：作为经营博客网站的一名大数据专业的大学生，个人博客不仅是展示技术见解、记录学习历程和分享生活感悟的重要窗口，更是连接志同道合者的数字桥梁。随着博客内容的丰富与访问量的逐步增长，理解“谁在访问”、“如何访问”以及“关注什么”变得至关重要。这些信息蕴含在服务器持续产生的访问日志中，是优化内容策略、提升用户体验、规划未来发展的核心数据资产。&lt;br /&gt;
因此，我将通过对网站访问者的请求访问进行数据收集，对实时流量趋势分析（如各国访问量、不同操作系统用户偏好、热门设备分布）的需求，设计并实现一套实时流量日志分析系统，通过技术手段实现数据采集、实时处理、多维度聚合及可视化展示，为运营决策提供数据支撑。&lt;/p&gt;
&lt;p&gt;用于数据内容涉及用户隐私，因此不提供数据集内容，个人学习内容笔记，仅供参考。&lt;/p&gt;
&lt;p&gt;项目链接：&lt;a href=&quot;https://gitee.com/rongwu651/bokeshishi&quot;&gt;https://gitee.com/rongwu651/bokeshishi&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1&gt;研究内容&lt;/h1&gt;
&lt;p&gt;​	本课题的核心目标是构建一个高效、实时的博客网站流量日志分析系统。该系统通过多维度数据采集、实时处理与聚合分析，实现对网站流量的深度洞察，帮助我快速掌握流量分布特征。课题的主要研究内容围绕如何利用大数据技术设计并实现高可靠、可扩展的实时分析系统，具体包括：&lt;/p&gt;
&lt;p&gt;主要研究的内容如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;针对大数据实时计算框架Kafka、zookeeper、storm，该如何设计系统架构，同时根据业务需求完成整套数据实时计算处理的实现。&lt;/li&gt;
&lt;li&gt;系统的设计与实现。在对业务进行需求分析后，需要对系统进行整体的架构设计，应当考虑到如何用分层架构思想完成系统架构设计。之后，依据这些设计对系统进行落地实现。&lt;/li&gt;
&lt;li&gt;核心功能实现细节与问题发现。针对各模块核心功能如何实现进行讲解，同时对开发过程中存在的问题进行简要概述问题与其解决方案。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1&gt;系统架构设计&lt;/h1&gt;
&lt;p&gt;​	本课题的主要内容是采用 “数据采集→消息传输→实时处理→存储→查询” 的分层设计，核心组件包括 Kafka（消息队列）、Apache Storm（实时计算）、HBase（分布式存储）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202506/images/image-29.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;center style=&quot;color:#808080; font-size:15px;&quot;&amp;gt;博客网站流量日志分析系统结构设计图&amp;lt;/center&amp;gt;&lt;/p&gt;
&lt;h2&gt;数据采集传输层&lt;/h2&gt;
&lt;p&gt;​	我们通过后台导出日志CSV文件并保存至项目中， 创建kafka生产者读取传输类CsvDataProducer，通过连接Kafka主题，读取并将CSV文件内容转为JSON格式，并按照日期作为分区依据写入到Kafka中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202506/images/image-30.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;center style=&quot;color:#808080; font-size:15px;&quot;&amp;gt;原数据CSV字段表&amp;lt;/center&amp;gt;&lt;/p&gt;
&lt;h2&gt;计算Bolt层&lt;/h2&gt;
&lt;h3&gt;IP定位Bolt&lt;/h3&gt;
&lt;p&gt;​	我们内置集成了功能强大的 MaxMind GeoIP2 数据库，它能提供准确的 IP 地理定位信息。将 IpLocationBolt 类作为第一层 Bolt，其主要职责是从 Kafka 消息队列读取信息。Kafka 消息队列接收的消息是 JSON 格式，IpLocationBolt 会使用 JSON 解析器从中提取 IP 字段。接着，借助 GeoIP2 数据库查询该 IP 对应的国家或地区信息。为确保数据处理的完整性和连贯性，它会将原始消息和查询到的国家或地区信息组合成新的元组输出，供后续的 Bolt 进行处理。&lt;/p&gt;
&lt;h3&gt;解析Bolt&lt;/h3&gt;
&lt;p&gt;​	我们把DataParseBolt 类作为第二层 Bolt。该 Bolt 接收来自第一层 IpLocationBolt 输出的元组，使用 JSON 解析器对输入元组中的 JSON 数据进行解析，从中提取出如日期、点击量、浏览器类型等关键数据。在日期处理方面，会把提取到的日期格式转换为统一格式，以方便后续的聚合和处理操作。最后，将处理后的数据重新组合成新的元组发射出去，以便后续不同类型的聚合 Bolt 进行针对性计算。&lt;/p&gt;
&lt;h3&gt;聚合Bolt&lt;/h3&gt;
&lt;p&gt;​	在第三层 Bolt 中，我们构建了 DailyCountrySumBolt、DailyPlatformAvgBolt、DailyDeviceMaxBolt 和 DailyAgentSumBolt 四个类，它们在整个数据处理流程中承担着关键的聚合任务。这些类会对第二层 DataParseBolt 解析出的详细数据进行进一步的聚合计算，从而满足不同的业务需求。具体如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;DailyCountrySumBolt：使用 date_key#country 作为组合键，精准聚合每日每个国家的总点击量，能清晰呈现不同国家每天的业务活跃度。&lt;/li&gt;
&lt;li&gt;DailyPlatformAvgBolt：以 date_key#platform 作为组合键，采用双 Map 机制，分别记录总点击量和记录数，动态计算每日每个操作系统的平均点击量，有助于了解不同操作系统用户的平均点击行为。&lt;/li&gt;
&lt;li&gt;DailyDeviceMaxBolt：通过 date_key#device 键值，实时计算每日每个设备的最高点击量，方便识别特定日期下哪些设备的点击活跃度最高。&lt;/li&gt;
&lt;li&gt;DailyAgentSumBolt：以 date_key#agent 为维度，聚合每日每个浏览器的总点击量，可用于分析不同浏览器的用户使用情况。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;存储层&lt;/h3&gt;
&lt;p&gt;​	存储层是整个实时分析系统的核心基础设施，负责持久化聚合结果并支持高效查询。本系统采用HBase作为主存储引擎，通过精心设计的表结构、写入策略和查询优化，满足多维度聚合数据的存储需求。以下是存储层模型的架构设计：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202506/images/image-31.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;center style=&quot;color:#808080; font-size:15px;&quot;&amp;gt;Hbase设计表&amp;lt;/center&amp;gt;&lt;/p&gt;
&lt;h3&gt;查询层&lt;/h3&gt;
&lt;p&gt;我们在HBaseDataReader通过构建多维度的数据查询引擎，封装了从HBase中读取四种聚合结果的统一接口。通过日期传参可获取当天的多维度数据内容。&lt;/p&gt;
&lt;h1&gt;核心功能实现细节&lt;/h1&gt;
&lt;p&gt;​	基于上述系统架构设计，本章将对其技术方案做出更详细的策划与实现，并阐述实现过程所遇的问题以及改进方案。本系统基于 Apache Storm 框架构建的流式数据处理系统，对从 Kafka 消息队列接收到的数据进行一系列处理，包括 IP 定位、数据解析、多维度数据聚合，最终将聚合结果存储到 HBase 数据库中。系统的主要业务目标是满足不同维度的数据分析需求，如每日国家总点击量、每日系统平均点击量、每日设备最大点击量和每日浏览器总点击量的统计。&lt;/p&gt;
&lt;h2&gt;数据生产&lt;/h2&gt;
&lt;h3&gt;CSV数据读取与Kafka消息生成&lt;/h3&gt;
&lt;p&gt;通过系统架构设计说明结合数据特征与业务需求， CsvDataProducer 类负责从 CSV 文件读取数据并发送到 Kafka 主题。具体实现步骤如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;配置 Kafka 生产者的属性，包括服务器地址与端口、序列化器、消息确认机制和重试次数。&lt;/li&gt;
&lt;li&gt;使用 CsvReader 读取资源目录中的CSV文件，提取数据内容（包括日期、浏览器类型、操作系统类型、设备、IP 地址和点击次数）并转化为JSON格式。&lt;/li&gt;
&lt;li&gt;创建ProducerRecord生产者，设置日期作为分区发送消息，并且处理发送结果。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202506/images/image-32.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;center style=&quot;color:#808080; font-size:15px;&quot;&amp;gt;CsvDataProducer核心代码&amp;lt;/center&amp;gt;&lt;/p&gt;
&lt;h2&gt;数据处理拓扑&lt;/h2&gt;
&lt;h3&gt;Kafka数据消费&lt;/h3&gt;
&lt;p&gt;我们通过构建DataAggregationTopology 类配置了 KafkaSpout 来消费 Kafka 主题中的数据，构建“生产者——消费者”体系架构。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用 KafkaSpoutConfig 构建 KafkaSpout 的配置，指定 Kafka 服务器地址、主题名称、消费者组 ID 和偏移量重置策略。&lt;/li&gt;
&lt;li&gt;同时使用TopologyBuilder设置 KafkaSpout 作为拓扑的数据源。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202506/images/image-33.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;center style=&quot;color:#808080; font-size:15px;&quot;&amp;gt;Kafka消费者启动代码&amp;lt;/center&amp;gt;&lt;/p&gt;
&lt;h3&gt;IP地理位置解析&lt;/h3&gt;
&lt;p&gt;​	由于网站配置的IP地理位置解析器过旧，解析数据内容存在一定偏差，因此使用较新版本的GeoIP2 数据库，构建IpLocationBolt 类从 KafkaSpout 接收原始消息，解析 IP 地址并查询其地理位置。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;通过初始化 GeoIP2 数据库读取器和 JSON 解析器，将上层交付的输入元组中获取原始数据内容，提取IP字段，通过GeoIP2查询并获取国家或地区名称信息。&lt;/li&gt;
&lt;li&gt;最后输出包含原始消息和国家名称的新元组至下一层Bolt。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202506/images/image-34.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;center style=&quot;color:#808080; font-size:15px;&quot;&amp;gt;IP解析国家或地区核心代码&amp;lt;/center&amp;gt;&lt;/p&gt;
&lt;h3&gt;数据解析&lt;/h3&gt;
&lt;p&gt;针对我们的业务需求，为后续数据聚合分析做准备，DataParseBolt 类将从 ip-location-bolt 获取原始消息，解析关键数据并输出需要的字段。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;从输入元组中获取原始消息和国家名称，解析 JSON 并提取日期、点击次数、浏览器、操作系统、设备等字段。&lt;/li&gt;
&lt;li&gt;将日期格式转化为yyyyMMdd，便于后续聚合分析。&lt;/li&gt;
&lt;li&gt;输出扩展后的数据内容字段，交付给下层聚合。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202506/images/image-35.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;center style=&quot;color:#808080; font-size:15px;&quot;&amp;gt;数据解析核心代码&amp;lt;/center&amp;gt;&lt;/p&gt;
&lt;h3&gt;数据聚合&lt;/h3&gt;
&lt;p&gt;​	根据系统架构和业务需求，数据聚合是整个系统的核心处理环节，主要负责对经过解析和处理后的数据按照不同的维度（日期和特定的业务维度，如国家、系统、设备、浏览器）进行聚合计算，得到相应的指标值（总点击量、平均点击量、最大点击量）。该环节由多个 Bolt 类协同完成，每个 Bolt 类负责处理特定维度的聚合任务。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;状态维护。根据不同运算结果，使用不同的数值类型。同时使用Map数据结构，存储维护日期与不同维度组合的值（例如Map&amp;lt;String, Long&amp;gt;，date#country）&lt;/li&gt;
&lt;li&gt;聚合逻辑。通过不同业务需求所需要的指标值，完成累加、平均计算、最大值比较等操作完成聚合操作与数值更新。&lt;/li&gt;
&lt;li&gt;最后将聚合后的结果作为新的元组发送给下层进行处理。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202506/images/image-37.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;center style=&quot;color:#808080; font-size:15px;&quot;&amp;gt;数据聚合核心思路代码&amp;lt;/center&amp;gt;&lt;/p&gt;
&lt;p&gt;以DailyAgentSumBolt每日浏览器总点击量为例：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;通过业务需求，提取上层交付的元组中的关键字段。&lt;/li&gt;
&lt;li&gt;构建日期+浏览器类型维度组合作为聚合键。&lt;/li&gt;
&lt;li&gt;利用Map数据结构和计算逻辑，实现聚合（累加）内容更新。&lt;/li&gt;
&lt;li&gt;最终将数据结果实时发送，完成实时更新。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;数据存储与查询&lt;/h2&gt;
&lt;h3&gt;Hbase写入&lt;/h3&gt;
&lt;p&gt;在存储层中，我们设计了对不同维度的数据内容存储的数据模型，通过上层交付的数据，HBaseWriteBolt 类将从各个聚合 Bolt 接收聚合结果，并将其写入 HBase 表：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;创建Hbase连接和表名、列名常量字段。&lt;/li&gt;
&lt;li&gt;通过映射方法getTargetTable，根据源组件名称映射到对应的 HBase 表。&lt;/li&gt;
&lt;li&gt;通过映射方法getTargetColumn，根据源组件名称映射到对应的列。&lt;/li&gt;
&lt;li&gt;确认好映射结果目标，通过Put对象将数据写入相对应的Hbase表中&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202506/images/image-38.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;center style=&quot;color:#808080; font-size:15px;&quot;&amp;gt;来源组件映射表转化代码&amp;lt;/center&amp;gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202506/images/image-39.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;center style=&quot;color:#808080; font-size:15px;&quot;&amp;gt;Hbase数据写入核心代码&amp;lt;/center&amp;gt;&lt;/p&gt;
&lt;h3&gt;Hbase数据读取&lt;/h3&gt;
&lt;p&gt;上一节我们通过将不同维度的数据存储在不同的数据表中，为方便读取不同表中的数据，通过编写一个泛类读取方法，接收表名和日期参数，获取对应结果值。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;通过substring(date.length() + 1) 去掉日期前缀，提取维度值。&lt;/li&gt;
&lt;li&gt;利用条件语句逻辑，根据表类型确认读取的数值类型。&lt;/li&gt;
&lt;li&gt;最后通过接口调用，获取查询数据结果内容。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202506/images/image-40.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;center style=&quot;color:#808080; font-size:15px;&quot;&amp;gt;Hbase读取条件筛选核心代码&amp;lt;/center&amp;gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202506/images/image-41-1024x188.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;center style=&quot;color:#808080; font-size:15px;&quot;&amp;gt;Hbase读取接口核心代码&amp;lt;/center&amp;gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202506/images/image-42.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;center style=&quot;color:#808080; font-size:15px;&quot;&amp;gt;Hbase读取接口调用代码&amp;lt;/center&amp;gt;&lt;/p&gt;
&lt;h1&gt;部分结果展示&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202506/images/image-43.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</content:encoded></item><item><title>基于ElasticSearch的二手房搜索与数据分析可视化系统</title><link>https://minthana.github.io/blog/posts/%E5%9F%BA%E4%BA%8Eelasticsearch%E7%9A%84%E4%BA%8C%E6%89%8B%E6%88%BF%E6%90%9C%E7%B4%A2%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%8F%AF%E8%A7%86%E5%8C%96%E7%B3%BB%E7%BB%9F/</link><guid isPermaLink="true">https://minthana.github.io/blog/posts/%E5%9F%BA%E4%BA%8Eelasticsearch%E7%9A%84%E4%BA%8C%E6%89%8B%E6%88%BF%E6%90%9C%E7%B4%A2%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%8F%AF%E8%A7%86%E5%8C%96%E7%B3%BB%E7%BB%9F/</guid><description>本系统采用Elasticsearch作为二手房数据的搜索、存储和分析引擎，利用Kibana平台完成数据检索分析和数据可视化大屏的搭建。</description><pubDate>Fri, 27 Jun 2025 17:54:00 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;p&gt;版本: Elasticsearch7.10.0&lt;/p&gt;
&lt;p&gt;前言:&lt;/p&gt;
&lt;p&gt;随着房地产市场的逐步成熟以及互联网技术的飞速发展，二手房交易市场呈现出线上化、智能化的显著趋势。越来越多的购房者和售房者倾向于通过二手房平台获取信息、完成交易。为了更加满足目标客户群体筛选房源数据并且快速预览当前市场行情的数据统计情况。因此，开发本系统完成条件筛选房源检索和数据可视化大屏等主要功能。 为了实现上述功能，本系统采用Elasticsearch作为二手房数据的搜索、存储和分析引擎，利用Kibana平台完成数据检索分析和数据可视化大屏的搭建。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;数据来源:广东省链家网二手房在售房源(2w+)&lt;/p&gt;
&lt;h1&gt;系统架构设计&lt;/h1&gt;
&lt;p&gt;ElasticSearch搜索引擎与Kibana分析可视化平台&lt;/p&gt;
&lt;p&gt;​	对存储在传统的关系型和非关系型数据库的数据，筛选条件检索获取数据并不高效和方便，利用ElasticSearch可以高效筛选获取数据，同时其水平扩展性的优点为系统未来发展和扩展提供便携性。 同时Kibana作为 Elasticsearch设计的开源分析和可视化平台，通过友善美观的界面、简化方便的REST API调用，帮助我们完成数据分析、数据检索以及数据可视化等场景的系统搭建。&lt;/p&gt;
&lt;h2&gt;数据基础操作与检索功能&lt;/h2&gt;
&lt;p&gt;本系统最大的特点之一就是实现存储在ElasticSearch的数据进行增删查改、相关查询、检索高亮和聚合分析功能。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202506/images/image-7.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;​	在ElasticSearch官方提供的REST API中，我们可以使用Kibana的开发工具，通过简单的HTTP请求，使用执行简短的JSON格式代码，完成对ElasticSearch的交互以及数据索引映射，数据存储、数据检索和数据分析操作等多场景功能，丰富我们的系统业务功能。本系统中，我们将采用REST API，实现基础的数据增删查改；布尔、范围、模糊查询等高级功能；以及对数据的检索高亮和聚合分析处理。帮助我们快速获取了解目标房源信息内容。&lt;/p&gt;
&lt;h2&gt;数据可视化大屏&lt;/h2&gt;
&lt;p&gt;通过Kibana，我们将基于房源数据，通过创建全局条件筛选控件，以及多维度数据分析与可视化，完成以下多表可视化大屏功能展示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202506/images/es%E5%8F%AF%E8%A7%86%E5%8C%96%E6%9E%B6%E6%9E%84.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;​	Kibana通过交互式可以快速完成对数据不同属性或多维度图表的设计和渲染。通过清洗后的二手房源数据信息内容，我们将通过Kibana提供的可视化图表模板，完成TOP小区与平均单价的柱状折线图、关注人数与发布区间关联的柱状图、单价与总价区间的饼图和树状图、区域频率云图、楼层等级与装修情况堆叠条形图、面积户型与室厅、朝向分类的面积图等构建可视化大屏。&lt;/p&gt;
&lt;h1&gt;索引设计说明&lt;/h1&gt;
&lt;p&gt;通过对链家网的数据爬取和清洗，生成的最终数据包含房源多个信息内容值。其中包括以下内容：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202506/images/%E7%B4%A2%E5%BC%95%E8%AE%BE%E8%AE%A1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;​	本索引设计专为房产数据存储与检索打造，旨在满足多元业务需求。字段类型依数据特性设定，“关注人数”“单价” 等整数型数据采用 “long” 类型，既保证数值范围，又便于快速计算；“总价”“面积” 等含小数的数据用 “double” 类型，确保精确存储与计算。“关注等级”“区域” 等分类或区间字段用 “keyword” 类型，支持精确匹配与聚合统计；“标题” 字段用 “text” 类型，实现全文检索。&lt;/p&gt;
&lt;p&gt;​	充分发挥数据优势，设计合理的字段类型配置让数据检索高效，无论是数值筛选还是分类匹配都能快速响应。清晰的字段定义利于数据规范化管理，减少错误与冗余。同时，其兼容性强，方便应对后续业务拓展和字段新增。通过此设计，可大幅提升房产数据处理效率，为房产信息系统稳定运行和业务发展提供坚实支撑。&lt;/p&gt;
&lt;h1&gt;系统详细设计与实现&lt;/h1&gt;
&lt;h2&gt;CRUD&lt;/h2&gt;
&lt;h3&gt;创建索引&lt;/h3&gt;
&lt;p&gt;利用ElasticSearch提供的官方REST API和Kibana平台提供执行窗口。构建创建zaishou索引的代码，完成对索引的构建，并且通过Kibana平台直接导入数据。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#删除索引 
DELETE /zaishou
# 构建索引
PUT /zaishou
{
  &quot;mappings&quot;: {
    &quot;properties&quot;: {
      &quot;新编号&quot;: {
        &quot;type&quot;: &quot;keyword&quot;,
        &quot;index&quot;: true,
        &quot;doc_values&quot;: true
      },
      &quot;标题&quot;: {&quot;type&quot;: &quot;text&quot;},
      &quot;城市&quot;: {&quot;type&quot;: &quot;keyword&quot;},
      &quot;区域&quot;: {&quot;type&quot;: &quot;keyword&quot;},
      &quot;小区名称&quot;: {&quot;type&quot;: &quot;keyword&quot;},
      &quot;室&quot;: {&quot;type&quot;: &quot;long&quot;},
      &quot;厅&quot;: {&quot;type&quot;: &quot;long&quot;},
      &quot;户型&quot;: {&quot;type&quot;: &quot;keyword&quot;},
      &quot;面积&quot;: {&quot;type&quot;: &quot;double&quot;},
      &quot;面积户型&quot;: {&quot;type&quot;: &quot;keyword&quot;},
      &quot;朝向&quot;: {&quot;type&quot;: &quot;keyword&quot;},
      &quot;朝向分类&quot;: {&quot;type&quot;: &quot;keyword&quot;},
      &quot;楼层&quot;: {&quot;type&quot;: &quot;keyword&quot;},
      &quot;楼层等级&quot;: {&quot;type&quot;: &quot;keyword&quot;},
      &quot;装修情况&quot;: {&quot;type&quot;: &quot;keyword&quot;},
      &quot;总价&quot;: {&quot;type&quot;: &quot;double&quot;},
      &quot;总价区间&quot;: {&quot;type&quot;: &quot;keyword&quot;},
      &quot;单价&quot;: {&quot;type&quot;: &quot;long&quot;},
      &quot;单价区间&quot;: {&quot;type&quot;: &quot;keyword&quot;},
      &quot;关注人数&quot;: {&quot;type&quot;: &quot;long&quot;},
      &quot;关注等级&quot;: {&quot;type&quot;: &quot;keyword&quot;},
      &quot;发布时间&quot;: {&quot;type&quot;: &quot;long&quot;},
      &quot;发布区间&quot;: {&quot;type&quot;: &quot;keyword&quot;}
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;数据的插入&lt;/h3&gt;
&lt;p&gt;根据索引映射和数据内容：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;对单条数据使用POST /zaishou/_doc/{索引ID}&lt;/li&gt;
&lt;li&gt;对多条数据使用POST /zaishou/_bulk&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202506/images/image-8.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;数据的修改&lt;/h3&gt;
&lt;p&gt;根据索引映射、数据内容和业务需求：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;通过 POST /zaishou/_update/{索引ID}/&lt;/li&gt;
&lt;li&gt;通过POST /zaishou/_bulk&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202506/images/image-11.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;数据的删除&lt;/h3&gt;
&lt;p&gt;根据索引映射、数据内容和业务需求：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;删除单条数据通过 DELETE/zaishou/_doc/{索引ID}/&lt;/li&gt;
&lt;li&gt;删除多条数据使用POST /zaishou/_bulk&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202506/images/image-12.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;高级查询&lt;/h2&gt;
&lt;h3&gt;布尔查询&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;通过bool查询组合多维度条件，确保结果精准匹配需求&lt;/li&gt;
&lt;li&gt;利用must，限定房源所在城市为“东莞”，户型为 “3 室 2 厅”，这两个条件为检索的基础前提&lt;/li&gt;
&lt;li&gt;通过filter过滤器，对总价进行range范围筛选，要求总价≥200 万且≤500 万&lt;/li&gt;
&lt;li&gt;通过match_not排除标题包含“老破小” 的房源，避免无关结果干扰&lt;/li&gt;
&lt;li&gt;按总价升序排列（asc），并限制返回前10 条，便于优先查看低价房源&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202506/images/image-13.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;范围查询&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;通过多条件范围range筛选，利用bool查询组合多维度条件&lt;/li&gt;
&lt;li&gt;使用must限定珠海城市范围的数据内容&lt;/li&gt;
&lt;li&gt;筛选面积范围在90-150 平方米，总价限制低于 300万元，发布时间在30-60天内的房源数据&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202506/images/image-14.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;模糊查询&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;使用通配符wildcard，查询匹配标题中包含 &quot;学&quot; 和 &quot;房&quot; 的任意文本，匹配&quot;学区房&quot;、&quot;学校附近房&quot;、&quot;学区好房&quot; 等多种变体。实现模糊查询&lt;/li&gt;
&lt;li&gt;根据索引设置，标题为text类型，使用match对 &quot;学区房&quot; 进行标准分词匹配&lt;/li&gt;
&lt;li&gt;通过should 连接两种条件，满足任一条件即可返回结果，提高准确率和召回率&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202506/images/image-15.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;高亮显示与聚合分析&lt;/h2&gt;
&lt;h3&gt;高亮显示&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;多字段同时在“标题”和“户型”查找关键字&lt;/li&gt;
&lt;li&gt;通过highlight用&amp;lt;strong&amp;gt;标签标记匹配字段内容，实现高亮显示&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202506/images/image-16.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;聚合分析&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;筛选广州城市，根据区域进行聚合处理，并且升序排序&lt;/li&gt;
&lt;li&gt;对筛选分组后的组进行平均总价和平均单价计算，完成聚合分析&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202506/images/image-17.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用嵌套聚合操作，外层聚合该城市的文档总数，内层聚合该城市的关注人数总和。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202506/images/image-18.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;通过自定义区间范围，对文档进行聚合分类分析，完成对面积大小的分类统计&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202506/images/image-19.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;用户行为分析&lt;/h2&gt;
&lt;p&gt;​	通过对筛选城市的人群对二手房源的关注程度进行分析，分析目标用户喜好，通过筛选获取广州城市近三个月发布的存量房源，利用聚合函数统计出前十的该城市热门小区及其平均总价和平均面积，户型分布情况，关注人数总和在售房源数量了解不同小区的销售和市场行情情况。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202506/images/image-20.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;数据可视化大屏&lt;/h2&gt;
&lt;h3&gt;自定义字段显示和过滤条件设置&lt;/h3&gt;
&lt;p&gt;​	数据集中存在着大量不同城市数据，同时通过市场产品调研，发现市面上的产品均提供了对发布时间、单价区间等条件筛选的选择器。因此我们将通过上面的调研结果，为用户提供城市、发布时间、单价、室厅数量选择器。帮助用户自定义筛选房源内容。同时用户可以根据Kibana平台自定义筛选条件内容。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202506/images/image-21.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;TOP小区市场行情与发布区间关注度对比&lt;/h3&gt;
&lt;p&gt;​	通过Kibana可视化模板，我们针对数据特征及其分布情况，筛选出存量房源数量TOP20的小区生成柱状图分布表，并计算出其各个小区的平均单价生成折线趋势表。&lt;/p&gt;
&lt;p&gt;​	通过聚合不同发布区间的房源数量及其对该时间段关注人数进行统计生成条形图。&lt;/p&gt;
&lt;p&gt;​	为用户提供直观的对比，于此同时可根据自定义筛选条件动态查询结果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202506/images/image-22.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202506/images/image-23.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;单价、总价区间与高频区域云图&lt;/h3&gt;
&lt;p&gt;​	通过Kibana可视化平台提供的模板，结合数据分布特征和业务需求。我们针对不同区间段的数据进行分类统计求和。利用饼图、树状图、云图，展示当前市场下，平均总价、平均单价和热门区域的分布情况。为用户提供直观的数据预览。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202506/images/image-24.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202506/images/image-25.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;楼层等级与装修情况&lt;/h3&gt;
&lt;p&gt;​	通过Kibana可视化平台提供的模板，结合数据分布特征，我们将挖掘出存量二手房在楼层等级与装修情况下的潜在关系，并利用堆叠条形图，进行可视化展示。帮助销售人员或其他相关人员快速了解潜在关系。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202506/images/image-26.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;面积户型与户型格局、朝向分类&lt;/h3&gt;
&lt;p&gt;​	通过Kibana可视化平台提供的模板，结合数据分布特征，借鉴前小节的思路，我们察觉到面积户型同户型格局、朝向分类的潜在关系，是提高消费者或其他人员的关注度的重要因素条件之一。因此针对上述思路，我们通过面积户型与户型格局、朝向分类之间的比对，生成相对应的面积图。为用户提供具有参考意义的可视化图形。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202506/images/image-27.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;可视化大屏总体布局设计&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202506/images/image-28.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h1&gt;迁移数据&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;POST _reindex
{
  &quot;source&quot;: {
    &quot;index&quot;: &quot;original_index&quot;  // 原索引名称
  },
  &quot;dest&quot;: {
    &quot;index&quot;: &quot;new_index&quot;       // 新索引名称，需提前构建
  },
  &quot;script&quot;: {
    &quot;source&quot;: &quot;&quot;&quot;
      // 设置文档ID = &quot;新编号&quot;的值
      ctx._id = ctx._source.新编号; 
      
      // 可选：从_source中移除&quot;新编号&quot;字段（避免重复存储）
      ctx._source.remove(&quot;新编号&quot;);
    &quot;&quot;&quot;
  }
}

#验证结果
GET /new_index/_search
{
  &quot;query&quot;: { &quot;match_all&quot;: {} }
}

DELETE /original_index  #删除旧索引
POST _aliases
{
  &quot;actions&quot;: [
    { &quot;add&quot;: { &quot;index&quot;: &quot;new_index&quot;, &quot;alias&quot;: &quot;original_index&quot; } } #修改别名
  ]
}

&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>心晴网书籍数据爬取、分析及可视化</title><link>https://minthana.github.io/blog/posts/%E5%BF%83%E6%99%B4%E7%BD%91%E4%B9%A6%E7%B1%8D%E6%95%B0%E6%8D%AE%E7%88%AC%E5%8F%96%E5%88%86%E6%9E%90%E5%8F%8A%E5%8F%AF%E8%A7%86%E5%8C%96/</link><guid isPermaLink="true">https://minthana.github.io/blog/posts/%E5%BF%83%E6%99%B4%E7%BD%91%E4%B9%A6%E7%B1%8D%E6%95%B0%E6%8D%AE%E7%88%AC%E5%8F%96%E5%88%86%E6%9E%90%E5%8F%8A%E5%8F%AF%E8%A7%86%E5%8C%96/</guid><description>利用Scrapy框架结合Splash＋Docker进行动态页面爬虫，通过Django实现数据分析与可视化的搭建</description><pubDate>Mon, 23 Jun 2025 23:28:00 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;p&gt;本项目聚焦于心理学专业网站 &quot;&lt;a href=&quot;http://ixinqing.com/&quot;&gt;心晴网&lt;/a&gt;&quot; 的书籍数据，通过网络爬虫技术批量获取平台上的心理学书籍信息，构建包含书籍基本属性（书名、作者、出版社、简介、URL）、内容特征（标签、价格）、用户评价（收藏数、推荐数）等多维度的数据集。在数据获取基础上，运用数据清洗、文本挖掘、统计分析等技术手段，对心理学书籍的主题分布、用户偏好等进行简单剖析。最终通过交互式可视化工具，将分析结果以图表、选择器等形式直观呈现，实现对心晴网心理学书籍数据的系统化解读与应用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;项目源代码地址：&lt;a href=&quot;https://gitee.com/rongwu651/pachong&quot;&gt;https://gitee.com/rongwu651/pachong&lt;/a&gt;&lt;/p&gt;
&lt;h1&gt;设计思路&lt;/h1&gt;
&lt;p&gt;本项目采用 &quot;数据采集 - 清洗治理 - 深度分析 - 可视化呈现&quot; 的闭环式技术路线，以心理学专业领域知识为导向，结合自然语言处理与数据可视化技术，实现从原始数据到知识发现的全流程价值转化。具体设计思路如下：&lt;/p&gt;
&lt;h2&gt;数据采集层&lt;/h2&gt;
&lt;h3&gt;目标网站解析和反爬策略&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;目标网站解析和反爬策略&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;通过浏览器开发者工具解析心晴网书籍列表页、详情页的 HTML 结构，识别动态加载组件（如价格内容通过JavaScript渲染），确定数据抓取入口；&lt;/p&gt;
&lt;p&gt;同时，设置随机请求头（User-Agent、Referer）模拟真实浏览器行为、设置自动限速功能，动态调整请求频率，避免高频访问触发 IP 封禁。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;多维度数据抓取&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;利用爬虫架构技术实现对目标网站页面架构内容获取，对于静态干净内容，直接通过定位标签元素解析获取数据内容。对于动态内容，结合网页渲染工具实时爬取数据内容。对于存在一定文本干扰的数据内容，采用正则表达式进行数据采集。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;数据存储&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;对于爬取的数据，通过数据管道，根据数据类型，合理的存储在结构化数据库中。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;数据清洗层&lt;/strong&gt;&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;基础数据清洗&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;对关键字段（如标题、作者、出版社）的数据进行数据缺失值、重复值检查与处理。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;文本数据处理&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;对于标签内容缺失的数据，通过 jieba 分词预处理文本，利用已分类书籍训练 TF-IDF 向量化器构建标签向量库，对未分类书籍文本向量化后计算与标签向量的余弦相似度，按阈值筛选高匹配标签，不足时用 TextRank 提取关键词补充，最终输出推荐标签并统计分布，实现标签智能推荐。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;数据分析与可视化层&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;利用Django项目构建数据模型，并将清洗后的数据迁移至此。通过前后端分离架构设计，在后端实现多维度数据分析(主要以统计聚合为主)并输出结构化分析数据，前端采集后端数据并利用Echarts进行可视化图表渲染。同时设计选择器完成数据动态渲染。&lt;/p&gt;
&lt;h1&gt;&lt;strong&gt;技术选型&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;在技术选型中，爬虫、数据分析与可视化采用 Python 具有显著优势。Python 语法简洁易读，开发效率高，大量开源项目与第三方库降低开发成本，其与机器学习框架的无缝衔接，更能为数据全流程处理提供完整解决方案。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;爬虫架构&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&amp;lt;figure&amp;gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;技术&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;用途说明&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;优势特点&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Scrapy&lt;/td&gt;
&lt;td&gt;核心爬虫框架，负责爬取逻辑、调度、数据提取与存储&lt;/td&gt;
&lt;td&gt;高效并发调度，组件化设计易扩展&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Splash&lt;/td&gt;
&lt;td&gt;动态渲染工具，处理 JS 加载的数据（如价格）&lt;/td&gt;
&lt;td&gt;支持 JS 渲染，多实例负载均衡&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Docker&lt;/td&gt;
&lt;td&gt;容器化部署 Splash 实例&lt;/td&gt;
&lt;td&gt;环境隔离，快速管理实例生命周期（启停/删除），易扩展&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&amp;lt;center style=&quot;color:#808080; font-size:15px;&quot;&amp;gt;爬虫架构技术选型&amp;lt;/center&amp;gt;&lt;/p&gt;
&lt;h2&gt;数据处理模块&lt;/h2&gt;
&lt;p&gt;&amp;lt;figure&amp;gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;技术&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;用途说明&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;优势特点&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Pandas&lt;/td&gt;
&lt;td&gt;数据清洗、数据结构化处理&lt;/td&gt;
&lt;td&gt;提高高效的数据处理接口方法，支持灵活数据转化&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;jieba&lt;/td&gt;
&lt;td&gt;用于中文分词、关键词提取&lt;/td&gt;
&lt;td&gt;支持自定义词库，提供多模式分词&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;scikit-learn&lt;/td&gt;
&lt;td&gt;用于文本向量化和余弦相似度计算&lt;/td&gt;
&lt;td&gt;集成标准化的特征工程工具和相似度算法，支持高效的文本特征提取与匹配&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&amp;lt;center style=&quot;color:#808080; font-size:15px;&quot;&amp;gt;数据处理模块技术选型&amp;lt;/center&amp;gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;数据分析与可视化&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&amp;lt;figure&amp;gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;技术&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;用途说明&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;优势特点&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Django&lt;/td&gt;
&lt;td&gt;后端Web架构，用于数据分析处理，向前端进行结构化数据输出&lt;/td&gt;
&lt;td&gt;便携读取数据库内容，提供接口动态渲染数据内容。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Echarts&lt;/td&gt;
&lt;td&gt;前端可视化库，将后端提供的结构化数据渲染为交互式图表&lt;/td&gt;
&lt;td&gt;图表类型丰富，交互性能力强&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&amp;lt;center style=&quot;color:#808080; font-size:15px;&quot;&amp;gt;数据分析与可视化技术选型&amp;lt;/center&amp;gt;&lt;/p&gt;
&lt;h1&gt;&lt;strong&gt;数据库设计&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;数据表包含 9 个核心字段，覆盖书籍基础信息、用户交互数据及元数据，具体设计如下：&lt;/p&gt;
&lt;p&gt;&amp;lt;figure&amp;gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;字段&lt;/th&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;数据说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Id&lt;/td&gt;
&lt;td&gt;Int&lt;/td&gt;
&lt;td&gt;主键，用于标识一组唯一的数据&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Title&lt;/td&gt;
&lt;td&gt;Varchar&lt;/td&gt;
&lt;td&gt;书籍名标题&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Author&lt;/td&gt;
&lt;td&gt;Varchar&lt;/td&gt;
&lt;td&gt;书籍所属作者&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Publisher&lt;/td&gt;
&lt;td&gt;Varchar&lt;/td&gt;
&lt;td&gt;书籍发行出版社&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Price&lt;/td&gt;
&lt;td&gt;Decimal&lt;/td&gt;
&lt;td&gt;书籍价格&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Tags&lt;/td&gt;
&lt;td&gt;Varchar&lt;/td&gt;
&lt;td&gt;书籍所属标签类，存在多值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Summary&lt;/td&gt;
&lt;td&gt;Text&lt;/td&gt;
&lt;td&gt;书籍介绍内容&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;fav_count&lt;/td&gt;
&lt;td&gt;Int&lt;/td&gt;
&lt;td&gt;收藏该书籍的人数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;commend_count&lt;/td&gt;
&lt;td&gt;Int&lt;/td&gt;
&lt;td&gt;推荐该书籍的人数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;url&lt;/td&gt;
&lt;td&gt;Varchar&lt;/td&gt;
&lt;td&gt;爬取该书籍信息的原始网页链接&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&amp;lt;center style=&quot;color:#808080; font-size:15px;&quot;&amp;gt;数据模型设计表&amp;lt;/center&amp;gt;&lt;/p&gt;
&lt;h1&gt;&lt;strong&gt;项目架构&lt;/strong&gt;&lt;/h1&gt;
&lt;h2&gt;&lt;strong&gt;爬虫设计&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;Scrapy 是一个功能强大的开源爬虫框架，它提供了许多内置的功能和组件，如请求调度、响应处理、数据提取、数据管道等，能够帮助我们快速构建高效、稳定的爬虫。因此我们只需要针对网站页面结构与业务需求，通过编写对应模块的代码，即可完成项目的搭建和运行。&lt;/p&gt;
&lt;p&gt;利用Scrapy架构，结合网站布局结构，通过设计ixinqing_spider.py爬虫模块流程，通过分页爬取列表中的书籍链接（同时进行过滤重复和有效数据），进而对书籍详细页面进行数据内容获取并利用Xpath 标签定位解析元素内容。最后提取下一页链接，通过递归parse方法，实现全量列表链接爬取和详细数据内容解析与保存。&lt;/p&gt;
&lt;p&gt;同时针对书籍详细页面存在需要动态渲染的数据内容（如价格），我们利用Docker构建多实例Splash集群，对目标详细页面内容进行自定义脚本注入，实现JavaScript渲染，提升并发处理能力的同时结合Xpath标签定位获取数据内容。&lt;/p&gt;
&lt;p&gt;通过编写MySQLPipeline管道，连接数据库将爬取的详细页面内容存储在数据库中以定义好的数据表中。从而实现数据爬虫到数据存储全过程内容。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;反爬虫策略&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;为缓解网站压力，防止IP封禁等其他因素导致爬虫过程出现异常，针对反爬虫策略处理主要通过，在middlewares.py中定义了随机状态头中间件，从settings.py的USER_AGENTS列表中随机选择用户代理，设置到请求头中。同理通过随机选择代理IP，设置到请求头中，避免单一IP爬虫被封禁。&lt;/p&gt;
&lt;p&gt;同时，配置setting.py参数，例如下载延迟、总并发数、单域名并发数，控制每个请求的间隔和限制同一时间对目标网站的请求量。同时开启自动限速根据网站响应动态调整延迟，平衡爬取效率与反爬风险。&lt;/p&gt;
&lt;p&gt;此外，利用多实例Splash集群，分散请求特征（如请求头，IP），降低反爬检测风险。针对爬虫返回出现的特定状态码，通过错误重试，应对临时反爬限制。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202506/images/image-1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;center style=&quot;color:#808080; font-size:15px;&quot;&amp;gt;爬虫流程图与反爬设置&amp;lt;/center&amp;gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;数据清洗&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;在对书籍数据处理中，完成对不同数据字段的重复值、缺失值筛选，异常值查看等基础检查和处理。此外，针对数据属性“标签”存在大量属于“未分类”的内容，且标签作为书籍分类的核心属性，直接影响数据的检索效率和分析价值。因此，我们将通过采用“文本向量化+语义相似度计算”的技术框架，提升数据的完整性和可用性。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;将已分类书籍的标题和简介内容结合并进行预处理，使用TF-IDF算法计算每个词在文本中出现的频率，并结合该词在所有文本中的重要性（逆文档频率）来计算权重。&lt;/li&gt;
&lt;li&gt;对于每个标签，我们将该标签下所有书籍的向量进行平均，得到该标签的特征向量。&lt;/li&gt;
&lt;li&gt;对于每本未分类的书籍，我们计算其内容与知识库中各标签的相似度，按照相似度高低进行排序。结合关键词提取算法，综合生成推荐标签列表。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;&lt;strong&gt;数据分析&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;保存数据清洗后的数据为CSV格式文件内容，同时构建Django数据模型D_Books，并将数据导入模型中。&lt;/p&gt;
&lt;p&gt;通过Django前后端架构分离，我们在后端views.py实现数据分析，并将聚合分析后的数据生成为结构化数据输出至前端HTML页面中。&lt;/p&gt;
&lt;p&gt;针对不同业务需求，我们根据字段完成以下内容：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;统计与聚合&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;通过Django ORM关系映射，便携调用数据库内容字段，将查询结果按照作者字段进行分组，利用聚合函数统计出每个作者名下书籍的数量。同理聚合统计出出版社及其出版的书籍数量，并筛选出TOP10的数据。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;数据范围划分&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;根据书籍价格的分布情况，定义多个价格区间（如0 - 10 元、10 - 20 元、20 - 30 元、30 - 50 元、50 - 100 元以及 100 元以上）。通过 Django ORM 的查询条件构建对象并分别统计每个区间内书籍的数量。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;标签处理&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;利用 collections.Counter 统计处理后的标签列表中每个标签的出现频率，按照频率高低排序后选取前 15 个标签作为标签云数据。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;相关性分析&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;关注收藏数与推荐数这两个指标之间的关系。通过将每本书的收藏数和推荐数进行配对组合，输出结构化数据至前端页面渲染。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;可视化&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;通过后端生成返回的数据结果，我们采用 ECharts 作为主要的可视化工具，它是一个基于 JavaScript 的开源可视化库，提供了丰富的图表类型和强大的交互功能，能够满足项目中各种复杂的可视化需求，如饼图、折线图、词云图、散点图、柱状图等，并且可以方便地与 Django 模板进行集成。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;TOP10 作者饼图 ：直观地展示 TOP10 作者及其所占的书籍比例，通过饼图的扇形区域大小和颜色区分，让用户清晰地看到不同作者在书籍市场中的影响力和贡献度，方便用户快速了解哪些作者的作品更为受欢迎。&lt;/li&gt;
&lt;li&gt;TOP10 出版社折线面积图 ：以折线面积图的形式呈现 TOP10 出版社的书籍数量变化趋势，折线图的平滑曲线和区域填充效果能够直观地反映出出版社之间书籍数量的差异和整体分布情况，帮助用户分析出版社的市场地位和发展态势。&lt;/li&gt;
&lt;li&gt;标签云图 ：利用词云图展示常见的书籍标签，标签的字体大小和颜色根据其出现频率和重要程度进行动态调整，突出了热门标签，使用户能够一目了然地了解当前书籍市场中流行的主题和趋势。&lt;/li&gt;
&lt;li&gt;收藏数与推荐数关系图 ：采用散点图展示收藏数与推荐数之间的关系，每个散点的大小根据推荐数进行动态调整，并通过视觉映射突出显示不同推荐数的点，为用户分析用户行为和推荐算法的效果提供了直观的依据。&lt;/li&gt;
&lt;li&gt;价格分布柱状图 ：通过柱状图直观地呈现不同价格区间内书籍的数量分布，柱状图的高度和颜色区分不同价格区间的书籍数量，使用户能够快速了解书籍价格的整体分布情况和各价格区间的书籍数量占比。&lt;/li&gt;
&lt;li&gt;书籍选择器：提供出书数量TOP10的作者名字选择器，通过用户动态选择作者名称，动态渲染展示书籍详细信息列表&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202506/images/image-2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h1&gt;项目启动&lt;/h1&gt;
&lt;p&gt;爬虫架构&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;BS&lt;br /&gt;
│ requirements.txt  #环境依赖&lt;br /&gt;
│ scrapy.cfg&lt;br /&gt;
│ __init__.py&lt;br /&gt;
│&lt;br /&gt;
├─BS&lt;br /&gt;
│ │ items.py #数据模型&lt;br /&gt;
│ │ middlewares.py # 中间件&lt;br /&gt;
│ │ pipelines.py #数据管道&lt;br /&gt;
│ │ settings.py #爬虫与架构配置&lt;br /&gt;
│ │ __init__.py&lt;br /&gt;
│ │&lt;br /&gt;
│ ├─spiders&lt;br /&gt;
│ │ │ ixinqing_spider.py  # 爬虫主程序&lt;br /&gt;
│ │ │ __init__.py&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Windows docker启动splash集群，用于动态渲染&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker run -d --name splash1 -p 8050:8050 scrapinghub/splash --slots=5 --max-timeout=60
docker run -d --name splash2 -p 8051:8050 scrapinghub/splash --slots=5 --max-timeout=60
docker run -d --name splash3 -p 8052:8050 scrapinghub/splash --slots=5 --max-timeout=60
docker run -d --name splash4 -p 8053:8050 scrapinghub/splash --slots=5 --max-timeout=60
docker run -d --name splash5 -p 8054:8050 scrapinghub/splash --slots=5 --max-timeout=60

docker stats splash1 splash2 splash3 splash4 splash5 #监控状态
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202506/images/image-3-1024x541.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;启动爬虫架构爬取数据&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;scrapy crawl ixinqing_spider -o 1.json  #启动爬虫
# -o 1.json 用于测试爬虫是否有效
# 测试同时注意设置&apos;DEPTH_LIMIT&apos;: 1 （分页循环爬取深度设置为1）
# 测试同时注释MySql数据写入管道   &apos;BS.pipelines.MySQLPipeline&apos;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;数据爬取内容如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202506/images/image-5-1024x508.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;数据清洗和Django分析与可视化&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;BookDjango&lt;br /&gt;
│ manage.py&lt;br /&gt;
│ requirements.txt&lt;br /&gt;
│&lt;br /&gt;
├─BookDjango&lt;br /&gt;
│ │ asgi.py&lt;br /&gt;
│ │ settings.py  # 配置文件&lt;br /&gt;
│ │ urls.py  #网页请求路径&lt;br /&gt;
│ │ wsgi.py&lt;br /&gt;
│ │ __init__.py&lt;br /&gt;
│ │&lt;br /&gt;
│&lt;br /&gt;
├─books  #Django应用&lt;br /&gt;
│ │ admin.py&lt;br /&gt;
│ │ apps.py&lt;br /&gt;
│ │ models.py #数据模型&lt;br /&gt;
│ │ tests.py&lt;br /&gt;
│ │ views.py # 数据处理，输出结构化数据&lt;br /&gt;
│ ├─templates #网页代码&lt;br /&gt;
│ │ visualization.html&lt;/p&gt;
&lt;p&gt;│&lt;br /&gt;
├─Clear #数据清洗&lt;br /&gt;
│ data_clear.csv #清洗后的数据&lt;br /&gt;
│ data_clear.ipynb #清洗代码&lt;br /&gt;
│ import_data_toDjango.py #写入Django数据模型中&lt;br /&gt;
│&lt;br /&gt;
└─static #静态文件内容&lt;br /&gt;
├─css&lt;br /&gt;
│ bootstrap.min.css&lt;br /&gt;
│ tailwind.min.css&lt;br /&gt;
│&lt;br /&gt;
└─js&lt;br /&gt;
echarts-wordcloud.min.js&lt;br /&gt;
echarts.min.js&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对于Django不熟悉的可以查看以下文章进行配置：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.datazzh.top/archives/1713/2025/02/10/&quot;&gt;Django搭建与配置_笔墨云烟&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;启动Django服务访问网页&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202506/images/image-6-659x1024.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</content:encoded></item><item><title>数据库系统工程师—13.云计算与大数据处理</title><link>https://minthana.github.io/blog/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%B7%A5%E7%A8%8B%E5%B8%88-13-%E4%BA%91%E8%AE%A1%E7%AE%97%E4%B8%8E%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/</link><guid isPermaLink="true">https://minthana.github.io/blog/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%B7%A5%E7%A8%8B%E5%B8%88-13-%E4%BA%91%E8%AE%A1%E7%AE%97%E4%B8%8E%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/</guid><pubDate>Wed, 30 Apr 2025 13:46:00 GMT</pubDate><content:encoded>&lt;h1&gt;云计算与大数据处理&lt;/h1&gt;
&lt;h2&gt;云计算基础知识&lt;/h2&gt;
&lt;p&gt;云计算是一种将可伸缩、弹性、共享的物理和虚拟资源池以按需自服务的方式供应和管理，并提供网络访问的模式&lt;/p&gt;
&lt;h2&gt;云计算的关键特征&lt;/h2&gt;
&lt;p&gt;1、关键特征&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;广泛的网络接入&lt;/li&gt;
&lt;li&gt;可测量的服务&lt;/li&gt;
&lt;li&gt;多租户&lt;/li&gt;
&lt;li&gt;按需自服务&lt;/li&gt;
&lt;li&gt;快速的弹性和可扩展性&lt;/li&gt;
&lt;li&gt;资源池化&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2、其它关键特征&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;虚拟化技术&lt;/li&gt;
&lt;li&gt;可靠性高&lt;/li&gt;
&lt;li&gt;性价比高&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;云计算的分类&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;公有云：一般是被一个云计算服务提供商所拥有，该组织将云计算服务销售给公众，公有云通常在远离客户建筑物的地方托管&lt;/li&gt;
&lt;li&gt;私有云：云的基础设施是为一个客户单独使用而构建的，因而提供对数据、安全性和服务质量的最有效控制。私有云可部署在企业数据中心中，也可部署在一个主机托管场所，被一个单一的组织拥有或租用&lt;/li&gt;
&lt;li&gt;社区云：云的基础设施被一些组织所共享，并为一个有共同关注点的社区服务。可以是该组织或某个第三方负责管理&lt;/li&gt;
&lt;li&gt;混合云：云的基础设施由以上两种或两种以上的云（私有、社区或公有）组成&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;云计算的分类&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;基础设施即服务：IaSS
&lt;ul&gt;
&lt;li&gt;提供虚拟化的计算资源，如虚拟机、存储、网络和操作系统。其核心技术是虚拟化&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;平台即服务：PaSS
&lt;ul&gt;
&lt;li&gt;为开发、测试和管理软件应用程序提供按需开发的环境。其核心技术是分布式并行计算。PaaS实际上是指将软件研发的平台作为一种服务&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;软件即服务：SaSS
&lt;ul&gt;
&lt;li&gt;通过互联网提供按需软件付费应用程序，云计算提供商托管和管理软件应用程序，并允许用户连接到应用程序并通过互联网访问应用程序。客户可以自己定制、配置、组装来得到满足自身需求的软件系统&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;云关键技术&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;虚拟化技术&lt;/li&gt;
&lt;li&gt;分布式数据存储&lt;/li&gt;
&lt;li&gt;并行计算&lt;/li&gt;
&lt;li&gt;运营支撑管理&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;大数据的特征&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;多样性（Variety）&lt;/li&gt;
&lt;li&gt;速度（Velocity）&lt;/li&gt;
&lt;li&gt;大量（Volume）&lt;/li&gt;
&lt;li&gt;价值（Value）：价值密度低&lt;/li&gt;
&lt;li&gt;真实性（Veracity)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;大数据处理流程&lt;/h2&gt;
&lt;p&gt;数据采集、数据分析和数据解释。&lt;/p&gt;
</content:encoded></item><item><title>数据库系统工程师—12.1~12.3事务的基本概念、数据库的并发控制、数据库的备份与恢复</title><link>https://minthana.github.io/blog/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%B7%A5%E7%A8%8B%E5%B8%88-12-112-3%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84/</link><guid isPermaLink="true">https://minthana.github.io/blog/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%B7%A5%E7%A8%8B%E5%B8%88-12-112-3%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84/</guid><pubDate>Mon, 28 Apr 2025 11:27:00 GMT</pubDate><content:encoded>&lt;h1&gt;事务的基本概念&lt;/h1&gt;
&lt;h2&gt;事务&lt;/h2&gt;
&lt;p&gt;事务：是&lt;strong&gt;一系列的数据库操作&lt;/strong&gt;，是数据库应用程序的&lt;strong&gt;逻辑单位&lt;/strong&gt;，即应用程序对数据库的操作都应该以事务的方式进行&lt;/p&gt;
&lt;p&gt;事务是一个操作序列，这些操作&lt;strong&gt;要么都做，要么都不做&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;BEGIN TRANSACTION：事务开始 begin transaction&lt;/li&gt;
&lt;li&gt;END TRANSACTION：事务结束 end transaction&lt;/li&gt;
&lt;li&gt;COMMIT：事务提交&lt;/li&gt;
&lt;li&gt;ROLLBACK：事务回滚&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;SQL中事务的开始与结束&lt;/h2&gt;
&lt;p&gt;SQL标准规定当一条SQL语句被执行，就隐式地开始了一个事务，SQL中的Commitwork和Rollback work语句之一会结束一个事务&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Commit work：提交当前事务。这意味着该事务所做的更新在数据库中永久保存。一但事务被提交后，一个新的事务自动开始。&lt;/li&gt;
&lt;li&gt;Rollback work：回滚当前事务。这意味着将撤销该事务对数据库的更新。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注意：如果事务已经执行了Commit work，就不能再用Rollback来撤销&lt;/p&gt;
&lt;h2&gt;事务的特性&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;原子性：事务的所有操作在数据库中要么都做要么都不做。&lt;/li&gt;
&lt;li&gt;一致性：一个事务独立执行的结果，将保持数据的一致性，即数据不会因为事务的执行而遭受破坏。&lt;/li&gt;
&lt;li&gt;隔离性：一个事务的执行不能被其他事务干扰。并发事务在执行过程中可能会对同一数据进行操作，这些事务的操作应该不会相互干扰，是相互隔离的。&lt;/li&gt;
&lt;li&gt;持久性：一个事务一旦提交，它对数据库的改变必须是永久的，即使系统出现故障也是如此。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;事务的状态&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;活动状态
&lt;ul&gt;
&lt;li&gt;事务的初始状态，事务执行时处于这个状态。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;部分提交状态
&lt;ul&gt;
&lt;li&gt;当操作序列的最后一条语句执行后，事务就处于部分提交状态。这时，事务虽然已经完全执行，但由于实际输出可能还临时驻留在内存中，在事务成功完成前还有可能出现硬件故障，因此，部分提交状态并不等于事务成功执行。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;失败状态
&lt;ul&gt;
&lt;li&gt;由于硬件或逻辑错误，使得事务不能继续正常执行，事务就进入了失败状态，处于失败状态的事务必须回滚。这样，事务就进入了中止状态。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;中止状态
&lt;ul&gt;
&lt;li&gt;事务回滚并且数据库恢复到事务开始执行前的状态。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;提交状态
&lt;ul&gt;
&lt;li&gt;当事务成功完成后，称事务处于提交状态。只有事务处于提交状态后，才能说事务已经提交&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202504/images/image-10-1024x329.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;BEGIN TRANSACTION：开始运行事务，使事务进入活动状态&lt;/li&gt;
&lt;li&gt;END TRANSACTION：说明事物中的所有读写操作都已完成，使事务进入部分提交状态，把事务的所有操作对数据库的影响存入数据库。&lt;/li&gt;
&lt;li&gt;COMMIT：标志事务已经成功地完成，事务中的所有操作对数据库的影响已经安全地存入数据库，事务进入提交状态，结束事务的运行。&lt;/li&gt;
&lt;li&gt;ABORT：标志事务进入失败状态，系统撤销事务中所有操作对数据库和其他事务的影响，结束事务的运行&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;数据库的并发控制&lt;/h1&gt;
&lt;h2&gt;事务调度&lt;/h2&gt;
&lt;h3&gt;串行调度&lt;/h3&gt;
&lt;p&gt;是指多个事务依次串行执行，且只有当一个事务的所有操作都执行完成才执行另一个事务的所有操作&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202504/images/image-11-1024x720.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;并发调度&lt;/h3&gt;
&lt;p&gt;利用&lt;strong&gt;分时的方法&lt;/strong&gt;同时处理多个事务&lt;/p&gt;
&lt;p&gt;并发调度执行的结果与&lt;strong&gt;某一次串行调度执行的结果相同&lt;/strong&gt;，则称这个并发调度是&lt;strong&gt;正确的&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202504/images/image-12.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;可恢复调度&lt;/h3&gt;
&lt;p&gt;指满足这样的条件的调度：当事务Tj要读事务Ti写的数据时，Ti事务必须要先于事务Tj提交。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202504/images/image-13.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;并发操作带来的问题&lt;/h2&gt;
&lt;p&gt;并发操作带来的数据不一致性有三类&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;丢失修改&lt;/li&gt;
&lt;li&gt;读脏数据&lt;/li&gt;
&lt;li&gt;不可重复读&lt;/li&gt;
&lt;li&gt;幻读也称幻影现象。事务T1读取数据后，事务T2执行插入或删除操作，使T1无法再现前一次读取结果&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;主要原因是事务的并发操作&lt;strong&gt;破坏了事务的隔离性&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;丢失修改&lt;/h3&gt;
&lt;p&gt;两个事务对同一个数据进行修改，导致事务A对数据库的修改被事务B的修改所覆盖&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202504/images/image-14.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;读脏数据&lt;/h3&gt;
&lt;p&gt;某事务读取的数据是其它事务修改后的值，但该修改后来又被撤销了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202504/images/image-16.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;不可重复读&lt;/h3&gt;
&lt;p&gt;事务对同一数据进行两次读取的结果不同。原因是两次读取的间隙数据被另一事务修改了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202504/images/image-15.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;并发调度的可串行性&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;多个事务的&lt;strong&gt;并发执行&lt;/strong&gt;是正确的，当且仅当其结果&lt;strong&gt;与某一次序串行&lt;/strong&gt;地执行它们的&lt;strong&gt;结果相同&lt;/strong&gt;，称这种调度策略是可串行化的调度。&lt;/li&gt;
&lt;li&gt;可串行性是并发事务正确性的准则。即：一个给定的并发调度，当且仅当它是可串行化的才认为是正确调度。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;并发控制技术&lt;/h2&gt;
&lt;p&gt;并发事务如果对数据读写时不加以控制，会破坏事务的&lt;strong&gt;隔离性和一致性&lt;/strong&gt;。为了保持事务的隔离性，系统必须对事务之间的相互作用加以控制，最典型的方式就是加锁&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;排它锁：简称X锁，也称为写锁，用于对数据进行写操作时进行锁定
&lt;ul&gt;
&lt;li&gt;如果事务T对数据A加上X锁后，就只允许事务T对数据A进行读取和修改&lt;/li&gt;
&lt;li&gt;其他事务对数据A不能再加任何锁，从而也不能读取和修改数据A，直到事务T释放A上的锁&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;共享锁：简称S锁，也称为读锁，用于对数据进行读操作时进行锁定
&lt;ul&gt;
&lt;li&gt;如果事务T对数据A加上了S锁后，事务T就只能读数据A但不可以修改&lt;/li&gt;
&lt;li&gt;其他事务可以再对数据A加S锁来读取&lt;/li&gt;
&lt;li&gt;只要数据A上有了S锁，任何事务都只能再对其加S锁读取而不能加X锁修改&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;封锁协议&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;一级封锁协议
&lt;ul&gt;
&lt;li&gt;事务T在修改数据A之前必须先对其&lt;strong&gt;加X锁&lt;/strong&gt;，直到&lt;strong&gt;事务结束才释放X&lt;/strong&gt;锁&lt;/li&gt;
&lt;li&gt;解决了&lt;strong&gt;丢失修改&lt;/strong&gt;的问题&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;二级封锁协议
&lt;ul&gt;
&lt;li&gt;一级封锁协议加上事务T在读取数据A之前必须对其加&lt;strong&gt;上S锁&lt;/strong&gt;，&lt;strong&gt;读完后即可释放S锁&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;解决了&lt;strong&gt;读脏数据&lt;/strong&gt;的问题&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;三级封锁协议
&lt;ul&gt;
&lt;li&gt;是一级封锁协议加上事务T在读取数据A之前必须对其加&lt;strong&gt;上S锁&lt;/strong&gt;，直到&lt;strong&gt;事务结束才释放S锁&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;解决了&lt;strong&gt;不可重复读&lt;/strong&gt;的问题&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202504/images/image-17-1024x255.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;两段锁协议&lt;/h2&gt;
&lt;p&gt;两段锁协议（2PL）:是指同一事务对任何数据进行读写之前必须对该数据加锁；在&lt;strong&gt;释放一个封锁之后&lt;/strong&gt;，该&lt;strong&gt;事务不再申请和获得任何其他封锁&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;所谓“两段”的含义是：事务分为两个阶段。&lt;/li&gt;
&lt;li&gt;第一阶段是获得封锁，也称为扩展阶段。&lt;/li&gt;
&lt;li&gt;第二阶段是释放封锁，也称为收缩阶段&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;eg.T1：Slock A...Slock B...Xlock C...Unlock B...Unlock A...Unlock C&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;遵循两段锁协议，一定是可串行化的；不遵循两段锁协议，可能是可串行化的，也可能不是&lt;/li&gt;
&lt;li&gt;采用两段锁协议也有可能产生死锁&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;事务的隔离级别&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;事务的隔离级别并不是越高越好&lt;/li&gt;
&lt;li&gt;隔离级别越高，数据一致性越强，系统代价增高&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在SQL标准中给出了事务的4类隔离级别，由低到高依次如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;READ UNCOMMITTED（读未提交）：允许一个事务可以读取另一个未提交事务正在修改的数据&lt;/li&gt;
&lt;li&gt;READ COMMITTED（读已提交）：只允许一个事务读其他事务已提交的数据&lt;/li&gt;
&lt;li&gt;REPEATABLE READ（可重复读）：一个事务开始读取数据后，其他事务就不能再对该数据执行更新（UPDATE）操作了&lt;/li&gt;
&lt;li&gt;SERIALIZABLE（可串行化）：最高级别，在该级别下，事务的执行顺序是可串行化的&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202504/images/image-18-1024x313.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h1&gt;数据库的备份与恢复&lt;/h1&gt;
&lt;h2&gt;数据库系统故障的种类&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;事务故障
&lt;ul&gt;
&lt;li&gt;是由于程序执行错误而引起事务非预期的、异常终止的故障。通常有如下两类错误引起事务执行失败
&lt;ul&gt;
&lt;li&gt;逻辑错误：如非法输入、找不到数据、溢出、超出资源限制等原因引起的事务执行失败&lt;/li&gt;
&lt;li&gt;系统错误：系统进入一种不良状态（如死锁），导致事务无法继续执行&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;系统故障
&lt;ul&gt;
&lt;li&gt;是指硬件故障、软件（如DBMS、OS或应用程序）漏洞的影响，导致丢失了内存中的信息，影响正在执行的事务，但未破坏存储在外存上的信息&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;介质故障
&lt;ul&gt;
&lt;li&gt;是指数据库的存储介质发生故障，如磁盘损坏、瞬间强磁场干扰等。这种故障直接破坏了数据库，会影响到所有正在读取这部分数据的事务&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;数据库备份&lt;/h2&gt;
&lt;p&gt;数据转储是将数据库自制到另一个磁盘或磁带上保存起来的过程，又称为数据备份&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;静态转储和动态转储
&lt;ul&gt;
&lt;li&gt;静态转储是指在转储期间&lt;strong&gt;不允许对数据库进行任何存取、修改操作&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;动态转储是在转储期间&lt;strong&gt;允许对数据库进行存取、修改操作&lt;/strong&gt;，因此，转储和用户事务可并发执行&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;海量转储和增量转储
&lt;ul&gt;
&lt;li&gt;海量转储是指每次转储全部数据&lt;/li&gt;
&lt;li&gt;增量转储是指每次只转储上次转储后更新过的数据&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;日志文件
&lt;ul&gt;
&lt;li&gt;在事务处理的过程中，DBMS把事务开始、事务结束以及对数据库的插入、删除和修改的每一次操作写入日志文件&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;数据库镜像
&lt;ul&gt;
&lt;li&gt;为了避免磁盘介质出现故障影响数据库的可用性，许多DBMS提供数据库镜像功能用于数据库恢复&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;数据恢复&lt;/h2&gt;
&lt;p&gt;要使数据库在发生故障后能够恢复，&lt;strong&gt;必须建立冗余数据&lt;/strong&gt;，在故障发生后利用这些冗余数据实施数据库恢复，常用的是数&lt;strong&gt;据转储和日志文件&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;故障恢复的两个操作&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;UNDO：撤销事务。将&lt;strong&gt;未完成&lt;/strong&gt;的事务撤销，使数据库恢复到事务执行前的正确状态
&lt;ul&gt;
&lt;li&gt;反向扫描日志文件（由后向前扫描），查找事务的更新操作&lt;/li&gt;
&lt;li&gt;对该事务的更新操作&lt;strong&gt;执行逆操作&lt;/strong&gt;，用日志文件记录中
&lt;ul&gt;
&lt;li&gt;更新前的值写入数据库&lt;/li&gt;
&lt;li&gt;插入的记录从数据库中删除&lt;/li&gt;
&lt;li&gt;删除的记录重新插入数据库中&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;REDO：重做事务。将已提交的事务重新执行
&lt;ul&gt;
&lt;li&gt;从事务的开始标志起，正向扫描日志文件
&lt;ul&gt;
&lt;li&gt;重新执行日志文件登记的该事务对数据库的所有操作&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;故障恢复策略&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;事务故障的恢复
&lt;ul&gt;
&lt;li&gt;事务故障是事务在运行至正常终止点（COMMIT或ROLLBACK）前终止&lt;/li&gt;
&lt;li&gt;日志文件只有该事务的开始标识而没有结束标识&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;对这类故障的恢复通常是通过撤销（&lt;strong&gt;UNDO&lt;/strong&gt;）产生故障的事务，使数据库恢复到该事务执行前的正确状态来完成的&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;系统故障的恢复
&lt;ul&gt;
&lt;li&gt;系统故障会使数据库的数据不一致&lt;/li&gt;
&lt;li&gt;一是未完成的事务对数据库的更新可能&lt;strong&gt;已经写入&lt;/strong&gt;数据库&lt;/li&gt;
&lt;li&gt;二是已提交的事务对数据库的更新可能&lt;strong&gt;还在缓冲区&lt;/strong&gt;没来得及写入数据库&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;撤销故障发生时未完成的事务（UNDO）&lt;/li&gt;
&lt;li&gt;重做已经提交的事务（REDO）&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;介质故障
&lt;ul&gt;
&lt;li&gt;介质故障时数据库遭到破坏，需要重装数据库，一般需要DBA的参与&lt;/li&gt;
&lt;li&gt;装载故障前最近一次的备份和故障前的日志文件副本，再按照系统故障的恢复过程执行撤销（UNDO）和重做（REDO）来恢复&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;具有检查点的恢复技术&lt;/h2&gt;
&lt;p&gt;检查点（CHECKPOINT)出现的原因：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;搜索整个日志将耗费大量的时间&lt;/li&gt;
&lt;li&gt;很多需要重做处理的事务实际上已经将其更新操作结果写到了数据库中，而恢复子系统又重新执行了这些操作，浪费了大量时间&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;检查点记录的内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;建立检查点时刻所有正在执行的事务清单&lt;/li&gt;
&lt;li&gt;这些事务最近一个日志记录的地址&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;系统使用检查点方法进行恢复的步骤是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;故障发生（故障点），找到最近的一个检查点&lt;/li&gt;
&lt;li&gt;寻找故障发生前所有的活动事务
&lt;ul&gt;
&lt;li&gt;将&lt;strong&gt;检查点前结束&lt;/strong&gt;的事务不做任何处理&lt;/li&gt;
&lt;li&gt;将&lt;strong&gt;故障点前完成&lt;/strong&gt;的事务做REDO处理&lt;/li&gt;
&lt;li&gt;将&lt;strong&gt;故障点前未完成&lt;/strong&gt;的事务做UNDO处理&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202504/images/image-19-1024x364.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</content:encoded></item><item><title>数据库系统工程师—11.数据库设计</title><link>https://minthana.github.io/blog/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%B7%A5%E7%A8%8B%E5%B8%88-11-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/</link><guid isPermaLink="true">https://minthana.github.io/blog/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%B7%A5%E7%A8%8B%E5%B8%88-11-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/</guid><pubDate>Sat, 26 Apr 2025 15:03:00 GMT</pubDate><content:encoded>&lt;h1&gt;数据库设计&lt;/h1&gt;
&lt;h2&gt;数据库设计概述&lt;/h2&gt;
&lt;h3&gt;数据库应用系统的生命期&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;数据库规划&lt;/li&gt;
&lt;li&gt;需求描述与分析&lt;/li&gt;
&lt;li&gt;数据库与应用程序设计&lt;/li&gt;
&lt;li&gt;数据库设计实现&lt;/li&gt;
&lt;li&gt;测试&lt;/li&gt;
&lt;li&gt;运行维护&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;数据库设计的一般策略&lt;/h3&gt;
&lt;p&gt;有两种：自顶向下和自底向上&lt;/p&gt;
&lt;h3&gt;数据库设计的基本步骤&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;用户需求分析&lt;/li&gt;
&lt;li&gt;概念结构设计&lt;/li&gt;
&lt;li&gt;逻辑结构设计&lt;/li&gt;
&lt;li&gt;物理结构设计&lt;/li&gt;
&lt;li&gt;数据库实施阶段&lt;/li&gt;
&lt;li&gt;数据库运行和维护阶段&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;系统需求分析&lt;/h2&gt;
&lt;h3&gt;需求分析的任务、方法和目标&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;信息要求&lt;/li&gt;
&lt;li&gt;处理要求&lt;/li&gt;
&lt;li&gt;系统要求&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202504/images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2025-04-26-143348.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;需求分析阶段的文档&lt;/h3&gt;
&lt;p&gt;需求分析阶段的成果是系统需求说明书，主要包括&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据流图&lt;/li&gt;
&lt;li&gt;数据字典&lt;/li&gt;
&lt;li&gt;各种说明性表格&lt;/li&gt;
&lt;li&gt;统计输出表&lt;/li&gt;
&lt;li&gt;系统功能结构图等&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;数据字典（Data Dictionary,DD)是各类数据描述的集合，它是关于数据库中&lt;strong&gt;数据的描述&lt;/strong&gt;，即元数据，而不是数据本身。如用户将向数据库中输入什么信息，从数据库中要得到什么信息，各类信息的内容和结构，信息之间的联系等。&lt;/p&gt;
&lt;p&gt;数据字典包括&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据项&lt;/li&gt;
&lt;li&gt;数据结构&lt;/li&gt;
&lt;li&gt;数据流&lt;/li&gt;
&lt;li&gt;数据存储&lt;/li&gt;
&lt;li&gt;处理过程&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;概念结构设计&lt;/h2&gt;
&lt;p&gt;概念结构设计是&lt;strong&gt;在需求分析的基础上&lt;/strong&gt;，依照需求分析中的信息要求，对用户信息加以分类、聚集和概括，&lt;strong&gt;建立信息模型&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最常用的方法是实体-联系方法，简称E-R方法。它将现实世界的信息结构统一用实体、属性以及实体之间的联系来描述。&lt;/li&gt;
&lt;li&gt;概念结构设计工作步骤包括
&lt;ul&gt;
&lt;li&gt;选择局部应用
&lt;ul&gt;
&lt;li&gt;选择适当层次的数据流图，让这一层的每一部分对应一个局部应用，实现某一项功能，从这一层入手，就能很好地设计分E-R图&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;逐一设计分E-R图
&lt;ul&gt;
&lt;li&gt;划分好各个局部应用之后，就要对每一个局部应用逐一设计分E-R图，又称为局部E-R图。
&lt;ul&gt;
&lt;li&gt;属性不可再分，即属性不再具有需要描述的性质，不能有属性的属性。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;属性不能与其他实体发生联系&lt;/strong&gt;，联系是实体与实体间的联系。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;E-R图合并
&lt;ul&gt;
&lt;li&gt;根据局部应用设计好各局部E-R图之后，就可以对各分E-R图进行合并。合并的目的在于解决冲突，消除冗余。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202504/images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2025-04-26-144008.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;分E-R图合并时，它们之间存在的冲突主要有以下三类：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;属性冲突：同一属性可能会存在于不同的分E-R图中，由于设计人员不同或是出发点不同，&lt;strong&gt;对属性的类型、取值范围、数据单位等可能会不一致&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;命名冲突：&lt;strong&gt;相同意义的属性&lt;/strong&gt;，在不同的分E-R图上&lt;strong&gt;有着不同的命名&lt;/strong&gt;，或是名称相同的属性在不同的分E-R图中代表着不同的意义，这些也需要进行统一。&lt;/li&gt;
&lt;li&gt;结构冲突：&lt;strong&gt;同一实体&lt;/strong&gt;在不同的分E-R图中&lt;strong&gt;有不同的属性&lt;/strong&gt;，&lt;strong&gt;同一对象&lt;/strong&gt;在某一分E-R图中被抽象&lt;strong&gt;为实体&lt;/strong&gt;而在另一分E-R图中又被抽象&lt;strong&gt;为属性&lt;/strong&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;逻辑结构设计&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;在概念结构设计的基础上&lt;/strong&gt;进行数据模型设计，可以是层次模型、网状模型和关系模型&lt;/p&gt;
&lt;p&gt;逻辑结构设计阶段的主要工作步骤包括&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;确定数据模型&lt;/li&gt;
&lt;li&gt;将E-R图转换成指定的&lt;strong&gt;数据模型&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;确定完整性&lt;strong&gt;约束&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;确定用户&lt;strong&gt;视图&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202504/images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2025-04-26-144618.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;E-R图向关系模式的转换&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;实体向关系模式的转换&lt;/li&gt;
&lt;li&gt;联系向关系模式的转换&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;关系模式的规范化&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;关系模式的评价及修正。有时根据处理要求，可能还需要增&lt;strong&gt;加部分冗余以满足处理要求&lt;/strong&gt;，这就需要做部分关系模式的处理，分解、合并或增加冗余属性，提高存储效率和处理效率。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;确定完整性约束&lt;/p&gt;
&lt;p&gt;用户视图的确定&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;根据数据流图确定&lt;strong&gt;处理过程使用&lt;/strong&gt;的视图&lt;/li&gt;
&lt;li&gt;根据用户类别确定&lt;strong&gt;不同用户使用&lt;/strong&gt;的视图&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;数据库的物理设计&lt;/h2&gt;
&lt;p&gt;数据库在物理设备上的&lt;strong&gt;存储结构与存取方法&lt;/strong&gt;称为数据库的物理结构。&lt;/p&gt;
&lt;p&gt;为一个给定的逻辑数据模型设计一个最适合应用要求的物理结构的过程，就是数据库的物理设计。&lt;/p&gt;
&lt;p&gt;物理设计的主要工作步骤包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;确定数据分布&lt;/li&gt;
&lt;li&gt;存储结构&lt;/li&gt;
&lt;li&gt;访问方式&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202504/images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2025-04-26-145025.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;确定数据分布&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;根据不同应用分布数据。&lt;/li&gt;
&lt;li&gt;根据处理要求确定数据的分布。&lt;/li&gt;
&lt;li&gt;对数据的分布存储必然会导致数据的逻辑结构的变化，要对关系模式做新的调整，回到数据库逻辑设计阶段做必要的修改。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;确定数据的存储结构&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为提高数据的访问速度，通常会采用索引技术。在物理设计阶段，要根据数据处理和修改要求，确定数据库文件的索引字段和索引类型&lt;/li&gt;
&lt;li&gt;存储结构具体指数据文件中记录之间的物理结构&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;确定数据的访问方式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;存储记录结构设计&lt;/li&gt;
&lt;li&gt;存储记录布局&lt;/li&gt;
&lt;li&gt;存取方法的设计&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;数据库运行维护与管理&lt;/h2&gt;
&lt;h3&gt;重组和重构&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;数据库重组是指&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在&lt;strong&gt;不改变数据库逻辑和物理结构的情况下&lt;/strong&gt;，去除数据库存储文件中的废弃空间以及碎片空间中的指针链，使数据库记录在物理上紧连。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据库重构是指&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;数据库系统运行过程中，会因为一些原因而对数据库的结构做修改，包括表结构的修改和视图的修改&lt;/p&gt;
&lt;h3&gt;审计&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;审计是一种DBMS工具，它记录数据库资源和权限的使用情况。启用审计功能，可以产生审计&lt;strong&gt;跟踪信息，包括哪些数据库对象受到了影响，谁在什么时候执行了这些操作&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;审计是被动的，它&lt;strong&gt;只能跟踪对数据库的修改而不能防止&lt;/strong&gt;，但作为一个安全性手段，起到对非法入侵的威慑作用，可以据此追究非法入侵者的法律责任&lt;/li&gt;
&lt;li&gt;审计功能的开启会&lt;strong&gt;影响系统的性能&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;存储管理&lt;/h3&gt;
&lt;p&gt;在数据库系统运行过程中，随着数据的不断变更，会影响到系统的响应效率。通过以下手段进行存储管理，可有效地提高系统性能。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;索引文件和数据文件分开存储，事务日志文件存储在高速设备上&lt;/li&gt;
&lt;li&gt;适时修改数据文件和索引文件的页面大小&lt;/li&gt;
&lt;li&gt;定期对数据进行排序&lt;/li&gt;
&lt;li&gt;增加必要的索引项&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;SQL语句的编码检验&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;尽可能地减少多表查询或建立物化视图。&lt;/li&gt;
&lt;li&gt;以不相关子查询替代相关子查询。&lt;/li&gt;
&lt;li&gt;只检索需要的列。&lt;/li&gt;
&lt;li&gt;用带IN的条件子句等价替换OR子句。&lt;/li&gt;
&lt;li&gt;经常提交COMMIT，以尽早释放锁。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;表设计的评价&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;如果频繁的访问是对两个相关的表进行连接操作，则考虑将其合并&lt;/li&gt;
&lt;li&gt;如果频繁的访问只是在表中的某一部分字段上进行，则考虑分解表，将该部分单独作为一个表&lt;/li&gt;
&lt;li&gt;对于更新很少的表，引入物化视图
&lt;ul&gt;
&lt;li&gt;物化视图是包括一个查询结果的数据库对象，它是远程数据的的本地副本，或者用来生成基于数据表求和的汇总表。物化视图存储基于远程表的数据，也可以称为快照。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;索引维护和改进&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;如果&lt;strong&gt;查询是瓶颈&lt;/strong&gt;，则在关系上&lt;strong&gt;建立适应的索引&lt;/strong&gt;，通常在作为查询条件的属性上建立索引，可以提高查询效率&lt;/li&gt;
&lt;li&gt;如果&lt;strong&gt;更新是瓶颈&lt;/strong&gt;，每次更新都会重建表上的索引，引起效率的降低，则考虑&lt;strong&gt;删除某些索引&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;选择适当的索引类型，如果是经常使用&lt;strong&gt;范围查询&lt;/strong&gt;，则&lt;strong&gt;B树索引&lt;/strong&gt;比散列索引更高效&lt;/li&gt;
&lt;li&gt;将有利于&lt;strong&gt;大多数据查询和更新&lt;/strong&gt;的索引设为&lt;strong&gt;聚簇索引&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;ER图向关系模式的转换&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202504/images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2025-04-26-145916-1024x403.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202504/images/image-5-1024x437.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202504/images/image-6-1024x419.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202504/images/image-7-1024x411.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202504/images/image-8-1024x529.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202504/images/image-9-1024x402.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</content:encoded></item><item><title>数据库系统工程师—10.系统开发和运行知识</title><link>https://minthana.github.io/blog/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%B7%A5%E7%A8%8B%E5%B8%88-10-%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E5%92%8C%E8%BF%90%E8%A1%8C%E7%9F%A5%E8%AF%86/</link><guid isPermaLink="true">https://minthana.github.io/blog/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%B7%A5%E7%A8%8B%E5%B8%88-10-%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E5%92%8C%E8%BF%90%E8%A1%8C%E7%9F%A5%E8%AF%86/</guid><pubDate>Fri, 25 Apr 2025 18:11:00 GMT</pubDate><content:encoded>&lt;h1&gt;系统开发和运行知识&lt;/h1&gt;
&lt;h2&gt;软件生存周期&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;可行性分析与项目开发计划&lt;/li&gt;
&lt;li&gt;需求分析&lt;/li&gt;
&lt;li&gt;概要分析&lt;/li&gt;
&lt;li&gt;详细分析&lt;/li&gt;
&lt;li&gt;编码和单元测试&lt;/li&gt;
&lt;li&gt;综合测试&lt;/li&gt;
&lt;li&gt;维护&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;软件生存周期模型&lt;/h2&gt;
&lt;h3&gt;瀑布模型&lt;/h3&gt;
&lt;p&gt;瀑布模型是将软件生存周期各个活动规定为&lt;strong&gt;依线性顺序连接&lt;/strong&gt;的若干阶段的模型。它规定了由前至后、相互衔接的固定次序，如同瀑布流水，逐级下落。瀑布模型假设，&lt;strong&gt;一个待开发的系统需求是完整的、简明的、一致的，而且可以先于设计和实现完成之前产生&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优点：容易理解，管理成本低；强调开发的阶段性早期计划及需求调查和产品测试。&lt;/li&gt;
&lt;li&gt;不足：客户必须能够完整、正确和清晰地表达他们的需要；在开始的两个或三个阶段中，很难评估真正的进度状态；当接近项目结束时，出现了大量的集成和测试工作；直到项目结束之前，都不能演示系统的能力。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在瀑布模型中，需求或设计中的错误往往只有到了项目后期才能够被发现，对于项目风险的控制能力较弱，从而导致项目常常延期完成，开发费用超预算。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202504/images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2025-04-25-162122.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;增量模型&lt;/h3&gt;
&lt;p&gt;增量模型融合了瀑布模型的基本成分和原型实现的迭代特征，它假设可以将&lt;strong&gt;需求分段为一系列增量产品&lt;/strong&gt;，每一增量可以分别地开发。该模型采用随着日程时间的进展而交错的线性序列，每一个线性序列产生软件的一个可发布的“增量”。&lt;strong&gt;增量模型强调每一个增量均发布一个可操作的产品&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优点：第一个可交付版本所需要的成本和时间很少；开发由增量表示的小系统所承担的风险不大；由于很快发布了第一个版本，因此可以减少用户需求的变更；运行增量投资，即在项目开始时，可以仅对一个或两个增量投资。&lt;/li&gt;
&lt;li&gt;不足：如果没有对用户的变更要求进行规划，那么产生的初始增量可能会造成后来增量的不稳定；如果需求不像早期思考的那样稳定和完整，那么一些增量就可能需要重新开发，重新发布；管理发生的成本、进度和配置的复杂性，可能会超出组织的能力。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202504/images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2025-04-25-162751.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;演化模型&lt;/h3&gt;
&lt;p&gt;主要&lt;strong&gt;针对事先不能完整定义需求&lt;/strong&gt;的软件开发，是在&lt;strong&gt;快速开发一个原型&lt;/strong&gt;的基础上，根据用户在使用原型的过程中提出的意见和建议对原型&lt;strong&gt;进行改进&lt;/strong&gt;，获得原型的新版本。重复这一过程，最终可得到令用户满意的软件产品。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优点：任何功能一经开发就能进入测试，以便验证是否符合产品的需求，可以帮助引导出高质量的产品要求。&lt;/li&gt;
&lt;li&gt;缺点：如果不加控制地让用户接触开发中尚未稳定的功能，可能对开发人员及用户都会产生负面影响。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;螺旋模型&lt;/h3&gt;
&lt;p&gt;将&lt;strong&gt;瀑布模型和演化模型&lt;/strong&gt;结合起来，加入了两种模型均忽略的&lt;strong&gt;风险分析&lt;/strong&gt;，弥补了两种模型的不足。螺旋模型将开发过程分为几个螺旋周期，每个螺旋周期大致和瀑布模型相符合&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;（1）制订计划。确定软件的目标，选定实施方案，明确项目开发的限制条件。&lt;/li&gt;
&lt;li&gt;（2）风险分析。分析所选的方案，识别风险，消除风险。&lt;/li&gt;
&lt;li&gt;（3）实施工程。实施软件开发，验证阶段产品。&lt;/li&gt;
&lt;li&gt;（4）用户评估。评价开发工作，提出修正建议，建立下一个周期的开发计划。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;螺旋模型强调风险分析，使得开发人员和用户对每个演化层出现的风险有所了解，继而做出应有的反应。因此特别适用于庞大、复杂并且具有高风险的系统。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202504/images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2025-04-25-163222-1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;喷泉模型&lt;/h3&gt;
&lt;p&gt;喷泉模型是一种&lt;strong&gt;以用户需求为动力&lt;/strong&gt;，以对象作为驱动的模型，适合于&lt;strong&gt;面向对象的开发方法&lt;/strong&gt;。它克服了瀑布模型不支持软件重用和多项开发活动集成的局限性。喷泉模型使开发过程具有迭代性和无间隙性。&lt;/p&gt;
&lt;p&gt;该模型的各个阶段没有明显的界限，开发人员可以同步进行。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优点：可以提高软件项目的开发效率，节省开发时间。&lt;/li&gt;
&lt;li&gt;不足：由于喷泉模型在各个开发阶段是重叠的，在开发过程中需要大量的开发人员，不利于项目的管理。此外这种模型要求严格管理文档，使得审核的难度加大。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202504/images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2025-04-25-164135.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;典型的软件开发方法&lt;/h2&gt;
&lt;h3&gt;结构化开发方法&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;是一种传统的信息系统开发方法，由结构化分析、结构化设计和结构化程序设计构成，它是一种面向数据流的开发方法。其精髓是&lt;strong&gt;自顶向下、逐层分解和模块化设计&lt;/strong&gt;，它的基本原则是功能的分解与抽象。&lt;/li&gt;
&lt;li&gt;结构化方法的开发过程一般是先把系统功能视为一个大的模块，再根据系统分析与设计的要求对其进行进一步的模块分解或组合。&lt;/li&gt;
&lt;li&gt;结构化方法特别适合于数据处理领域的问题，但是不适合解决规模较大的、比较复杂的项目，且难以适应需求的变化。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;原型化开发方法&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;根据用户初步需求，利用系统开发工具，&lt;strong&gt;快速地建立一个系统模型&lt;/strong&gt;展示给用户，在此基础上与用户交流，最终实现用户需求的信息系统快速开发的方法。&lt;/li&gt;
&lt;li&gt;原型法的优点主要在于能更有效地确认用户需求。&lt;/li&gt;
&lt;li&gt;原型化方法比较&lt;strong&gt;适合于用户需求不清、业务理论不确定、需求经常变化的情况&lt;/strong&gt;。当系统规模不是很大也不太复杂时，采用该方法是比较好的。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;面向对象开发方法&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;面向对象开发方法的基本出发点是尽可能&lt;strong&gt;按照人类认识世界的方法和思维方法来分析和解决问题&lt;/strong&gt;。客观世界是由许多具体的事物、事件、概念和规则组成的，这些均可被看成对象，面向对象方法正是以对象作为最基本的元素，它也是分析问题、解决问题的核心。&lt;/li&gt;
&lt;li&gt;使用面向对象的方法构造的系统具有更好的复用性。面向对象的方法使系统的描述及信息模型的表示与客观实体相对应，符合人们的思维习惯，因此可以缩短开发周期。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;敏捷开发&lt;/h3&gt;
&lt;p&gt;敏捷开发的总体目标是通过“尽可能早地、持续地对有价值的软件的交付”使客户满意。通过在软件开发过程中加入灵活性，敏捷方法可以使用户能够在开发周期的后期增加或改变需求&lt;/p&gt;
&lt;h2&gt;软件管理&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;成本估算&lt;/li&gt;
&lt;li&gt;风险分析&lt;/li&gt;
&lt;li&gt;进度管理
&lt;ul&gt;
&lt;li&gt;Gantt图&lt;/li&gt;
&lt;li&gt;项目计划评审技术（PERT）图&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;人员管理
&lt;ul&gt;
&lt;li&gt;主程序员组：由一名主程序员、一名后备程序员、一名资料员和若干名程序员组成&lt;/li&gt;
&lt;li&gt;无主程序员组：无主程序员组中的成员之间相互平等&lt;/li&gt;
&lt;li&gt;层次式程序员组：层次式组中有一位组长，组长负责全面的工作，他领导若干名高级程序员，每个高级程序员又领导若干名程序员&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;需求分析&lt;/h2&gt;
&lt;h3&gt;任务与分类&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;确定软件系统的综合要求。&lt;/li&gt;
&lt;li&gt;分析软件系统的数据要求。包括基本元素、数据元素之间的逻辑关系、数据量和峰值等。常用的数据描述方法是实体-关系模型（E-R模型）。&lt;/li&gt;
&lt;li&gt;导出系统的逻辑模型。在结构化分析方法中可用数据流图来描述；在面向对象分析方法中可用类模型来描述。&lt;/li&gt;
&lt;li&gt;修正项目开发计划。&lt;/li&gt;
&lt;li&gt;如有必要，可开发一个原型系统。对一些需求不够明确的软件，可以先开发一个原型系统，以验证用户的需求。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;（1）功能需求：所开发的软件必须具备什么样的功能。&lt;/p&gt;
&lt;p&gt;（2）非功能需求：是指产品必须具备的属性或品质，如可靠性、性能、响应时间、容错性和扩展性等。&lt;/p&gt;
&lt;p&gt;（3）设计约束：也称为限制条件、补充规约，这通常是对解决方案的一些约束说明。&lt;/p&gt;
&lt;h3&gt;结构化分析方法&lt;/h3&gt;
&lt;p&gt;结构化分析（Structured Analysis, SA)方法是一种面向数据流的需求分析方法，适用于分析大型数据处理系统，是一种简单、实用的方法，现在已经得到广泛的使用。&lt;/p&gt;
&lt;p&gt;结构化分析方法的基本思想是自顶向下、逐层分解。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SA方法的分析结果由以下几部分组成：一套分层的数据流图、一本数据字典、一组小说明（也称加工逻辑说明）、补充材料。&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;面向对象分析方法&lt;/h3&gt;
&lt;h4&gt;基本概念&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;对象：在面向对象的系统中，对象是基本的运行时的实体，它既包括数据（属性），也包括作用于数据的操作（行为）。&lt;/li&gt;
&lt;li&gt;消息：对象之间进行通信的一种构造叫作消息。&lt;/li&gt;
&lt;li&gt;类：一个类定义了一组大体上相似的对象。类是在对象之上的抽象，对象是类的具体化，是类的实例。&lt;/li&gt;
&lt;li&gt;继承：继承是父类和子类之间共享数据和方法的机制。这是类之间的一种关系，在定义和实现一个类的时候，可以在一个已经存在的类的基础上来进行，把这个已经存在的类所定义的内容作为自己的内容，并加入若干新的内容。&lt;/li&gt;
&lt;li&gt;多态：在收到消息时，对象要予以响应。不同的对象收到同一消息可以产生完全不同的结果，这一现象叫作多态。&lt;/li&gt;
&lt;li&gt;动态绑定和静态绑定：绑定是一个把过程调用和响应调用所需要执行的代码加以结合的过程。在一般的程序设计语言中，绑定是在编译时进行的，叫作静态绑定。动态绑定则是在运行时进行的，因此，一个给定的过程调用和代码的结合直到调用发生时才进行。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;统一建模语言UML&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;类图：类图描述一组对象、接口、协作和它们之间的关系。&lt;/li&gt;
&lt;li&gt;对象图：对象图描述一组对象及它们之间的关系。对象图描述了在类图中所建立的事物的实例的静态快照。&lt;/li&gt;
&lt;li&gt;用例图：用例图描述一组用例、参与者与它们之间的关系。&lt;/li&gt;
&lt;li&gt;序列图：序列图是一种交互图，交互图展现了一种交互，它由一组对象或参与者以及它们之间可能发送的消息构成。交互图专注于系统的动态视图。序列图是场景的图形化表示，描述了以时间顺序组织的对象之间的交互活动，是强调消息的时间次序的交互图。&lt;/li&gt;
&lt;li&gt;通信图：通信图也是一种交互图，它强调收发消息的对象或参与者的结构组织。序列图强调的是时序，通信图强调的是对象之间的组织结构(关系)。&lt;/li&gt;
&lt;li&gt;状态图：状态图描述一个状态机，它由状态、转换、事件和活动组成。状态图关注系统的动态视图。&lt;/li&gt;
&lt;li&gt;活动图：活动图是一种特殊的状态图，它展现了在系统内从一个活动到另一个活动的流程。活动图专注于系统的动态视图，它强调对象间的控制流程。&lt;/li&gt;
&lt;li&gt;构件图：构件图描述一组构件之间的组织和依赖。构件图专注于系统的静态实现视图。它与类图相关，通常把构件映射为一个或多个类、接口或协作。&lt;/li&gt;
&lt;li&gt;部署图：部署图描述了运行时的处理节点以及其中的构件的配置。部署图给出了体系结构的静态实施视图。它与构件图相关，通常一个节点包含一个或多个构件。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;数据流图&lt;/h2&gt;
&lt;p&gt;数据流图（DFD）是结构化分析方法中用来描述系统的逻辑模型的。它是&lt;strong&gt;面向数据流&lt;/strong&gt;来建模的。&lt;/p&gt;
&lt;p&gt;（1）数据流：由一组固定成分的数据组成，表示数据的流向。DFD中描述的是数据流，而不是控制流。除了流向数据存储或从数据存储流出的数据流不必命名外，每个数据流都必须有一个合适的名字，以反映该数据流的含义。&lt;/p&gt;
&lt;p&gt;（2）加工：描述了输入数据流到输出数据流之间的变换，也就是输入数据流经过什么处理后变成了输出数据流。每个加工有一个名字和编号。编号能反映出该加工位于分层DFD中的哪个层次和哪张图中，也能够看出它是哪个加工分解出来的子加工。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202504/images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2025-04-25-172930-1024x222.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;（3）数据存储：数据存储用来表示存储的数据，每个数据存储都有一个名字。&lt;/p&gt;
&lt;p&gt;（4）外部实体：外部实体是指存在于系统之外的人员或组织或其它系统，它指出系统所需数据的发源地和系统所产生的数据的归宿地。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202504/images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2025-04-25-173208.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;系统设计&lt;/h2&gt;
&lt;p&gt;系统设计的主要目的就是为系统制定蓝图，在各种技术和实施方法中权衡利弊，精心设计，合理使用各种资源，最终勾画出新系统的详细设计方案。&lt;/p&gt;
&lt;p&gt;系统设计分为概要设计和详细设计&lt;/p&gt;
&lt;h3&gt;概要设计&lt;/h3&gt;
&lt;p&gt;（1）设计软件系统总体结构&lt;/p&gt;
&lt;p&gt;将一个复杂的系统按功能划分成模块；确定每个模块的功能；确定模块之间的调用关系；确定模块之间的接口，即模块之间传递的信息；评价模块结构的质量。&lt;/p&gt;
&lt;p&gt;（2）数据结构及数据库设计&lt;/p&gt;
&lt;p&gt;（3）编写概要设计文档&lt;br /&gt;
文档主要有概要设计说明书、数据库设计说明书、用户手册以及修订测试计划。&lt;/p&gt;
&lt;p&gt;（4）评审&lt;br /&gt;
对设计部分是否完整地实现了需求中规定的功能、性能等要求进行评审。&lt;/p&gt;
&lt;h3&gt;详细设计&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;对每个模块进行详细的算法设计。&lt;/li&gt;
&lt;li&gt;对模块内的数据结构进行设计。&lt;/li&gt;
&lt;li&gt;对数据库进行物理设计，即确定数据库的物理结构。&lt;/li&gt;
&lt;li&gt;其他设计。&lt;/li&gt;
&lt;li&gt;编写详细设计说明书。&lt;/li&gt;
&lt;li&gt;评审.对处理过程的算法和数据库的物理结构都要评审。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;模块独立&lt;/h3&gt;
&lt;p&gt;模块独立是指每个模块完成一个相对独立的特定子功能，并且与其他模块之间的联系简单。衡量模块独立程度的标准有两个：&lt;strong&gt;耦合性和内聚性&lt;/strong&gt;&lt;/p&gt;
&lt;h4&gt;耦合&lt;/h4&gt;
&lt;p&gt;耦合性是指模块之间联系的紧密程度。耦合性越高，则模块的独立性越差。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;无直接耦合
&lt;ul&gt;
&lt;li&gt;指两个模块间没有直接的关系，它们分别从属于不同模块的控制与调用，它们之间不传递任何信息。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;数据耦合
&lt;ul&gt;
&lt;li&gt;指两个模块之间有调用关系，传递的是简单的&lt;strong&gt;数据值&lt;/strong&gt;，相当于高级语言中的值传递&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;标记耦合
&lt;ul&gt;
&lt;li&gt;指两个模块之间传递的是&lt;strong&gt;数据结构&lt;/strong&gt;，如高级语言中的数据组名、记录名、文件名等这些名字即为标记。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;控制耦合
&lt;ul&gt;
&lt;li&gt;指一个模块调用另一个模块时，&lt;strong&gt;传递的是控制变量&lt;/strong&gt;，被调模块通过该控制变量的值有选择地执行块内的某一功能。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;公共耦合
&lt;ul&gt;
&lt;li&gt;指通过一个公共数据环境相互作用的那些模块之间的耦合。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;内容耦合：是耦合性程度最高的。
&lt;ul&gt;
&lt;li&gt;当一个模块直接使用另一个模块的内部数据，或通过非正常入口而转入另一个模块内部，这种模块之间的耦合为内容耦合。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;内聚&lt;/h4&gt;
&lt;p&gt;内聚是指模块内部各元素之间联系的紧密程度，例如一个完成多个功能的模块的内聚度就比完成单一功能的模块的内聚度低。&lt;strong&gt;内聚度越低，模块的独立性越差。&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;偶然内聚
&lt;ul&gt;
&lt;li&gt;指一个模块内的各个处理元素之间没有任何联系。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;逻辑内聚
&lt;ul&gt;
&lt;li&gt;指模块内执行几个逻辑上相似的功能，通过参数确定该模块完成哪一个功能。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;时间内聚
&lt;ul&gt;
&lt;li&gt;把需要同时执行的动作组合在一起形成的模块为时间内聚模块。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;通信内聚
&lt;ul&gt;
&lt;li&gt;指模块内所有处理元素都在同一个数据结构上操作，或者指各处理使用相同的输入数据或产生相同的输出数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;顺序内聚
&lt;ul&gt;
&lt;li&gt;指一个模块中各个处理元素都密切相关于同一功能且必须顺序执行，前一功能元素的输出就是下一功能元素的输入。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;功能内聚
&lt;ul&gt;
&lt;li&gt;这是最强的内聚，指模块内所有元素共同完成一个功能，缺一不可。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;将软件系统划分模块时，尽量做到高内聚、低耦合，提高模块的独立性。&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;系统测试基础知识&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;单元测试：单元测试也称为&lt;strong&gt;模块测试&lt;/strong&gt;。单元测试侧重于模块中的内部处理逻辑结构和数据结构。&lt;/li&gt;
&lt;li&gt;集成测试：集成测试的目的是检查&lt;strong&gt;模块之间&lt;/strong&gt;，以及模块和已集成的软件之间的接口关系。并验证已集成的软件是否符合设计要求。&lt;/li&gt;
&lt;li&gt;确认测试：确认测试主要用于验证软件的功能、性能和其他特性是否与用户需求一致。&lt;/li&gt;
&lt;li&gt;系统测试：系统测试的对象是完整的、集成的计算机系统，系统测试的目的是在真实系统工作环境下，验证完整的软件配置项能否和系统正确连接，并满足系统/子系统设计文档和软件开发合同规定的要求。技术依据是用户需求或开发合同。&lt;/li&gt;
&lt;li&gt;回归测试：回归测试的目的是&lt;strong&gt;测试软件变更之后&lt;/strong&gt;，变更部分的正确性和对变更需求的符合性，以及软件原有的、正确的功能、性能和其他规定的要求的不损害性。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;软件测试方法&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;黑盒测试法
&lt;ul&gt;
&lt;li&gt;功能测试，在完全不考虑软件的内部结构和特性的情况下，测试软件的外部特性。主要用于集成测试、确认测试和系统测试中。常用的黑盒测试技术有：等价类划分、边界值分析、错误推测和因果图等。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;白盒测试法
&lt;ul&gt;
&lt;li&gt;白盒测试也称为结构测试，主要用于软件单元测试中。它的主要思想是将程序看作是一个透明的白盒，测试人员完全清楚程序的结构和处理算法，按照程序内部逻辑结构设计测试用例。&lt;/li&gt;
&lt;li&gt;白盒测试常用的技术是逻辑覆盖，循环覆盖和基本路径测试。主要的逻辑覆盖标准有语句覆盖、判定覆盖、条件覆盖、条件/判定覆盖、 条件组合覆盖、路径覆盖等。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;CMM（软件能力成熟度模型）&lt;/h2&gt;
&lt;p&gt;CMM（软件能力成熟度模型）是一种对软件组织在定义、实施、度量、控制和改善其软件过程的实践中各个发展阶段的描述形成的标准。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;初始级
&lt;ul&gt;
&lt;li&gt;无序、无章法，无制度&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;可重复级
&lt;ul&gt;
&lt;li&gt;有基本的制度和标准&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;已定义级
&lt;ul&gt;
&lt;li&gt;标准化，文档化，完善的制度&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;已管理级
&lt;ul&gt;
&lt;li&gt;定量的，可量度的&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;优化级
&lt;ul&gt;
&lt;li&gt;有新技术新方法，可以避免缺陷&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;ISO/IEC9126软件质量模型&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202504/images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2025-04-25-181050.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202504/images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2025-04-25-181114.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</content:encoded></item><item><title>数据库系统工程师—9.非关系型数据库NoSQL</title><link>https://minthana.github.io/blog/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%B7%A5%E7%A8%8B%E5%B8%88-9-%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93nosql/</link><guid isPermaLink="true">https://minthana.github.io/blog/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%B7%A5%E7%A8%8B%E5%B8%88-9-%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93nosql/</guid><pubDate>Thu, 24 Apr 2025 10:19:00 GMT</pubDate><content:encoded>&lt;h1&gt;非关系型数据库NoSQL&lt;/h1&gt;
&lt;h2&gt;CAP理论&lt;/h2&gt;
&lt;p&gt;对于一个分布式系统，一致性、可用性和分区容忍性三个特点&lt;strong&gt;最多只能三选二&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一致性(Consistency)：系统在执行了某些操作后仍处于一个一致的状态&lt;/li&gt;
&lt;li&gt;可用性(Availablity)：数据的所有操作都有成功的返回。简言之，就是任何请求不管成功或失败都有响应&lt;/li&gt;
&lt;li&gt;分区容忍性(Partition tolerance)：在网络发生故障的时候。在网络连接上，一些结点出现故障，使得原本连通的网络变成了一块一块的分区，若允许系统继续工作，那就是分区可容忍的。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;ACID理论&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;原子性(Atomicity)：
&lt;ul&gt;
&lt;li&gt;事务的所有操作在数据库中要么都做要么都不做&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;一致性(Consistency)：
&lt;ul&gt;
&lt;li&gt;一个事务独立执行的结果，将保持数据的一致性，即数据不会因为事务的执行而遭受破坏&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;隔离性(Isolation)：
&lt;ul&gt;
&lt;li&gt;一个事务的执行不能被其他事务干扰。并发事务在执行过程中可能会对同一数据进行操作，这些事务的操作应该不会相互干扰，是相互隔离的&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;持久性(Durability)：
&lt;ul&gt;
&lt;li&gt;一个事务一旦提交，它对数据库的改变必须是永久的，即使系统出现故障也是如此&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;BASE理论&lt;/h2&gt;
&lt;p&gt;由于CAP理论的存在，为了提高性能，出现了ACID的一种变种BASE，它是一个弱一致性的理论，只要求最终一致性。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;BA(Basically Available)：基本可用&lt;/li&gt;
&lt;li&gt;S(Soft state)：软状态，可以理解为“无连接的”的，而与之相对应的是“面向连接”的。&lt;/li&gt;
&lt;li&gt;E(Eventual consistency):最终一致性，最终整个系统看到的数据是一致的&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;NoSQL数据库的种类&lt;/h2&gt;
&lt;p&gt;文档存储、键值存储、列存储、图存储&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202504/images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2025-04-24-101843.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</content:encoded></item><item><title>数据库系统工程师—8.3~8.4授权与触发器、嵌入式SQL与存储过程</title><link>https://minthana.github.io/blog/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%B7%A5%E7%A8%8B%E5%B8%88-8-38-4%E6%8E%88%E6%9D%83%E4%B8%8E%E8%A7%A6%E5%8F%91%E5%99%A8%E5%B5%8C%E5%85%A5%E5%BC%8Fsql%E4%B8%8E%E5%AD%98/</link><guid isPermaLink="true">https://minthana.github.io/blog/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%B7%A5%E7%A8%8B%E5%B8%88-8-38-4%E6%8E%88%E6%9D%83%E4%B8%8E%E8%A7%A6%E5%8F%91%E5%99%A8%E5%B5%8C%E5%85%A5%E5%BC%8Fsql%E4%B8%8E%E5%AD%98/</guid><pubDate>Tue, 22 Apr 2025 19:37:00 GMT</pubDate><content:encoded>&lt;h1&gt;授权与触发器&lt;/h1&gt;
&lt;h2&gt;授权&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;grant [权限列表] on [对象类型,对象名] to user
with grant option;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;with grant option：允许将此权限赋给其他用户&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;收回&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;revoke [权限列表] on [对象类型,对象名] from user
[restrict | cascade];
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;restrict：表示只收回语句中指定的用户的权限&lt;/li&gt;
&lt;li&gt;cascade：表示除了收回指定用户的权限外，还收回该用户赋予的其他用户的权限。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;触发器&lt;/h2&gt;
&lt;h3&gt;特点&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;当数据库程序员声明的事件发生时，触发器被激活。声明的事件可以是对某个特定关系的&lt;strong&gt;插入、删除或更新&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;当触发器被事件激活时，&lt;strong&gt;不是立即执行&lt;/strong&gt;，而是首先由触发器&lt;strong&gt;测试触发条件&lt;/strong&gt;，如果事件不成立，响应该事件的触发器什么都不做。&lt;/li&gt;
&lt;li&gt;如果触发器声明的条件满足，则与该触发器相连的&lt;strong&gt;动作由DBMS执行&lt;/strong&gt;。动作可以阻止事件发生，可以撤销事件。&lt;/li&gt;
&lt;li&gt;触发器可以引用当前数据库以外的对象，但只能在当前数据库中创建触发器；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;不能在临时表或系统表上创建触发器&lt;/strong&gt;，但触发器可以引用临时表&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;创建&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;create trigger &amp;lt;name&amp;gt; 
[before | after]
[delete | insert | update/update of 列名清单]
on &amp;lt;table_name&amp;gt;
[referencing &amp;lt;临时视图名&amp;gt;]
[for each row | for each statement]
[when &amp;lt;触发条件&amp;gt;]
begin
    &amp;lt;触发动作&amp;gt;
end[触发器名称]
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;referencing：提供两个临时视图，分别为更新前后的值
&lt;ul&gt;
&lt;li&gt;行级触发器：old row | new row
&lt;ul&gt;
&lt;li&gt;行级触发器是指一条SQL语句&lt;strong&gt;影响的每一行&lt;/strong&gt;触发一次&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;语句级触发器：old table | new table
&lt;ul&gt;
&lt;li&gt;语句级触发器是指一条SQL语句触发一次&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;for each row
&lt;ul&gt;
&lt;li&gt;行级触发器&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;for eahc statement
&lt;ul&gt;
&lt;li&gt;语句级触发器，默认&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;修改与删除&lt;/h3&gt;
&lt;p&gt;修改：create改alter&lt;/p&gt;
&lt;p&gt;删除：drop trigger 名称;&lt;/p&gt;
&lt;h1&gt;嵌入式SQL与存储过程&lt;/h1&gt;
&lt;h2&gt;嵌入式SQL&lt;/h2&gt;
&lt;p&gt;SQL提供了将SQL语句嵌入到某种高级语言中的方式，通常采用预编译的方法。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;区分主语言与SQL语句的方式
&lt;ul&gt;
&lt;li&gt;EXEC SQL &amp;lt;SQL语句&amp;gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;向主语言传递SQL语句&lt;strong&gt;执行的状态信息&lt;/strong&gt;的方式
&lt;ul&gt;
&lt;li&gt;SQLCA，即SQL通信区，是系统默认定义的全局变量。SQLCA.sqlcode&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;主变量（共享变量）
&lt;ul&gt;
&lt;li&gt;主语言通过主变量向SQL语句提供参数，主变量是由主语言的程序定义的，并&lt;strong&gt;用SQL的DECLARE语句说明&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;在引用共享变量时，前面需要加“：”冒号&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;定义&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;EXEC SQL BEGIN DECLARE SECTION;
    char Msname[4], Msex[3], givensno[5];
    int Mage;
    char SQLSTATE[6];     //特殊的共享变量，解释SQL语句的执行状况
EXEC SQL END DECLARE SECTION
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;共享&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;EXEC SQL INSERT INTO SC(Sno,Cno,Grade)
Values (:HSno, :HCno, :Hgrade);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;游标&lt;/h2&gt;
&lt;p&gt;SQL语言是面向集合的，一条SQL语句可以&lt;strong&gt;产生或处理多条记录。而主语言是面向记录的，一组主变量一次只能放一条记录&lt;/strong&gt;，所以，引入游标，通过移动游标指针来决定获取哪一条记录。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;定义&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;它只是一条说明性语句，定义游标后，其中的SELECT语句并不执行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;exec sql declare &amp;lt;游标名称&amp;gt; cursor for
&amp;lt;select 语句&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;打开、推进、关闭游标&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;打开游标使得其处于活跃状态，游标是一个指针，此时指向查询结果的&lt;strong&gt;第一行之前&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;推进游标，游标推进一行，并把游标指向的行（称为当前行）中的值取出，送到共享变量中&lt;/li&gt;
&lt;li&gt;关闭游标，使它不再和查询结果相联系。游标关闭后，后面还可以再打开。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;exec sql open &amp;lt;游标名称&amp;gt;
exec sql fetch &amp;lt;cursor_name&amp;gt; into 变量表
exec sql close &amp;lt;cursor_name&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;存储过程&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;是一组为了完成特定功能的SQL语句集合，经编译后存储在数据库中，用户通过指定存储过程的名称并给出参数来执行&lt;/li&gt;
&lt;li&gt;存储过程中可以包含逻辑控制语句和数据操纵语句，它可以接受参数、输出参数、返回单个或多个结果集以及返回值&lt;/li&gt;
&lt;li&gt;由于存储过程在创建时即在数据库服务器上进行了编译并存储在数据库中，所以存储过程运行要比单个的SQL语句块要快&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;create procedure 存储过程名 (in | out | in out 参数 数据类型)
[as]
begin
&amp;lt;SQL语句&amp;gt;
end
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;IN：为默认值，表示该参数为输入型参数，在过程体中值一般不变。&lt;/li&gt;
&lt;li&gt;OUT：表示该参数为输出参数，可以作为存储过程的输出结果，供外部调用者使用。&lt;/li&gt;
&lt;li&gt;IN OUT： 既可作为输入参数，也可作为输出参数。&lt;/li&gt;
&lt;/ul&gt;
</content:encoded></item><item><title>数据库系统工程师—8.2数据操作</title><link>https://minthana.github.io/blog/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%B7%A5%E7%A8%8B%E5%B8%88-8-2%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C/</link><guid isPermaLink="true">https://minthana.github.io/blog/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%B7%A5%E7%A8%8B%E5%B8%88-8-2%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C/</guid><pubDate>Mon, 21 Apr 2025 20:21:00 GMT</pubDate><content:encoded>&lt;h1&gt;数据操作&lt;/h1&gt;
&lt;h2&gt;SELECT&lt;/h2&gt;
&lt;h3&gt;查询基本格式&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;select * from table_namewhere 条件表达式group by 列名 [having 条件表达式]order by 列名 [asc] | [desc];
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;where可用的运算符&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202504/images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2025-04-21-193827.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;连接查询&lt;/h3&gt;
&lt;p&gt;如果涉及两个以上的表，则称为连接查询&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Select S.Sno,Snamefrom S,SCwhere S.Sno=SC.Sno and SC.Cno=&apos;C1&apos;;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;子查询&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;子查询也称嵌套查询&lt;/li&gt;
&lt;li&gt;嵌套查询是指一个SELECT-FROM-WHERE查询块中可以嵌入另一个查询块之中。在SQL中允许多重嵌套。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;IN、NOT IN&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;Select Sno,Snamefrom Swhere Sno IN （    Select Sno from SC Where Cno=&apos;C1&apos;);
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;EXISTS 、NOT EXISTS&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;Select Cno,Cname from Cwhere NOT EXISTS (    select * from SC where SC.Cno=C.Cno)；
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;聚集函数&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202504/images/image-1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202504/images/image-3-1024x407.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;分组查询&lt;/h2&gt;
&lt;h3&gt;GROUP BY&lt;/h3&gt;
&lt;p&gt;对元组进行分组，此时的聚集函数只用于每个分组&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Select Sno,AVG(Grade) from SC GROUP BY Sno；
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;HAVING&lt;/h3&gt;
&lt;p&gt;在GROUP BY子句后面加上HAVING子句，对分组后做一个选择，去掉不满足HAVING后面的 那个条件的分组&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Select Sno,AVG(Grade) from SC GROUP BY Sno HAVING AVG(Grade)&amp;gt;85;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;字符串操作&lt;/h2&gt;
&lt;p&gt;字符串常用LIKE来进行匹配操作，区分大小写&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;“%”匹配任意长度字符串&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code&gt;  Select Snamefrom SWhere Addr LIKE &apos;%科技路%&apos;;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;“_”匹配任意&lt;strong&gt;一个&lt;/strong&gt;字符&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code&gt;  Select Sname,Sage,SDfrom SWhere Sname LIKE &apos;__国庆&apos;; 
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为了使模式中包含特殊字符，即%和_，允许使用ESCAPE关键词来定义转义符，LIKE语句后面紧跟“ESCAPE&apos;\&apos;”表明转义符&apos;\&apos; 后面的特殊字符为普通字符。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;LIKE &apos;ab\%cd%&apos;escape&apos;\&apos;
&lt;ul&gt;
&lt;li&gt;匹配所有以ab%cd开头的字符串&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;LIKE &apos;ab\\cd%&apos;escape&apos;\&apos;
&lt;ul&gt;
&lt;li&gt;匹配所有以ab\cd开头的字符串&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;集合操作&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;UNION（并）、UNION ALL（不去掉重复行）&lt;/li&gt;
&lt;li&gt;INTERSECT（交）&lt;/li&gt;
&lt;li&gt;EXCEPT（差）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202504/images/image-4.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;外连接&lt;/h2&gt;
&lt;p&gt;*** JOIN ? ON exp&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;LEFT JOIN(左外连接)&lt;/li&gt;
&lt;li&gt;RIGHT JOIN(右外连接)&lt;/li&gt;
&lt;li&gt;FULL JOIN（全外连接）&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;SELECT S.Sno,Sname,SC.Cno,Grade FROM S FULL JOIN SC ON S.Sno=SC.Sno;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;INSERT INTO语句&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;insert into 表名 values(值1，值2)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code&gt;  insert into SCVALUES (&apos;3001&apos;, &apos;C1&apos;, &apos;84&apos;);
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;insert into 表名(列名) values(值1)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code&gt;  INSERT INTO SC(SNO,CNO)VALUES (&apos;3001&apos;, &apos;C2&apos;); 
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;DELETE语句&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;delete from 表名 where exp;delete from 表名;  # 删除全部数据，保留表结构
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;UPDATE语句&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt; update 表名 set 列名=新值 where exp;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;视图的查询与更新&lt;/h2&gt;
&lt;h3&gt;视图的查询&lt;/h3&gt;
&lt;p&gt;建立计算机系（CS表示计算机系）学生的视图，并要求进行修改、插入操作时保证该视图只有计算机系的学生&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE VIEW CS_STUDENTAS SELECT Sno,Sname,Sage,SexFROM StudentWhere SD=&apos;CS&apos;WITH CHECK OPTION;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;此时要查询计算机系年龄小于20岁的学生的学号及年龄的SQL语句如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT Sno,Sage FROM CS_Student WHERE Sage&amp;lt;20
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;系统执行该语句时，通常&lt;strong&gt;先将其转换成等价的对基本表的查询&lt;/strong&gt;，&lt;strong&gt;然后执行查询语句&lt;/strong&gt;。也就是查询视图时，系统先从数据字典中取出视图的定义，然后将定义中的查询语句和对该视图的查询语句结合起来，形成一个修正的查询语句。对上例修正之后的查询语句为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT Sno,Sage FROM Student WHERE SD=&apos;CS&apos; AND Sage&amp;lt;20;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;视图的更新&lt;/h3&gt;
&lt;p&gt;SQL对视图的更新必须遵循以下规则：&lt;/p&gt;
&lt;p&gt;（1）从&lt;strong&gt;多个基本表&lt;/strong&gt;通过连接操作导出的视图&lt;strong&gt;不允许更新&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;（2）对使用了&lt;strong&gt;分组、聚集函数&lt;/strong&gt;操作的视图&lt;strong&gt;不允许进行更新操作&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;（3）如果视图是从&lt;strong&gt;单个基本表&lt;/strong&gt;通过投影、选取操作导出的则&lt;strong&gt;允许进行更新操作&lt;/strong&gt;，且语法同基本表。&lt;/p&gt;
</content:encoded></item><item><title>数据库系统工程师—8.1 SQL概述与数据库定义</title><link>https://minthana.github.io/blog/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%B7%A5%E7%A8%8B%E5%B8%88-8-1-sql%E6%A6%82%E8%BF%B0%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9A%E4%B9%89/</link><guid isPermaLink="true">https://minthana.github.io/blog/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%B7%A5%E7%A8%8B%E5%B8%88-8-1-sql%E6%A6%82%E8%BF%B0%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9A%E4%B9%89/</guid><pubDate>Sun, 20 Apr 2025 21:20:00 GMT</pubDate><content:encoded>&lt;h1&gt;SQL概述与数据库定义&lt;/h1&gt;
&lt;h2&gt;SQL的基本组成&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;数据定义语言
&lt;ul&gt;
&lt;li&gt;DDL提供定义关系模式和视图、删除关系和视图、修改关系模式的命令&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;交互式数据操纵语言
&lt;ul&gt;
&lt;li&gt;DML提供查询、插入、删除和修改的命令。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;事务控制
&lt;ul&gt;
&lt;li&gt;提供定义事务&lt;strong&gt;开始&lt;/strong&gt;和&lt;strong&gt;结束&lt;/strong&gt;的命令。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;嵌入式SQL和动态SQL
&lt;ul&gt;
&lt;li&gt;用于&lt;strong&gt;嵌入&lt;/strong&gt;到某种通用的&lt;strong&gt;高级语言&lt;/strong&gt;中混合编程。其中，SQL负责操纵数据库，高级语言负责控制程序流程。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;完整性
&lt;ul&gt;
&lt;li&gt;DDL包括定义数据库中的数据必须满足的&lt;strong&gt;完整性约束条件&lt;/strong&gt;的命令，对于破坏完整性约束条件的更新将被禁止。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;权限管理
&lt;ul&gt;
&lt;li&gt;DDL中包括说明对关系和视图的访问权限&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;SQL语言中完成核心功能的9个动词
&lt;ul&gt;
&lt;li&gt;数据查询：Select&lt;/li&gt;
&lt;li&gt;数据定义：Create、Drop、Alter&lt;/li&gt;
&lt;li&gt;数据操纵：Insert、Update、Delete&lt;/li&gt;
&lt;li&gt;数据控制：Grant、Revoke&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;SQL的数据类型&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202504/images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2025-04-20-204444.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;表的创建、修改和删除&lt;/h2&gt;
&lt;h3&gt;创建&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;create table table_name(
    id int(10) primary key,
    name varchar(200),
    class int(10) references t2(class),
    grade varchar(10),
    foreign key grade references t3(grade) on delete [set null] | [casecade]
);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;约束&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;实体完整性约束：primary key
&lt;ul&gt;
&lt;li&gt;可以添加到列后面，即列级完整性约束条件&lt;/li&gt;
&lt;li&gt;或在最后，即表级完整性约束条件（主码属性组只能使用表级）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;参照完整性约束：foreign key
&lt;ul&gt;
&lt;li&gt;列级完整性约束条件 references 表名(列名)&lt;/li&gt;
&lt;li&gt;表级完整性约束条件 foreign key 列名 references 表名(列名)   （有几个写几个）
&lt;ul&gt;
&lt;li&gt;on delete set null：表示删除被参照关系的元组时，将参照关系的相应属性值置&lt;strong&gt;为空值&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;on delete casecade：表示删除被参照关系的元组时，&lt;strong&gt;同时删除&lt;/strong&gt;参照关系中的元组&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;属性值上的约束
&lt;ul&gt;
&lt;li&gt;NOT NULL：表示不允许取空值&lt;/li&gt;
&lt;li&gt;UNIQUE：表示取值唯一&lt;/li&gt;
&lt;li&gt;NOT NULL UNIQUE：表示取值唯一且不为空 (等价于primary key)&lt;/li&gt;
&lt;li&gt;CHECK：限制列中值的取值范围
&lt;ul&gt;
&lt;li&gt;CHECK (Sex=&apos;男&apos; OR Sex=&apos;女&apos;)，CHECK (余额&amp;gt;=0)，CHECK (年龄&amp;gt;=18 AND 年龄&amp;lt;=60)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;全局约束
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;基于元组的检查子句&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code&gt;  CREATE TABLE E(
  Eno CHAR(8) PRIMARY KEY, 入职日期 DATE, 离职日期 DATE,
  CHECK (入职日期&amp;lt;=离职日期) );
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;基于断言的语法格式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code&gt;   create assertion name check();
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;修改&lt;/h3&gt;
&lt;p&gt;增删改&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;alter table table_name(
    add name varchar(100),  #新增列
    modify class int(10),   #修改类型
    drop name,              #删除列
    add constraint C_no check(......) #新增约束,命名为C_no
);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;删除&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt; drop table table_name;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;索引的创建和删除&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;create [unique] | [cluster] index 
index_name on 表名(列名); 

drop index index_name;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;index类型
&lt;ul&gt;
&lt;li&gt;unique：唯一索引&lt;/li&gt;
&lt;li&gt;cluster：聚簇索引，使得索引项的顺序是与表中记录的&lt;strong&gt;物理顺序一致&lt;/strong&gt;的索引组织&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;在列名后，可添加
&lt;ul&gt;
&lt;li&gt;ASC 升序，默认&lt;/li&gt;
&lt;li&gt;DESC 降序&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;视图的创建和删除&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;create view view_name 
as (select 语句)
[with check option];

drop view view_name;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;子查询可以是任意复杂的SELECT语句，但通常&lt;strong&gt;不允许含有ORDER BY子句和DISTINCT短语&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;WITH CHECK OPTION表示对UPDATE,INSERT,DELETE操作时保证更新、插入或删除的行满足视图定义中的谓词条件（即子查询中的条件表达式）&lt;/li&gt;
&lt;/ul&gt;
</content:encoded></item><item><title>数据库系统工程师—7.6~7.7 Armstrong公理系统、模式分解及分解后的特性</title><link>https://minthana.github.io/blog/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%B7%A5%E7%A8%8B%E5%B8%88-7-6-armstrong%E5%85%AC%E7%90%86%E7%B3%BB%E7%BB%9F/</link><guid isPermaLink="true">https://minthana.github.io/blog/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%B7%A5%E7%A8%8B%E5%B8%88-7-6-armstrong%E5%85%AC%E7%90%86%E7%B3%BB%E7%BB%9F/</guid><pubDate>Sat, 19 Apr 2025 10:08:00 GMT</pubDate><content:encoded>&lt;h1&gt;Armstrong公理系统&lt;/h1&gt;
&lt;h2&gt;Armstrong公理系统&lt;/h2&gt;
&lt;p&gt;Armstrong公理系统（函数依赖的公理系统）：设关系模式R(U,F)，其中U为属性集，F是U上的一组函数依赖，那么有如下推理规则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A1自反律：若Y⊆X⊆U，则X→Y为F所蕴涵&lt;/li&gt;
&lt;li&gt;A2增广律：若X→Y为F所蕴涵，且Z⊆U，则XZ→YZ为F所蕴涵。&lt;/li&gt;
&lt;li&gt;A3传递律：若X→Y，Y→Z为F所蕴涵，则X→Z为F所蕴涵。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;根据上述三条推理规则又可推出下述三条推理规则：&lt;br /&gt;
（1）合并规则：若X→Y，X→Z，则X→YZ为F所蕴涵。&lt;/p&gt;
&lt;p&gt;（2）伪传递律：若X→Y，WY→Z，则XW→Z为F所蕴涵&lt;/p&gt;
&lt;p&gt;（3）分解规则：若X→Y，Z⊆Y，则X→Z为F所蕴涵。&lt;/p&gt;
&lt;h2&gt;函数依赖的闭包F+及属性的闭包XF+&lt;/h2&gt;
&lt;h3&gt;函数依赖的闭包F+&lt;/h3&gt;
&lt;p&gt;关系模式R(U,F)中为F所逻辑蕴含的函数依赖的全体（通过Armstrong公理系统推理）称为F的闭包，记为：F+&lt;/p&gt;
&lt;h3&gt;属性的闭包XF+&lt;/h3&gt;
&lt;p&gt;设F为属性集U上的一组函数依赖，X⊆U，XF+={A|X→A能由F根据Armstrong公理导出}，则称XF+为属性集X关于函数依赖集F的闭包。&lt;/p&gt;
&lt;h2&gt;候选码的求解方法&lt;/h2&gt;
&lt;p&gt;根据函数依赖。将属性划分为以下&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;L：仅出现在函数依赖集F左部的属性&lt;/li&gt;
&lt;li&gt;R：仅出现在函数依赖集F右部的属性&lt;/li&gt;
&lt;li&gt;LR：在函数依赖集F左右部都出现的属性&lt;/li&gt;
&lt;li&gt;NLR：在函数依赖集F左右部都未出现的属性&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;结论1：若X(X⊆U)是L类属性，则X必为R的任一候选码的成员。若XF+=U，则X必为R的唯一候选码。&lt;/p&gt;
&lt;p&gt;结论2：若X(X⊆U)是R类属性，则X不是R的任一候选码的成员。&lt;/p&gt;
&lt;p&gt;结论3：是X(X⊆U)是NLR类属性，则X必为R的任一候选码的成员。&lt;/p&gt;
&lt;p&gt;结论4：若X(X⊆U)是L类和NLR类属性组成的属性集，若XF+=U，则X必为R的唯一候选码。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第1步、根据题意，将所有的属性分类：
&lt;ul&gt;
&lt;li&gt;L：只在左边出现，一定是&lt;/li&gt;
&lt;li&gt;R：只在右边出现，一定不是&lt;/li&gt;
&lt;li&gt;LR：左右都出现，有可能是，也有可能不是&lt;/li&gt;
&lt;li&gt;NLR：左右都没出现，一定是&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;第2步、将&lt;strong&gt;所有的L类和NLR类属性组合起来&lt;/strong&gt;，设为P，求其闭包PF+，如果是全集U，那么它就是候选码。&lt;/li&gt;
&lt;li&gt;第3步、如果PF+不是全集U，则&lt;strong&gt;依次将LR类&lt;/strong&gt;属性&lt;strong&gt;跟P组合&lt;/strong&gt;起来求闭包，只要其闭包是全集U，就是候选码。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;模式分解及分解后的特性&lt;/h1&gt;
&lt;h2&gt;无损连接&lt;/h2&gt;
&lt;p&gt;无损连接是指将一个关系模式分解成若干个关系模式后，通过自然连接和投影等运算仍能还原到原来的关系模式，则称这种分解为无损连接分解。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这个定理只适用于分解为两个子模式的情况，分解为多个子模式的时候不适用&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;关系模式R(U,F)的一个分解ρ ={ R1(U1,F1),R2(U2,F2)}&lt;/p&gt;
&lt;p&gt;具有无损连接的充分必要的条件是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;U1⋂U2→U1－U2∈F+&lt;/li&gt;
&lt;li&gt;或U1⋂U2→U2－U1∈F+&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;保持函数依赖&lt;/h2&gt;
&lt;p&gt;设关系模式R(U,F)的一个分解 ρ ={R1(U1,F1), R2(U2,F2),…,Rk(Uk,Fk)}，（F1 ⋃ F2 ⋃ F3 ⋃…⋃ Fk)+ =F+，则称分解ρ保持函数依赖&lt;/p&gt;
&lt;h1&gt;最小函数依赖集&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;右边单一属性&lt;/li&gt;
&lt;li&gt;左边无冗余&lt;/li&gt;
&lt;li&gt;没有传递依赖&lt;/li&gt;
&lt;/ul&gt;
</content:encoded></item><item><title>数据系统工程师—7.4~7.5关系数据库设计基础知识、规范化</title><link>https://minthana.github.io/blog/posts/%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F%E5%B7%A5%E7%A8%8B%E5%B8%88-7-47-5%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E8%A7%84/</link><guid isPermaLink="true">https://minthana.github.io/blog/posts/%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F%E5%B7%A5%E7%A8%8B%E5%B8%88-7-47-5%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E8%A7%84/</guid><pubDate>Tue, 15 Apr 2025 17:11:00 GMT</pubDate><content:encoded>&lt;h1&gt;关系数据库设计基础知识&lt;/h1&gt;
&lt;h2&gt;函数依赖&lt;/h2&gt;
&lt;h3&gt;函数依赖&lt;/h3&gt;
&lt;p&gt;对于属性集X的每一个确定的值，都有属性Y的一个唯一确定的值与之对应&lt;/p&gt;
&lt;p&gt;记Y函数依赖X，X→Y&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;非平凡函数依赖：X→Y，Y∉X&lt;/li&gt;
&lt;li&gt;平凡函数依赖：X→Y，Y⊆X&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;完全函数依赖与部分函数依赖&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;完全函数依赖：必须用码的全部属性才能确定另一个属性&lt;/li&gt;
&lt;li&gt;部分函数依赖：仅需码的部分属性就能确定另一个属性&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;传递函数依赖&lt;/h3&gt;
&lt;p&gt;在R(U,F)中 X→Y，Y→Z，Y∉X，Y⇸X，则称Z对X传递依赖&lt;/p&gt;
&lt;h3&gt;多值依赖&lt;/h3&gt;
&lt;p&gt;一个属性决定了另一组属性的多个可能组合，且这些组合独立于其他属性存在&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;平凡多值依赖：z = Ø&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;非平凡多值依赖：z ≠ Ø&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;多值依赖具有对称性。即若X→→Y,则X→→Z，其中Z=U-X-Y。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;多值依赖的传递性。即若X→→Y,Y→→Z,则X→→Z-Y。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;函数依赖可以看成是多值依赖的特殊情况。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;若X→→Y,X→→Z,则X→→YZ。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;若X→→Y,X→→Z,则X→→Y ⋂ Z&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;若X→→Y,X→→Z,则X→→Z-Y&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;规范化&lt;/h1&gt;
&lt;h2&gt;1NF&lt;/h2&gt;
&lt;p&gt;若关系模式R的&lt;strong&gt;每一个分量是不可再分&lt;/strong&gt;的数据项，则关系模式R属于第一范式。记为R∈1NF。&lt;/p&gt;
&lt;p&gt;存在的问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据冗余&lt;/li&gt;
&lt;li&gt;更新异常（修改操作后数据不一致）&lt;/li&gt;
&lt;li&gt;插入异常&lt;/li&gt;
&lt;li&gt;删除异常&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;2NF&lt;/h2&gt;
&lt;p&gt;若关系模式R∈1NF，且每一个非主属性完全依赖于码，则关系模式R∈2NF。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2NF消除了非主属性对码的部分函数依赖&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;存在的问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据冗余&lt;/li&gt;
&lt;li&gt;更新异常（修改操作后数据不一致）&lt;/li&gt;
&lt;li&gt;插入异常&lt;/li&gt;
&lt;li&gt;删除异常&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;3NF&lt;/h2&gt;
&lt;p&gt;若关系模式R(U,F)中不存在这样的码X，属性组Y及非主属性Z（Z⊈Y）使得X→Y,(Y⇸X)Y→Z成立，则关系模式R∈3NF。&lt;/p&gt;
&lt;p&gt;消除了&lt;strong&gt;非主属性&lt;/strong&gt;对码的&lt;strong&gt;函数传递依赖&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;存在的问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据冗余&lt;/li&gt;
&lt;li&gt;更新异常（修改操作后数据不一致）&lt;/li&gt;
&lt;li&gt;插入异常&lt;/li&gt;
&lt;li&gt;删除异常&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;BCNF巴克斯范式&lt;/h2&gt;
&lt;p&gt;关系模式R∈1NF，若X→Y且Y⊈X时，X必含有码，则关系模式R∈BCNF&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当3NF消除了&lt;strong&gt;主属性&lt;/strong&gt;对码的部分函数依赖和传递函数依赖，则称为BCNF。&lt;/li&gt;
&lt;li&gt;即，&lt;strong&gt;只有候选码才能决定其他属性&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;4NF&lt;/h2&gt;
&lt;p&gt;关系模式R∈1NF，若对于R的每个非平凡多值依赖X→→Y且Y⊈X时，X必含有码，则关系模式R(U,F)∈4NF。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;没有非平凡的非函数依赖的多值依赖&lt;/strong&gt;&lt;/p&gt;
</content:encoded></item><item><title>数据库系统工程师—7.3 元组演算、域演算与查询优化</title><link>https://minthana.github.io/blog/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%B7%A5%E7%A8%8B%E5%B8%88-7-3-%E5%85%83%E7%BB%84%E6%BC%94%E7%AE%97%E5%9F%9F%E6%BC%94%E7%AE%97%E4%B8%8E%E6%9F%A5%E8%AF%A2%E4%BC%98/</link><guid isPermaLink="true">https://minthana.github.io/blog/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%B7%A5%E7%A8%8B%E5%B8%88-7-3-%E5%85%83%E7%BB%84%E6%BC%94%E7%AE%97%E5%9F%9F%E6%BC%94%E7%AE%97%E4%B8%8E%E6%9F%A5%E8%AF%A2%E4%BC%98/</guid><pubDate>Tue, 15 Apr 2025 16:38:00 GMT</pubDate><content:encoded>&lt;h1&gt;元组演算、域演算与查询优化&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;全称量词⩝&lt;/li&gt;
&lt;li&gt;存在量词∃&lt;/li&gt;
&lt;li&gt;¬非&lt;/li&gt;
&lt;li&gt;∧与&lt;/li&gt;
&lt;li&gt;∨或&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;θ&lt;/strong&gt; &amp;gt; &lt;strong&gt;⩝&lt;strong&gt;和&lt;/strong&gt;∃&lt;/strong&gt; &amp;gt; &lt;strong&gt;¬&lt;/strong&gt; &amp;gt; &lt;strong&gt;∧&lt;strong&gt;和&lt;/strong&gt;∨&lt;/strong&gt; &amp;gt; &lt;strong&gt;⇒&lt;/strong&gt;，加括号时，括号中的运算符优先。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202504/images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2025-04-14-171859.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202504/images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2025-04-14-171950.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;在关系代数运算中，笛卡儿积、连接运算是最耗费时间和空间的&lt;/p&gt;
&lt;p&gt;优化的准则：&lt;br /&gt;
（1）提早执行选取运算。对于有选择运算的表达式，应优化成尽可能先执行选择运算的等价表达式，以得到较小的中间结果，减少运算量和从外存读块的次数。&lt;/p&gt;
&lt;p&gt;（2）合并乘积与其后的选择运算为连接运算。&lt;/p&gt;
&lt;p&gt;（3）将投影运算与其后的其他运算同时进行，以避免重复扫描关系。&lt;/p&gt;
&lt;p&gt;（4）将投影运算和其前后的二目运算结合起来，使得没有必要为去掉某些字段再扫描一遍关系。&lt;/p&gt;
&lt;p&gt;（5）在执行连接前对关系适当地预处理，就能快速地找到要连接的元组。方法有两种：索引连接法、排序合并连接法。&lt;/p&gt;
&lt;p&gt;（6）存储公共子表达式。对于有公共子表达式的结果应存于外存（中间结果），这样，当从外存读出它的时间比计算的时间少时，就可节约操作时间。&lt;/p&gt;
</content:encoded></item><item><title>数据库系统工程师—7.1~7.2关系数据库概述、关系运算</title><link>https://minthana.github.io/blog/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%B7%A5%E7%A8%8B%E5%B8%88-7-17-2%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E8%BF%B0%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97/</link><guid isPermaLink="true">https://minthana.github.io/blog/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%B7%A5%E7%A8%8B%E5%B8%88-7-17-2%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E8%BF%B0%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97/</guid><pubDate>Mon, 14 Apr 2025 10:51:00 GMT</pubDate><content:encoded>&lt;h1&gt;关系数据库概述&lt;/h1&gt;
&lt;h2&gt;相关名词&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;1、关系：在关系数据库中，实体以及实体间的联系都是用关系来表示的。类似于程序设计语言中变量的概念。&lt;/li&gt;
&lt;li&gt;2、关系模式：是对关系的描述。类似于程序设计语言中类型定义的概念。&lt;/li&gt;
&lt;li&gt;3、关系模型：是由若干个关系模式组成的集合。&lt;/li&gt;
&lt;li&gt;4、属性：用来描述某一个事物的特征。&lt;/li&gt;
&lt;li&gt;5、域：每个属性的取值范围所对应一个值的集合。&lt;/li&gt;
&lt;li&gt;6、候选码：若关系中的某一属性或属性组的值能唯一标识一个元组，则称该属性或属性组为候选码。&lt;/li&gt;
&lt;li&gt;7、主码：又称为主键，若一个关系有多个候选码，则选定其中一个为主码。&lt;/li&gt;
&lt;li&gt;8、主属性：包含在任何候选码中的各个属性称为主属性。&lt;/li&gt;
&lt;li&gt;9、非主属性：不包含在任何候选码中的属性称为非主属性。&lt;/li&gt;
&lt;li&gt;10、外码：如果关系模式R中的属性或属性组非该关系的码，但它是其他关系的码，那么该属性集对关系模式R而言是外码。&lt;/li&gt;
&lt;li&gt;11、全码：关系模型的所有属性组是这个关系模式的候选码，称为全码。&lt;/li&gt;
&lt;li&gt;12、元组/记录：行&lt;/li&gt;
&lt;li&gt;13、字段、数据项&lt;/li&gt;
&lt;li&gt;14、元数：属性的个数（列数）&lt;/li&gt;
&lt;li&gt;15、基数：记录的个数（行数）&lt;/li&gt;
&lt;li&gt;16、n元关系：元数为几，就是几元关系。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;关系数据库模式&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;R(U,D,dom,F)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;R表示关系名&lt;/li&gt;
&lt;li&gt;U是组成该关系的属性名集合&lt;/li&gt;
&lt;li&gt;D是属性的域&lt;/li&gt;
&lt;li&gt;dom是属性向域的映像集合&lt;/li&gt;
&lt;li&gt;F为属性间数据的依赖关系集合&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;关系的三种类型&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;基本关系（基本表或基表）：它是实际存在的表，是实际存储数据的逻辑表示。&lt;/li&gt;
&lt;li&gt;查询表。查询结果对应的表。&lt;/li&gt;
&lt;li&gt;视图表。它是一种虚拟表，是由基本表或其他视图表导出的表。它本身是不独立存储在数据库的，数据库只存放它的定义。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;关系的完整性约束&lt;/h2&gt;
&lt;p&gt;是对关系的某种约束条件，用来保证用户对数据库作出修改时不会破坏数据的一致性，防止对数据的意外破坏&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;实体完整性：是指基本关系R的主属性不能取空值&lt;/li&gt;
&lt;li&gt;参照完整性&lt;/li&gt;
&lt;li&gt;用户定义完整性&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;关系运算&lt;/h1&gt;
&lt;h2&gt;基本的关系代数运算&lt;/h2&gt;
&lt;h3&gt;并&lt;/h3&gt;
&lt;p&gt;R∪S={t|t∈R∨t∈S}&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202504/images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2025-04-14-102430.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;差&lt;/h3&gt;
&lt;p&gt;R - S = { t | t ∈ R ˄ t ∉ S}&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202504/images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2025-04-14-102501.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;广义笛卡儿积&lt;/h3&gt;
&lt;p&gt;R×S&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202504/images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2025-04-14-102547.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;投影及广义投影&lt;/h3&gt;
&lt;p&gt;πA(R)={ t [A] | t ∈ R }&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202504/images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2025-04-14-102622.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;选择&lt;/h3&gt;
&lt;p&gt;σF(R)={ t | t ∈ R ∧ F(T) = True}&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202504/images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2025-04-14-103427.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;扩展的关系运算&lt;/h2&gt;
&lt;h3&gt;交&lt;/h3&gt;
&lt;p&gt;R∩S={t|t∈R∧t∈S}&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202504/images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2025-04-14-103559.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;连接&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;θ连接
&lt;ul&gt;
&lt;li&gt;由基本的关系运算&lt;strong&gt;笛卡儿积&lt;/strong&gt;和选取运算导出&lt;/li&gt;
&lt;li&gt;θ为比较运算符，如&amp;gt;、&amp;lt;、=、≠，X和Y分别为R和S上可以进行比较的属性组&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;等值连接⨝
&lt;ul&gt;
&lt;li&gt;θ为“=”时，称为等值连接&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;自然连接⨝
&lt;ul&gt;
&lt;li&gt;是一种特殊的等值连接&lt;/li&gt;
&lt;li&gt;在结果集中将重复属性列去掉&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;左外连接⟕
&lt;ul&gt;
&lt;li&gt;左侧为准，右侧填充&lt;/li&gt;
&lt;li&gt;&lt;img src=&quot;./guide/202504/images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2025-04-14-104630.png&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;右外连接⟖
&lt;ul&gt;
&lt;li&gt;右侧为准，左侧填充&lt;/li&gt;
&lt;li&gt;&lt;img src=&quot;./guide/202504/images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2025-04-14-104711.png&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;全外连接⟗
&lt;ul&gt;
&lt;li&gt;左、右连接并集&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;除&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202504/images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2025-04-14-104055.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202504/images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2025-04-14-105013.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</content:encoded></item><item><title>数据库系统工程师—6.数据库技术基础</title><link>https://minthana.github.io/blog/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%B7%A5%E7%A8%8B%E5%B8%88-6-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/</link><guid isPermaLink="true">https://minthana.github.io/blog/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%B7%A5%E7%A8%8B%E5%B8%88-6-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/</guid><pubDate>Sun, 13 Apr 2025 08:39:00 GMT</pubDate><content:encoded>&lt;h1&gt;数据库技术基础&lt;/h1&gt;
&lt;h2&gt;DBMS功能、特点、分类&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;数据库管理系统&lt;/strong&gt;主要功能包括&lt;strong&gt;数据定义、数据库操作、管理和存取&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据定义：DDL&lt;/li&gt;
&lt;li&gt;数据库操作：DML&lt;/li&gt;
&lt;li&gt;数据库运行管理&lt;/li&gt;
&lt;li&gt;数据组织、存储、管理&lt;/li&gt;
&lt;li&gt;数据库的建立与维护&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;DBMS特点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据结构化统一管理&lt;/li&gt;
&lt;li&gt;有较高的数据独立性&lt;/li&gt;
&lt;li&gt;数据控制功能
&lt;ul&gt;
&lt;li&gt;数据的安全性&lt;/li&gt;
&lt;li&gt;数据的完整性&lt;/li&gt;
&lt;li&gt;并发控制&lt;/li&gt;
&lt;li&gt;故障恢复&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;DBMS分类&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;关系数据库系统：RDBS&lt;/li&gt;
&lt;li&gt;面向对象的数据库系统：OODBS&lt;/li&gt;
&lt;li&gt;对象关系数据库系统：ORDBS&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;数据库系统体系结构分类&lt;/h2&gt;
&lt;p&gt;数据库系统体系结构分为&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;集中式&lt;/li&gt;
&lt;li&gt;分布式&lt;/li&gt;
&lt;li&gt;C/S（客户端/服务器）&lt;/li&gt;
&lt;li&gt;并行结构&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;数据库系统的三级模式结构&lt;/h2&gt;
&lt;h3&gt;数据库的三级模式结构&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202504/images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2025-04-13-081213.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;数据抽象&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;视图层：描述整个数据库的某个部分&lt;/li&gt;
&lt;li&gt;逻辑层：描述数据库中存储什么数据以及这些数据间存在什么关系&lt;/li&gt;
&lt;li&gt;物理层：描述数据在存储器中是如何存储的&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;三级模式&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;外模式：也称用户模式或子模式，是用户与数据库系统的接口，是用户用到的那部分数据的描述。&lt;/li&gt;
&lt;li&gt;概念模式：也称&lt;strong&gt;模式&lt;/strong&gt;，是数据库中全部数据的逻辑结构和特征的描述，只涉及型的描述，不涉及具体的值。&lt;/li&gt;
&lt;li&gt;内模式：也称存储模式，是数据物理结构和存储方式的描述，定义所有的内部记录类型、索引和文件的组织方式，以及数据控制方面的细节。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;两级映像&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;模式/内模式映像&lt;/li&gt;
&lt;li&gt;外模式/模式映像&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;数据的独立性&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;数据的物理独立性：它是指当数据库的内模式发生改变时，数据的逻辑结构不变&lt;/li&gt;
&lt;li&gt;数据的逻辑独立性：它是指用户的应用程序与数据库的逻辑结构是相互独立的，数据的逻辑结构发生变化后，用户程序也可以不修改，但是，为了程序能够正确执行，需要修改外模式/模式之间的映像&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;数据模型&lt;/h2&gt;
&lt;p&gt;什么是数据模型？就是对现实世界数据特征的抽象。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;概念数据模型
&lt;ul&gt;
&lt;li&gt;也称为信息模型，是现实世界到信息世界的第一层抽象，按用户的观点对数据和信息建模&lt;/li&gt;
&lt;li&gt;E-R模型（实体联系）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;基本数据模型：
&lt;ul&gt;
&lt;li&gt;是按照计算机系统的观点对数据建模，是现实世界数据特征的抽象，用于DBMS的实现&lt;/li&gt;
&lt;li&gt;层次模型，网状模型、关系模型和面向对象数据模型&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;数据模型的三要素&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;数据结构&lt;/li&gt;
&lt;li&gt;数据操作&lt;/li&gt;
&lt;li&gt;约束条件&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;E-R模型&lt;/h2&gt;
&lt;h3&gt;实体&lt;/h3&gt;
&lt;p&gt;实体是现实世界中可以区别于其他对象的“事物”或“物体”，每个实体由一组特性（属性）来表示，其中的某一部分属性可以唯一标识某个实体，如职工号&lt;/p&gt;
&lt;h3&gt;联系&lt;/h3&gt;
&lt;p&gt;两个&lt;strong&gt;不同实体之间&lt;/strong&gt;的联系&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一对一（1:1）&lt;/li&gt;
&lt;li&gt;一对多（1:*）&lt;/li&gt;
&lt;li&gt;多对多（*:*）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;两个以上&lt;strong&gt;不同实体集之间&lt;/strong&gt;的联系&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1:1:1&lt;/li&gt;
&lt;li&gt;1:1:*&lt;/li&gt;
&lt;li&gt;1:*:*&lt;/li&gt;
&lt;li&gt;*:*:*&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;同一实体集内&lt;/strong&gt;的二元联系&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1:*&lt;/li&gt;
&lt;li&gt;*:*&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;属性&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;简单属性和复合属性：简单属性是原子的、不可再分的，复合属性可以细分为更小的部分。如通信地址可以进一步细分为省、市、街道、邮编等。&lt;/li&gt;
&lt;li&gt;单值属性和多值属性：指一个属性有单个值或多个值。如职工的亲属姓名。&lt;/li&gt;
&lt;li&gt;NULL属性：当实体在某个属性上没有值或属性值未知时，使用NULL值。表示无意义或不知道。&lt;/li&gt;
&lt;li&gt;派生属性：可以从其他属性得来。如参加工作时间和工作年限，身份证号和年龄等。&lt;/li&gt;
&lt;/ul&gt;
</content:encoded></item><item><title>数据库系统工程师—5.4 信息安全与网络安全</title><link>https://minthana.github.io/blog/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%B7%A5%E7%A8%8B%E5%B8%88-5-4-%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/</link><guid isPermaLink="true">https://minthana.github.io/blog/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%B7%A5%E7%A8%8B%E5%B8%88-5-4-%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/</guid><pubDate>Fri, 11 Apr 2025 15:28:00 GMT</pubDate><content:encoded>&lt;h1&gt;信息安全与网络安全&lt;/h1&gt;
&lt;h2&gt;常见的网络攻击技术&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;篡改消息&lt;/li&gt;
&lt;li&gt;伪造（伪装、假冒）&lt;/li&gt;
&lt;li&gt;重放：发送一个目的主机已接收过的包，来达到欺骗系统的目的，主要用于身份认证过程，破坏认证的正确性。.&lt;/li&gt;
&lt;li&gt;拒绝服务(DOS)&lt;/li&gt;
&lt;li&gt;窃听（截取）&lt;/li&gt;
&lt;li&gt;流量分析（通信量分析）&lt;/li&gt;
&lt;li&gt;字典攻击&lt;/li&gt;
&lt;li&gt;社会工程学攻击&lt;/li&gt;
&lt;li&gt;SQL注入攻击&lt;/li&gt;
&lt;li&gt;会话劫持&lt;/li&gt;
&lt;li&gt;漏洞扫描&lt;/li&gt;
&lt;li&gt;缓冲区溢出&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;主动攻击与被动攻击&lt;/h2&gt;
&lt;p&gt;主动攻击：击会导致某些数据流被篡改或者产生虚假的数据流&lt;/p&gt;
&lt;p&gt;被动攻击：并不对数据信息做任何修改，也不产生虚假的数据流&lt;/p&gt;
&lt;h2&gt;安全的分类&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;物理安全&lt;/li&gt;
&lt;li&gt;网络安全&lt;/li&gt;
&lt;li&gt;系统安全&lt;/li&gt;
&lt;li&gt;应用安全&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;防火墙技术&lt;/h2&gt;
&lt;p&gt;防火墙技术经历了&lt;strong&gt;包过滤、应用代理网关和状态检测技术&lt;/strong&gt;三个发展阶段。&lt;/p&gt;
&lt;h3&gt;包过滤防火墙&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;它处于网络层和数据链路层&lt;/li&gt;
&lt;li&gt;通过**包检查块（包过滤器）**检查模块，对每一个传入和传出网络的IP包打开进行检查，例如源地址、目的地址、协议和端口等，对于不符合包过滤规则的包进行记录，发出报警并丢弃该包&lt;/li&gt;
&lt;li&gt;对用户完全透明，速度较快。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;应用代理网关防火墙&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;能彻底隔断内网与外网的直接通信，内网用户对外网的访问变成了防火墙对外网的访问，然后再由防火墙转发给内网用户。&lt;/li&gt;
&lt;li&gt;可以检查应用层、传输层和网络层的协议特征，对数据包的检测能力比较强&lt;/li&gt;
&lt;li&gt;难以配置，处理速度非常慢。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;状态检测技术防火墙&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;结合了代理防火墙的安全性和包过滤防火墙的高速等优点&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;入侵检测与防御&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;入侵检测系统(IDS)&lt;/li&gt;
&lt;li&gt;入侵防御系统(IPS)&lt;/li&gt;
&lt;/ul&gt;
</content:encoded></item><item><title>数据库系统工程师—5.1~5.3计算机网络概述与网络硬件基础、网络的协议与标准、Internet基础知识</title><link>https://minthana.github.io/blog/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%B7%A5%E7%A8%8B%E5%B8%88-5-15-3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0%E4%B8%8E%E7%BD%91%E7%BB%9C%E7%A1%AC%E4%BB%B6/</link><guid isPermaLink="true">https://minthana.github.io/blog/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%B7%A5%E7%A8%8B%E5%B8%88-5-15-3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0%E4%B8%8E%E7%BD%91%E7%BB%9C%E7%A1%AC%E4%BB%B6/</guid><pubDate>Thu, 10 Apr 2025 10:59:00 GMT</pubDate><content:encoded>&lt;h1&gt;计算机网络概述与网络硬件基础&lt;/h1&gt;
&lt;h2&gt;计算机网络的分类&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;局域网 LAN&lt;/li&gt;
&lt;li&gt;城域网 MAN&lt;/li&gt;
&lt;li&gt;广域网 WAN&lt;/li&gt;
&lt;li&gt;个域网 PAN&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;网络的拓扑结构&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;总线型&lt;/li&gt;
&lt;li&gt;星型&lt;/li&gt;
&lt;li&gt;环型&lt;/li&gt;
&lt;li&gt;树型&lt;/li&gt;
&lt;li&gt;分布式结构&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;网络互连设备&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;物理层
&lt;ul&gt;
&lt;li&gt;中继器：实现局域网网段互连的，用于扩展局域网网段的长度。&lt;/li&gt;
&lt;li&gt;集线器：多路中继器。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;数据链路层
&lt;ul&gt;
&lt;li&gt;网桥：连接两个不同的网段，对帧进行过滤与转发。&lt;/li&gt;
&lt;li&gt;二层交换机：多端口网桥，按物理地址对帧进行数据转发。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;网络层
&lt;ul&gt;
&lt;li&gt;路由器：连接不同的子网，根据IP地址进行路由选择与数据的分组交换。&lt;/li&gt;
&lt;li&gt;三层交换机：在二层交换机的基础上增加了部分网络层的功能。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;应用层
&lt;ul&gt;
&lt;li&gt;网关：进行协议转换，可以使不同类型的网络系统之间进行通信。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202504/images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2025-04-10-100745.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;网络传输介质&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;双绞线&lt;/li&gt;
&lt;li&gt;同轴电缆&lt;/li&gt;
&lt;li&gt;光纤&lt;/li&gt;
&lt;li&gt;微波&lt;/li&gt;
&lt;li&gt;红外线和激光&lt;/li&gt;
&lt;li&gt;卫星通信&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;网络的协议与标准&lt;/h1&gt;
&lt;h2&gt;ISO/OSI参考模型&lt;/h2&gt;
&lt;p&gt;物理层、数据链路层、网络层、传输层、会话层、表示层、应用层&lt;/p&gt;
&lt;h2&gt;TCP/IP协议簇&lt;/h2&gt;
&lt;p&gt;TCP/IP体系（事实上的国际标准）&lt;/p&gt;
&lt;p&gt;下往上依次是 &lt;strong&gt;网络接口层、网际层、运输层、应用层&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;特性&lt;/h3&gt;
&lt;p&gt;TCP/IP协议是&lt;strong&gt;Internet的核心协议&lt;/strong&gt;，是迄今为止发展最为成熟的互联网络协议系统。&lt;/p&gt;
&lt;p&gt;（1）&lt;strong&gt;逻辑编址&lt;/strong&gt;。每一台连入互联网的设备都要分配一个IP地址，一个IP地址包含网络号，子网络号和主机号，因此可以通过IP地址很方便地找到对应的设备。&lt;/p&gt;
&lt;p&gt;（2）&lt;strong&gt;路由选择&lt;/strong&gt;。在TCP/IP协议中包含了专门用于定义路由器如何选择网络路径的协议，即IP数据包的路由选择。&lt;/p&gt;
&lt;p&gt;（3）&lt;strong&gt;域名解析&lt;/strong&gt;。为了方便用户记忆，专门设计了一种更方便的字母式地址结构，称为域名。将域名映射为IP地址的操作，称为域名解析。&lt;/p&gt;
&lt;p&gt;（4）&lt;strong&gt;错误检测与流量控制&lt;/strong&gt;。TCP/IP协议可以检测数据信息的传输错误，确认已传递的数据信息已被成功接收，监测网络系统中的信息流量，防止出现网络拥塞&lt;/p&gt;
&lt;h3&gt;网际层协议&lt;/h3&gt;
&lt;h4&gt;IP&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;IP所提供的服务通常被认为是&lt;strong&gt;无连接的和不可靠的&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;差错检测&lt;/strong&gt;和&lt;strong&gt;流量控制&lt;/strong&gt;之类的服务&lt;strong&gt;授权给了其他的各层协议&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;功能：&lt;/p&gt;
&lt;p&gt;（1）将上层数据（TCP/UDP数据）或同层的其他数据（如ICMP数据）&lt;strong&gt;封装到IP数据报中&lt;/strong&gt;；&lt;/p&gt;
&lt;p&gt;（2）将IP数据报&lt;strong&gt;传送到最终目的地&lt;/strong&gt;；&lt;/p&gt;
&lt;p&gt;（3）为了使数据能够在链路层上进行传输&lt;strong&gt;对数据进行分段&lt;/strong&gt;；&lt;/p&gt;
&lt;p&gt;（4）&lt;strong&gt;确定&lt;/strong&gt;数据报到达其他网络中的&lt;strong&gt;目的地的路径&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202504/images/tcpip-e1744251842804.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h4&gt;ARP和RARP（地址解析协议）&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;ARP 将IP地址转化为物理地址MAC&lt;/li&gt;
&lt;li&gt;RARP 将MAC地址→IP地址&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;ICMP（网络控制信息协议）&lt;/h4&gt;
&lt;p&gt;主要功能有：通告网络故障、通告网络拥堵、协助解决故障&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;是一个&lt;strong&gt;专门用于发送差错报文&lt;/strong&gt;的协议。&lt;/li&gt;
&lt;li&gt;由于IP是一种尽力传送的协议，传送的数据报有可能丢失、重复、延迟或乱序，因此IP需要一种&lt;strong&gt;避免差错并在发生差错时报告的机制。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;传输层协议&lt;/h3&gt;
&lt;h4&gt;TCP&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;TCP提供了一个&lt;strong&gt;可靠的&lt;/strong&gt;、&lt;strong&gt;面向连接的&lt;/strong&gt;、&lt;strong&gt;全双工的数据传输服务&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;它采用了一种叫做**“重发”的技术**。&lt;/li&gt;
&lt;li&gt;TCP协议一般用于&lt;strong&gt;传输数据量比较少&lt;/strong&gt;，且对可靠性要求高的场合&lt;/li&gt;
&lt;li&gt;TCP&lt;strong&gt;建立和关闭连接时&lt;/strong&gt;，通过&lt;strong&gt;三次握手和四次挥手&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;UDP&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;UDP是一种&lt;strong&gt;不可靠的&lt;/strong&gt;、&lt;strong&gt;无连接的&lt;/strong&gt;协议，可以保证应用程序进程间的通信。&lt;/li&gt;
&lt;li&gt;不负责重新发送丢失的或出错、不对接收到的无序IP数据报重新排序、不消除重复的IP数据报、不对已收到数据进行确认、也不负责建立或终止连接。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;应用层协议&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;FTP（File Transport Protocol 文件传输协议）
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;TCP&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;21端口控制、20端口传输数据&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;SFTP（SSH File Transfer Protocol 安全文件传输协议）
&lt;ul&gt;
&lt;li&gt;建立在TCP之上，默认端口号22&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;TFTP（Trivial File Transfer Protocol 简单文件传输协议）
&lt;ul&gt;
&lt;li&gt;UDP&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Telnet(远程登录协议）
&lt;ul&gt;
&lt;li&gt;建立在TCP之上，使用23端口&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;HTTP（Hypertext Transfer Protocol 超文本传输协议）
&lt;ul&gt;
&lt;li&gt;TCP&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;HTTPS(Hypertext Transfer Protocol Secure 超文本传输安全协议）
&lt;ul&gt;
&lt;li&gt;HTTPS在HTTP的基础上&lt;strong&gt;加入SSL(安全套接层）&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;DHCP（Dynamic Host Configuration Protocol 动态主机配置协议）
&lt;ul&gt;
&lt;li&gt;动态地分配IP地址和配置信息&lt;/li&gt;
&lt;li&gt;UDP&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;DNS(Domain Name System 域名系统）&lt;/li&gt;
&lt;li&gt;SNMP(Simple Network Management Protocol 简单网络管理协议）
&lt;ul&gt;
&lt;li&gt;UDP&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;SMTP（Simple Mail Transfer Protocol 简单邮件传输协议）
&lt;ul&gt;
&lt;li&gt;建立在TCP之上，端口号25。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202504/images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2025-04-10-103742-1024x426.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h1&gt;Internet基础知识&lt;/h1&gt;
&lt;h2&gt;域名&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;域名的格式
&lt;ul&gt;
&lt;li&gt;计算机主机名.本地名.组名.最高层域名&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;URL的格式
&lt;ul&gt;
&lt;li&gt;协议://主机.域名[:端口号]/路径/文件名&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;IPV4&lt;/h2&gt;
&lt;p&gt;IP地址的格式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个IPV4地址占4字节(&lt;strong&gt;32位&lt;/strong&gt;)&lt;/li&gt;
&lt;li&gt;转成十进制后，为4个十进制数字&lt;/li&gt;
&lt;li&gt;每个十进制数字的取值范围为0~255&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;IP地址的分类&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A类
&lt;ul&gt;
&lt;li&gt;网络地址数：主机地址数为1：3&lt;/li&gt;
&lt;li&gt;网络地址以0开头&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;B类
&lt;ul&gt;
&lt;li&gt;网络地址数：主机地址数为1：1&lt;/li&gt;
&lt;li&gt;网络地址以10开头&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;C类
&lt;ul&gt;
&lt;li&gt;网络地址数：主机地址数为3：1&lt;/li&gt;
&lt;li&gt;网络地址以110开头&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;需注意：主机号全为&lt;strong&gt;0代表网段&lt;/strong&gt;、全为&lt;strong&gt;1代表广播地址&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;子网掩码&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;子网掩码是&lt;strong&gt;结合&lt;/strong&gt;IP地址&lt;strong&gt;来看的&lt;/strong&gt;，用于&lt;strong&gt;区分网络号和主机号&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;网络号用1表示，主机号用0表示&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;IPV6&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;IPv6的地址空间为128位，是IPV4的4倍&lt;/li&gt;
&lt;/ul&gt;
</content:encoded></item><item><title>数据库系统工程师—4.3~4.4设备管理、文件管理与作业管理</title><link>https://minthana.github.io/blog/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%B7%A5%E7%A8%8B%E5%B8%88-4-34-4%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E4%B8%8E%E4%BD%9C%E4%B8%9A/</link><guid isPermaLink="true">https://minthana.github.io/blog/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%B7%A5%E7%A8%8B%E5%B8%88-4-34-4%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E4%B8%8E%E4%BD%9C%E4%B8%9A/</guid><pubDate>Tue, 08 Apr 2025 21:08:00 GMT</pubDate><content:encoded>&lt;h1&gt;设备管理&lt;/h1&gt;
&lt;h2&gt;设备的分类&lt;/h2&gt;
&lt;p&gt;（1）按数据组织分类：设备可分为块设备和字符设备：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;块设备：是指以数据块为单位来组织和传送数据信息的设备，如磁盘&lt;/li&gt;
&lt;li&gt;字符设备：是指以单个字符为单位来传送数据信息的设备，如交互式终端、打印机、鼠标键盘等&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;（2）按功能分类：可分为输入设备、输出设备、存储设备、网络联网设备、供电设备等&lt;/p&gt;
&lt;p&gt;（3）从资源分配角度分类：可分为独占设备、共享设备和虚拟设备&lt;/p&gt;
&lt;p&gt;（4）按数据传输率分类：设备分为低速设备、中速设备和高速设备&lt;/p&gt;
&lt;h2&gt;I/O设备管理软件&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;设备管理的目标主要是如何提高设备的利用率，即提高CPU与I/O设备之间的并行操作速度，并为用户提供方便、统一的界面。&lt;/li&gt;
&lt;li&gt;为了提高设备的利用率，我们采用了“分层构造”的思想，即把设备管理软件组织成为一系列的层次。&lt;/li&gt;
&lt;li&gt;主要分为4层：中断处理程序、设备驱动程序、与设备无关的系统软件和用户级软件&lt;/li&gt;
&lt;li&gt;各层之间既相互独立，又彼此协作&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202504/images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2025-04-08-204356.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;例：某用户进程现在需要读取硬盘中的数据。&lt;/p&gt;
&lt;p&gt;① 与设备无关软件检查高速缓存中有没有要读的数据块，如果有，则直接从高速缓存中调取；如果没有，则调用设备驱动程序，向I/O硬件发出一个请求。&lt;/p&gt;
&lt;p&gt;② 用户进程转为阻塞状态，等待磁盘操作的完成。磁盘操作完成时，硬件产生一个中断，转入中断处理程序。&lt;/p&gt;
&lt;p&gt;③ 中断处理程序检查中断的原因，认识到这时磁盘读取数据的操作已经完成，于是唤醒用户进程取回从磁盘读取的信息，此次I/O请求结束。&lt;/p&gt;
&lt;p&gt;④ 用户进程得到了需要读取的数据内容，由阻塞转为就绪状态，继续运行。&lt;/p&gt;
&lt;h2&gt;设备管理采用的相关技术&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;通道技术&lt;/strong&gt; ：像高速公路，让数据直达目的地，减少CPU拥堵。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;DMA技术&lt;/strong&gt; ：自动搬运工，绕过CPU直接传输数据，提升效率。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;缓冲技术&lt;/strong&gt; ：蓄水池，平衡数据流，防止溢出或干涸。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Spooling技术&lt;/strong&gt; ：临时中转站，暂存任务，优化设备利用率。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;磁盘调度算法&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;磁盘调度分为&lt;strong&gt;移臂调度&lt;/strong&gt;和&lt;strong&gt;旋转调度&lt;/strong&gt;两类，先进行移臂调度，再进行旋转调度。&lt;/li&gt;
&lt;li&gt;由于访问磁盘最耗时的是寻道时间，因此，磁盘调度的目标是使磁盘的平均寻道时间最少。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;读取磁盘数据的时间 = 寻道时间 + 旋转延迟时间 + 数据传输时间&lt;/p&gt;
&lt;p&gt;寻道时间：把磁头移动到指定磁道上所经历的时间。（通常&lt;strong&gt;寻道时间是最长的&lt;/strong&gt;）&lt;/p&gt;
&lt;p&gt;旋转延迟时间（旋转等待时间）：指定扇区移动到磁头下面所经历的时间。&lt;/p&gt;
&lt;p&gt;数据传输时间：从磁盘读出或向磁盘写入数据所花费的时间。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202504/images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2025-04-08-205233.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;磁盘调度算法&lt;/h2&gt;
&lt;h3&gt;移臂调度算法&lt;/h3&gt;
&lt;p&gt;（1）先来先服务：根据进程请求的先后次序进行调度。保证所有进程的请求都得到回应，但是平均寻道时间可能很长。&lt;/p&gt;
&lt;p&gt;（2）最短寻道时间优先：选择访问的磁道与当前磁头所在的磁道距离最近的，使得每次的寻道时间最短&lt;/p&gt;
&lt;p&gt;（3）扫描算法（类似电梯调度）：不仅考虑到要访问的磁道与当前磁道的距离，更优先考虑的是磁头当前的移动方向。&lt;/p&gt;
&lt;p&gt;（4）单向扫描调度算法：在扫描算法的基础上，规定磁头只做单向移动。&lt;/p&gt;
&lt;h3&gt;旋转调度算法&lt;/h3&gt;
&lt;p&gt;（1）如果进程请求访问的是&lt;strong&gt;不同编号的扇区&lt;/strong&gt;（无论是否在同一磁道），则总是让首先到达磁头位置下的扇区先进行读写操作。&lt;/p&gt;
&lt;p&gt;（2）如果进程请求访问的是&lt;strong&gt;相同编号的扇区&lt;/strong&gt;（无论是否在同一磁道），旋转调度时可以任选一个扇区进行读写操作。&lt;/p&gt;
&lt;h1&gt;文件管理与作业管理&lt;/h1&gt;
&lt;h2&gt;文件的结构和组织&lt;/h2&gt;
&lt;p&gt;文件的逻辑结构：从用户角度看到的文件组织形式就是文件的逻辑结构，但实际上这些文件在内存上的存放方式可能并不是这样的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;有结构的记录式文件&lt;/li&gt;
&lt;li&gt;无结构的流式文件&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;文件的物理结构：从实现的角度看，文件在存储器上的存放方式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;连续结构&lt;/li&gt;
&lt;li&gt;链接结构&lt;/li&gt;
&lt;li&gt;索引结构&lt;/li&gt;
&lt;li&gt;多个物理块的索引表&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;文件的目录结构&lt;/h2&gt;
&lt;p&gt;（1）一级目录结构：只有一张目录表，不允许重名，查找速度慢，不能实现文件共享。&lt;/p&gt;
&lt;p&gt;（2）二级目录结构：由主文件目录和用户目录组成。&lt;/p&gt;
&lt;p&gt;（3）多级目录结构：我们熟悉的Windows系统，以及UNIX系统都采用这种多级目录结构。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;绝对地址&lt;/li&gt;
&lt;li&gt;相对地址：是从当前工作目录下的路径名&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;文件存储空间的管理&lt;/h2&gt;
&lt;p&gt;在将文件保存到外存时，我们首先要知道哪些存储空间是“占用”的，哪些存储空间是“空闲”的。因此我们需要对磁盘空间进行管理。&lt;/p&gt;
&lt;h3&gt;空闲区表&lt;/h3&gt;
&lt;p&gt;操作系统为磁盘的所有空闲区建立一张空闲表。它&lt;strong&gt;适用于连续文件结构&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202504/images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2025-04-08-210317.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;位示图&lt;/h3&gt;
&lt;p&gt;在外存上建立一张位示图（bitmap），记录文件存储器的使用情况。每一位对应文件存储器上的一个物理块，0表示空闲，1表示占用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202504/images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2025-04-08-210521.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;空闲块链&lt;/h3&gt;
&lt;p&gt;每一个&lt;strong&gt;空闲物理块中设置一个指针&lt;/strong&gt;，它&lt;strong&gt;指向下一个&lt;/strong&gt;空闲物理块，所有空闲物理块&lt;strong&gt;构成一个链表&lt;/strong&gt;，链表的&lt;strong&gt;头指针放在文件存储器&lt;/strong&gt;的一个特定位置上（如管理块中）。&lt;/p&gt;
&lt;h3&gt;成组链接法&lt;/h3&gt;
&lt;p&gt;在系统中将&lt;strong&gt;空闲块分成若干个组&lt;/strong&gt;，每100个空闲块为一组，&lt;strong&gt;每组的第一个&lt;/strong&gt;空闲块&lt;strong&gt;登记了下一组空闲块的物理盘块号和空闲块总数&lt;/strong&gt;。&lt;/p&gt;
&lt;h2&gt;作业调度算法&lt;/h2&gt;
&lt;p&gt;（1）先来先服务：按作业到达的先后顺序进行调度。&lt;/p&gt;
&lt;p&gt;（2）短作业优先：按作业运行时间的长短进行调度，即启动要求运行时间最短的作业。&lt;/p&gt;
&lt;p&gt;（3）响应比高优先：响应比高的作业优先启动。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;响应比：RP = 作业响应时间/作业执行时间=&lt;strong&gt;（作业等待时间+作业执行时间）/作业执行时间&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;（4）优先级调度算法：按照系统设定的优先级或者用户指定的优先级，优先级高的先调度。&lt;/p&gt;
&lt;p&gt;（5）均衡调度算法：根据系统的运行情况和作业本身的特性对作业进行分类，力求均衡地使用系统的各种资源，即注意发挥系统效率，又使用户满意。&lt;/p&gt;
</content:encoded></item><item><title>数据库系统工程师—4.2存储管理</title><link>https://minthana.github.io/blog/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%B7%A5%E7%A8%8B%E5%B8%88-4-2%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/</link><guid isPermaLink="true">https://minthana.github.io/blog/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%B7%A5%E7%A8%8B%E5%B8%88-4-2%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/</guid><pubDate>Mon, 07 Apr 2025 14:31:00 GMT</pubDate><content:encoded>&lt;h1&gt;存储管理&lt;/h1&gt;
&lt;h2&gt;基本概念&lt;/h2&gt;
&lt;h3&gt;存储器的层次结构&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202504/images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2025-04-07-135658.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;地址&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;逻辑地址（虚拟地址、相对地址）：程序员使用的地址只是用符号命名的一个地址，称为符号名地址，这个地址并不是主存中真实存在的地址&lt;/li&gt;
&lt;li&gt;物理地址（绝对地址）：是主存中真实存在的地址。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;地址重定向&lt;/h3&gt;
&lt;p&gt;定义&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;程序未运行&lt;/strong&gt;时，存储&lt;strong&gt;在外存&lt;/strong&gt;，&lt;strong&gt;运行&lt;/strong&gt;时，需要&lt;strong&gt;装载到内存&lt;/strong&gt;中。&lt;/li&gt;
&lt;li&gt;把程序中的指令和数据的&lt;strong&gt;逻辑地址转换为对应的物理地址&lt;/strong&gt;，这个转换的过程称为&lt;strong&gt;地址重定位&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;静态重定位：在&lt;strong&gt;程序装入主存时已经完成&lt;/strong&gt;了逻辑地址到物理地址的变化，在程序的执行期间不会再发生变化。&lt;/p&gt;
&lt;p&gt;动态重定位：在&lt;strong&gt;程序运行期间完成&lt;/strong&gt;逻辑地址到物理地址的变换&lt;/p&gt;
&lt;h2&gt;分区存储管理&lt;/h2&gt;
&lt;p&gt;分区存储管理：&lt;strong&gt;把主存划分成若干个区域&lt;/strong&gt;，每个区域分配给一个作业使用。这就是分区存储管理方式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;固定分区&lt;/strong&gt;：系统&lt;strong&gt;生成时已经分好区&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可变分区&lt;/strong&gt;：是一种&lt;strong&gt;动态分区方式&lt;/strong&gt;，存储空间的&lt;strong&gt;划分&lt;/strong&gt;是在&lt;strong&gt;作业装入时进行的&lt;/strong&gt;，故分区的个数是可变的，&lt;strong&gt;分区的大小刚好等于作业的大小&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可重定位分区&lt;/strong&gt;：分配好的区域&lt;strong&gt;可以移动&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;分页存储管理&lt;/h2&gt;
&lt;h3&gt;分页原理&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;页：将&lt;strong&gt;进程地址空间&lt;/strong&gt;划分为若干个大小相等的区域&lt;/li&gt;
&lt;li&gt;块（页框）：将&lt;strong&gt;主存的空间&lt;/strong&gt;也划分成与&lt;strong&gt;页相同大小&lt;/strong&gt;的若干个物理块&lt;/li&gt;
&lt;li&gt;在为进程&lt;strong&gt;分配主存时&lt;/strong&gt;，将&lt;strong&gt;进程中若干页分别装入多个不相邻接（离散）的块中&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;地址结构：&lt;strong&gt;页号&lt;/strong&gt; | &lt;strong&gt;页内地址&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;页表&lt;/h3&gt;
&lt;p&gt;系统为每个进程建立了一张页面映射表，保证在主存中找到进程要访问的页面所对应的物理块&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202504/images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2025-04-07-140757.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;地址变换过程&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202504/images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2025-04-07-140855.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;分段存储管理&lt;/h2&gt;
&lt;h3&gt;分段原理&lt;/h3&gt;
&lt;p&gt;将用户程序或作业的地址空间&lt;strong&gt;按内容划分为段&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;比如主程序一段，子程序一段，数据专门放一段，每个段的长度是不等的，但是&lt;strong&gt;每个段占用一个连续的分区&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;地址结构：&lt;strong&gt;段号&lt;/strong&gt; | &lt;strong&gt;段内地址&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;段表&lt;/h3&gt;
&lt;p&gt;进程中的各个段可以离散地分配到主存的不同分区中。在系统中为每个进程建立一张段映射表，简称为“段表”。&lt;img src=&quot;./guide/202504/images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2025-04-07-141305.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;地址变换过程&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202504/images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2025-04-07-141455.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;段页式存储管理&lt;/h2&gt;
&lt;h3&gt;段页式原理&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;先将整个主存划分成大小相等的存储块&lt;/li&gt;
&lt;li&gt;将用户程序按程序的逻辑关系&lt;strong&gt;先分为若干个段&lt;/strong&gt;，然后&lt;strong&gt;再将段划分成页&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;地址：&lt;strong&gt;段号&lt;/strong&gt; | &lt;strong&gt;页号&lt;/strong&gt; | &lt;strong&gt;页内地址&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;段页式存储管理同时拥有段表和页表&lt;/p&gt;
&lt;h3&gt;地址变换过程&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202504/images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2025-04-07-141906.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;虚拟存储管理&lt;/h2&gt;
&lt;h3&gt;时间局限性&lt;/h3&gt;
&lt;p&gt;程序中的某条指令一旦执行，则不久的将来很有可能再次被访问；某个存储单元如果被访问，不久的将来它很可能再次被访问。&lt;/p&gt;
&lt;h3&gt;空间局限性&lt;/h3&gt;
&lt;p&gt;一旦程序访问了某个存储单元，则不久的将来，其附近的存储单元也最有可能被访问。&lt;/p&gt;
&lt;p&gt;如果我们运行程序的时候，允许将作业的一部分装入主存即可运行程序，而其余部分可以暂时留在磁盘上，等需要的时候再装入主存。这样一来，一个小的主存空间就可以运行比它大的一个作业。从用户角度看，系统具有的主存容量比实际的主存容量要大得多，称为虚拟存储器。&lt;/p&gt;
&lt;h2&gt;页面置换算法&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;最佳置换算法：选择那些是永不使用的，或者是在最长时间内不再被访问的页面置换出去。&lt;/li&gt;
&lt;li&gt;先进先出置换算法(FIFO)：优先淘汰内存中停留时间最长的页面&lt;/li&gt;
&lt;li&gt;最近最少未使用算法(LRU)：优先淘汰最近这段时间用得最少的页面&lt;/li&gt;
&lt;li&gt;最近未用置换算法(NUR)：优先淘汰最近一段时间未引用过的页面&lt;/li&gt;
&lt;/ul&gt;
</content:encoded></item><item><title>数据库系统工程师—4.1进程管理</title><link>https://minthana.github.io/blog/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%B7%A5%E7%A8%8B%E5%B8%88-4-1%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/</link><guid isPermaLink="true">https://minthana.github.io/blog/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%B7%A5%E7%A8%8B%E5%B8%88-4-1%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/</guid><pubDate>Mon, 07 Apr 2025 13:53:00 GMT</pubDate><content:encoded>&lt;h1&gt;操作系统基本概念&lt;/h1&gt;
&lt;p&gt;操作系统的4个特征&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;并发性&lt;/li&gt;
&lt;li&gt;共享性&lt;/li&gt;
&lt;li&gt;虚拟性&lt;/li&gt;
&lt;li&gt;不确定性&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;操作系统的五大功能&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;进程管理&lt;/li&gt;
&lt;li&gt;文件管理&lt;/li&gt;
&lt;li&gt;存储管理&lt;/li&gt;
&lt;li&gt;设备管理&lt;/li&gt;
&lt;li&gt;作业管理&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;操作系统的定义：能&lt;strong&gt;有效地组织和管理系统中的各种软/硬件资源&lt;/strong&gt;，合理地组织计算机系统的工作流程，控制程序的执行，并且向用户&lt;strong&gt;提供一个良好的工作环境和友好的接口&lt;/strong&gt;。&lt;/p&gt;
&lt;h1&gt;进程管理&lt;/h1&gt;
&lt;h2&gt;概念&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;进程组成：&lt;strong&gt;程序&lt;/strong&gt; | &lt;strong&gt;数据&lt;/strong&gt; | &lt;strong&gt;PCB&lt;/strong&gt;（进程控制块）&lt;/li&gt;
&lt;li&gt;进程是程序的一次执行&lt;/li&gt;
&lt;li&gt;基本单位：进程是&lt;strong&gt;资源分配&lt;/strong&gt;和&lt;strong&gt;独立运行的基本单位&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;两个基本属性：可拥有资源的独立单位；可独立调度和分配的基本单位&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;状态转换&lt;/h2&gt;
&lt;p&gt;三个状态：就绪、阻塞、等待状态&lt;/p&gt;
&lt;h3&gt;三态模型和五态模型&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202504/images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2025-04-07-133349.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;进程间的同步与互斥&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;同步：是指在系统中一些需要&lt;strong&gt;相互合作，协同工作&lt;/strong&gt;的进程，这样的相互联系称为进程的同步&lt;/li&gt;
&lt;li&gt;互斥：是指系统中多个进程因&lt;strong&gt;争用临界资源而互斥执行&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;临界资源：是指有些资源一次只能供一个进程使用。如打印机、共享变量等&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;信号量机制（P、V操作）&lt;/h2&gt;
&lt;h3&gt;概念&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;公用信号量：实现进程间的&lt;strong&gt;互斥&lt;/strong&gt;，&lt;strong&gt;初值为1&lt;/strong&gt;或资源的数目。&lt;/li&gt;
&lt;li&gt;私用信号量：实现进程间的&lt;strong&gt;同步&lt;/strong&gt;，&lt;strong&gt;初值为0&lt;/strong&gt;或某个正整数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;信号量S的物理意义&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;S≥0&lt;/strong&gt;表示某资源的&lt;strong&gt;可用数&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;S&amp;lt;0&lt;/strong&gt;，则其绝对值表示阻塞队列中&lt;strong&gt;等待该资源的进程数&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;PV操作&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;P操作和V操作是低级通信原语&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;P操作&lt;/strong&gt;表示&lt;strong&gt;申请&lt;/strong&gt;一个资源&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;V操作&lt;/strong&gt;表示&lt;strong&gt;释放&lt;/strong&gt;一个资源&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;P操作&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;S=S-1,若S≥0，则执行P操作的进程继续执行；&lt;/li&gt;
&lt;li&gt;若&lt;strong&gt;S&amp;lt;0&lt;/strong&gt;，则置该进程为阻塞状态（因为无可用资源），并&lt;strong&gt;将其插入阻塞队列&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;V操作&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;S=S+1，若S&amp;gt;0，则执行V操作的进程继续执行；&lt;/li&gt;
&lt;li&gt;若&lt;strong&gt;S≤0&lt;/strong&gt;，则从阻塞状态唤醒一个进程，并将&lt;strong&gt;其插入就绪队列&lt;/strong&gt;，然后执行V操作的进程继续。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;进程调度&lt;/h2&gt;
&lt;p&gt;（1）高级调度：又称“长调度”“作业调度”或“接纳调度”&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;它决定处于输入池中的&lt;strong&gt;哪个后备作业可以调入主系统做好运行的准备&lt;/strong&gt;，成为一个或一组就绪进程&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;（2）中级调度：又称“中程调度”或“对换调度”&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;它决定于交换区中的&lt;strong&gt;哪个就绪进程可以调入内存&lt;/strong&gt;，以便直接参与对CPU的竞争。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;（3）低级调度：又称“短程调度”或“进程调度”&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;它决定处于内存中的&lt;strong&gt;哪个就绪进程可以占用CPU&lt;/strong&gt;。低级调度是操作系统中最活跃、&lt;strong&gt;最重要的调度程序&lt;/strong&gt;，对系统的影响很大。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202504/images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2025-04-07-134238.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;进程调度算法&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;先来先服务&lt;/li&gt;
&lt;li&gt;时间片轮转&lt;/li&gt;
&lt;li&gt;优先级调度&lt;/li&gt;
&lt;li&gt;多级反馈调度：是时间片轮转算法和优先级算法的综合与发展&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;死锁&lt;/h2&gt;
&lt;h3&gt;基本概念&lt;/h3&gt;
&lt;p&gt;是指&lt;strong&gt;两个以上的进程&lt;/strong&gt;互相都&lt;strong&gt;要求对方已经占有的资源&lt;/strong&gt;导致无法继续运行下去的现象&lt;/p&gt;
&lt;p&gt;产生死锁的4个必要条件：&lt;strong&gt;互斥条件、请求保持条件、不可剥夺条件、环路条件。&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;死锁的处理策略有：鸵鸟策略、预防策略、避免策略和检测与解除死锁。&lt;/li&gt;
&lt;li&gt;死锁预防：采用某种策略限制并发进程对资源的请求。&lt;/li&gt;
&lt;li&gt;死锁避免：如银行家算法。&lt;/li&gt;
&lt;li&gt;死锁检测：系统定时地运行一个程序来检测是否发生死锁，若有，则设法加以解除。&lt;/li&gt;
&lt;li&gt;死锁解除：有资源剥夺法和撤销进程法。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;避免数量&lt;/h3&gt;
&lt;p&gt;至少需要资源：&lt;strong&gt;M =(k-1)×n+1&lt;/strong&gt;避免死锁&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;k：资源数量&lt;/li&gt;
&lt;li&gt;n：进程数量&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;线程&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;一个进程中有多个线程&lt;/strong&gt;，共享该进程的资源。&lt;/p&gt;
&lt;p&gt;在引入线程之前：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;进程&lt;/strong&gt;两个基本属性&lt;strong&gt;为可拥有资源的独立单位；可独立调度和分配的基本单位&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;引入线程后：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;线程作为调度和分配&lt;/strong&gt;的基本单位，&lt;strong&gt;进程作为独立分配资源&lt;/strong&gt;的单位。&lt;/li&gt;
&lt;/ul&gt;
</content:encoded></item><item><title>数据库系统工程师—3.7图的相关算法</title><link>https://minthana.github.io/blog/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%B7%A5%E7%A8%8B%E5%B8%88-3-7%E5%9B%BE%E7%9A%84%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/</link><guid isPermaLink="true">https://minthana.github.io/blog/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%B7%A5%E7%A8%8B%E5%B8%88-3-7%E5%9B%BE%E7%9A%84%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/</guid><pubDate>Mon, 07 Apr 2025 13:25:00 GMT</pubDate><content:encoded>&lt;h1&gt;图的相关算法&lt;/h1&gt;
&lt;h2&gt;生成树与最小生成树&lt;/h2&gt;
&lt;h3&gt;生成树&lt;/h3&gt;
&lt;p&gt;生成树：设图G=(V,E)是个&lt;strong&gt;连通图&lt;/strong&gt;，如果&lt;strong&gt;其子图&lt;/strong&gt;是一棵&lt;strong&gt;包含&lt;/strong&gt;G的&lt;strong&gt;所有顶点的树&lt;/strong&gt;，则该子图称为G的生成树。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202504/images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2025-04-07-131446.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;最小生成树&lt;/h3&gt;
&lt;p&gt;最小生成树：对于连通网来说，边是带权值的，生成树的各边也带权值，于是就把生成树各边的权值总和称为生成树的权，把&lt;strong&gt;权值最小的生成树称为最小生成树&lt;/strong&gt;。&lt;/p&gt;
&lt;h2&gt;普里姆算法&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;以顶点为主&lt;/li&gt;
&lt;li&gt;取任意一点，寻找与之距离最近（权值）的点和线，加入其中作为一个整体&lt;/li&gt;
&lt;li&gt;重复上述操作，直至最小生成树形成&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202504/images/pulimu.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;克鲁斯卡尔算法&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;以边为主&lt;/li&gt;
&lt;li&gt;取最小边，把边两侧顶点记录下来，循环以上操作直至形成&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202504/images/kelusikaer.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202504/images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2025-04-07-132346.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;图源：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/weixin_43972154/article/details/121593942&quot;&gt;[AcWing]859. Kruskal算法求最小生成树（C++实现）Kruskal算法模板题_kruskal模板题-CSDN博客&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/banke8061/article/details/101782181&quot;&gt;普里姆算法解析-CSDN博客&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</content:encoded></item><item><title>数据库系统工程师—3.6查找算法</title><link>https://minthana.github.io/blog/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%B7%A5%E7%A8%8B%E5%B8%88-3-6%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/</link><guid isPermaLink="true">https://minthana.github.io/blog/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%B7%A5%E7%A8%8B%E5%B8%88-3-6%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/</guid><pubDate>Wed, 02 Apr 2025 21:22:00 GMT</pubDate><content:encoded>&lt;h1&gt;查找算法&lt;/h1&gt;
&lt;h2&gt;顺序查找&lt;/h2&gt;
&lt;p&gt;从表中的一端开始，逐个进行记录的关键字和给定值的比较，若找到一个记录的关键字与给定值相等，则查找成功；若整个表中的记录均比较过，仍未找到关键字等于给定值的记录，则查找失败。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202504/images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2025-04-02-202950.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;折半查找（二分查找）&lt;/h2&gt;
&lt;p&gt;先令查找表中间位置记录的关键字和给定值比较，若相等，则查找成功；若不等，则缩小范围，直至新的查找区间中间位置记录的关键字等于给定值或者查找区间没有元素时（查找不成功）为止。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;这种方法要求查找表进行&lt;strong&gt;顺序存储&lt;/strong&gt;并且按关键字&lt;strong&gt;有序排列&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;查找效率比顺序查找要高，但要求关键字有序排列。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;适用于表不易变动&lt;/strong&gt;，且又经常进行查找的情况。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202504/images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2025-04-02-203012.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;折半查找判定树&lt;/h2&gt;
&lt;p&gt;从折半查找的过程来看，可以用一棵二叉树来描述。通常称这个描述折半查找二叉树的过程称为折半查找判定树。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202504/images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2025-04-02-205150.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;树表查找&lt;/h2&gt;
&lt;p&gt;二叉查找树是一种&lt;strong&gt;动态查找表&lt;/strong&gt;，表结构本身是&lt;strong&gt;在查找过程中动态生成的&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;其实就是二叉排序树/二叉查找树&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;左边节点小于父节点，左子树所有节点小于根节点&lt;/li&gt;
&lt;li&gt;右边节点大于父节点，右子树所有节点大于根节点&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202504/images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2025-04-02-210453.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;索引顺序查找(分块查找)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;是对顺序查找的一种改进&lt;/li&gt;
&lt;li&gt;将表分成若干块，每一块中的关键字不一定有序，但&lt;strong&gt;块之间是有序&lt;/strong&gt;的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202504/images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2025-04-02-210942.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;哈希查找&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;哈希函数：关键字作为自变量，关键字存放的地址作为因变量&lt;/li&gt;
&lt;li&gt;Hi=Hash(Key)&lt;/li&gt;
&lt;li&gt;哈希冲突：对于某个哈希函数Hash和两个关键字K1和K2，如果K1≠K2而Hash(K1)=Hash(K2)，则称出现了冲突。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;开放地址法&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202504/images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2025-04-02-211958.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;链地址法&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;它将具有&lt;strong&gt;相同哈希函数值的记录&lt;/strong&gt;组织&lt;strong&gt;成一个链表&lt;/strong&gt;，当链域的值为NULL时，表示已没有后继记录。&lt;/li&gt;
&lt;li&gt;地址里存放的是指针，而不是关键字，将哈希函数值相同的记录组成一个链表&lt;/li&gt;
&lt;/ul&gt;
</content:encoded></item><item><title>数据库系统工程师—3.5排序算法</title><link>https://minthana.github.io/blog/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%B7%A5%E7%A8%8B%E5%B8%88-3-5%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</link><guid isPermaLink="true">https://minthana.github.io/blog/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%B7%A5%E7%A8%8B%E5%B8%88-3-5%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</guid><pubDate>Tue, 01 Apr 2025 16:21:00 GMT</pubDate><content:encoded>&lt;h1&gt;排序算法&lt;/h1&gt;
&lt;h2&gt;直接插入算法&lt;/h2&gt;
&lt;p&gt;将待排元素依次加入队列中，并进行比较，插入应该的位置&lt;/p&gt;
&lt;p&gt;待排序列：35 12 67 29 51&lt;br /&gt;
第1步：35&lt;br /&gt;
第2步：12 35&lt;br /&gt;
第3步：12 35 67&lt;br /&gt;
第4步：12 29 35 67&lt;br /&gt;
第5步：12 29 35 51 67&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202504/images/zhijiecharusuanfa.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;冒泡排序&lt;/h2&gt;
&lt;p&gt;首先将第一个记录的关键字和第二个记录的关键字进行比较，若为逆序，则交换两个记录的值，然后比较第二个记录和第三个记录的关键字，依此类推。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202504/images/maoaopaixu.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;简单选择排序&lt;/h2&gt;
&lt;p&gt;通过n-i次关键字之间的比较，从n-i+1个记录中选出关键字最小的记录，并和第i（1≤i≤n）个记录进行交换，当i等于n时所有记录有序排列。&lt;/p&gt;
&lt;p&gt;待排序列：35 12 67 29 51&lt;br /&gt;
①：找出最小值12，与第一个关键字进行交换：                    12 35 67 29 51&lt;/p&gt;
&lt;p&gt;②：找出剩下4个记录中的最小值29，与第二个关键字交换：12 29 67 35 51&lt;/p&gt;
&lt;p&gt;③：找出剩下3个记录中的最小值35，与第三个关键字交换：12 29 35 67 51&lt;/p&gt;
&lt;p&gt;④：找出剩下2个记录中的最小值51，与第四个关键字交换：12 29 35 51 67&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202504/images/kuaisupaixu.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;希尔排序&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;希尔排序又称“&lt;strong&gt;缩小增量排序&lt;/strong&gt;”，是对直接插入排序方法的改进&lt;/li&gt;
&lt;li&gt;先将整个待排记录序列分割成若干子序列，然后分别进行直接插入排序，待整个序列中的记录基本有序时，再对全体记录进行一次直接插入排序。&lt;/li&gt;
&lt;li&gt;如，待排数量为n，第一次d=n/2,直至d=d/2=1为止，排序结束&lt;/li&gt;
&lt;li&gt;每间隔d，划分一组，进行位置上的直接插入&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202504/images/xierpaixu.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;快速排序&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;第一步：选取对比数据元素（第一个记录）&lt;/li&gt;
&lt;li&gt;第二步：设定下标i,j分别位于队列的最左最右两侧&lt;/li&gt;
&lt;li&gt;第三步：行动从j开始，如果数值小于对比元素，与i上的元素交换位置，如没有j向左移动直至达到条件&lt;/li&gt;
&lt;li&gt;第四步：行动交给i，如果该数值大于对比元素，与j上的元素交换位置，如没有i往右侧移动一位直至达到条件&lt;/li&gt;
&lt;li&gt;第五步：当i,j相遇，停止所有行动。此时左侧全部小于右侧（以对比元素为界限）&lt;/li&gt;
&lt;li&gt;前、后两部分可以再采用同样的方法进行排序。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202504/images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2025-04-01-180203.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;堆排序&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;大顶堆：每个结点的值都大于或等于其左右孩子结点的值&lt;/li&gt;
&lt;li&gt;小顶堆：每个结点的值都小于或等于其左右孩子结点的值&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对一组待排序记录的关键字，首先把它们按堆的定义排成一个序列（即建立初始堆），从而输出堆顶的最小关键字（对于小顶堆而言）。然后将剩余的关键字再调整成新堆，便得到次小的关键字，如此反复，直到全部关键字排成有序序列为止。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202504/images/tuipaixu.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;归并排序&lt;/h2&gt;
&lt;p&gt;把一个有n个记录的无序文件看成是由n个长度为1的有序子文件组成的文件，然后进行两两归并，得到ｎ/2个长度为2或1的有序文件，再两两归并，如此重复，直至最后形成包含ｎ个记录的有序文件为止。&lt;/p&gt;
&lt;p&gt;待排序列：39 19 32 25 46 58 47 55&lt;br /&gt;
[39 19][32 25][46 58][47 55]&lt;br /&gt;
[19 39][25 32][46 58][47 55]&lt;br /&gt;
[19 25 32 39] [46 47 55 58]&lt;br /&gt;
[19 25 32 39 46 47 55 58]&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202504/images/guibing.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;总结与比较&lt;/h2&gt;
&lt;p&gt;一句话总结&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1、直接插入排序：按顺序插入待排关键字，插入时依次查找位置，直接插入，后面的依次后移。&lt;/li&gt;
&lt;li&gt;2、冒泡排序：依次把相邻的两个记录进行比较，然后交换位置。&lt;/li&gt;
&lt;li&gt;3、简单选择排序：每次选择最小的，与第一个没有排过序的记录交换。&lt;/li&gt;
&lt;li&gt;4、希尔排序：间隔若干个空的记录分为一组，进行直接插入排序，依次将间隔缩小到1为止。&lt;/li&gt;
&lt;li&gt;5、快速排序：设两个指针指示头尾，从尾开始，首尾交替轮流和枢轴记录（第一个记录）进行比较，并交换位置。&lt;/li&gt;
&lt;li&gt;6、堆排序：反复将待排序列建立成堆，并取堆顶。&lt;/li&gt;
&lt;li&gt;7、归并排序：两两归并为一组，再四个记录归并为一组，依此类推。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202504/images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2025-04-01-182329.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;图源&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/kir_77/article/details/110260821&quot;&gt;冒泡排序（Bubble Sort）含gif动图_冒泡排序gif-CSDN博客&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/rej177/article/details/124421389&quot;&gt;数据结构七大排序算法图解——插入排序动图展示-CSDN博客&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.kuangstudy.com/m/bbs/1864735312417533954&quot;&gt;【基本排序算法】排序思路/GIF动图/C语言代码/算法改良-KuangStudy-文章&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/m0_58097299/article/details/128876350&quot;&gt;【排序】java代码实现，万字详解常见的八大排序，直接插入排序，希尔排序，选择排序，堆排序，冒泡排序，快速排序，归并排序，计数排序-CSDN博客&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/l199616j/p/10741093.html&quot;&gt;八大排序算法——堆排序（动图演示 思路分析 实例代码java 复杂度分析） - 测试开发喵 - 博客园&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/fivestudy/p/10075421.html&quot;&gt;分而治之，归并排序的动画演示 - 五分钟学算法 - 博客园&lt;/a&gt;&lt;/p&gt;
</content:encoded></item><item><title>数据库系统工程师—3.1~3.4线性结构、数组和矩阵、树和二叉树、图</title><link>https://minthana.github.io/blog/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%B7%A5%E7%A8%8B%E5%B8%88-3-13-4%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84%E6%95%B0%E7%BB%84%E5%92%8C%E7%9F%A9%E9%98%B5%E6%A0%91/</link><guid isPermaLink="true">https://minthana.github.io/blog/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%B7%A5%E7%A8%8B%E5%B8%88-3-13-4%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84%E6%95%B0%E7%BB%84%E5%92%8C%E7%9F%A9%E9%98%B5%E6%A0%91/</guid><pubDate>Mon, 31 Mar 2025 13:13:00 GMT</pubDate><content:encoded>&lt;h1&gt;线性结构&lt;/h1&gt;
&lt;h2&gt;线性表&lt;/h2&gt;
&lt;p&gt;n个元素的有限序列（n≥0）&lt;/p&gt;
&lt;h3&gt;顺序表&lt;/h3&gt;
&lt;p&gt;用一组&lt;strong&gt;地址连续&lt;/strong&gt;的存储单元依次存储线性表的数据元素，使得&lt;strong&gt;逻辑上相邻&lt;/strong&gt;的两个元素，&lt;strong&gt;物理上也相邻&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优点：可以&lt;strong&gt;随机存取&lt;/strong&gt;表中的元素，按序号&lt;strong&gt;查找&lt;/strong&gt;元素的&lt;strong&gt;速度很快&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;缺点：插入和删除操作&lt;strong&gt;需要移动元素&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;链表&lt;/h3&gt;
&lt;p&gt;节点只在需要时候申请，无需事先分配。节点地址可连续可不连续&lt;/p&gt;
&lt;p&gt;节点：数据域 | 指针域&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优点：插入和删除操作&lt;strong&gt;不需要移动元素&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;缺点：&lt;strong&gt;只能按顺序访问&lt;/strong&gt;元素，&lt;strong&gt;不能&lt;/strong&gt;进行&lt;strong&gt;随机存取&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;链表类别&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;单链表 （有头指针指向初始节点）&lt;/li&gt;
&lt;li&gt;循环链表&lt;/li&gt;
&lt;li&gt;双链表（有head指针指向初始节点）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;栈&lt;/h2&gt;
&lt;p&gt;特殊的线性表，规则是“后进后出“&lt;/p&gt;
&lt;h3&gt;顺序栈&lt;/h3&gt;
&lt;p&gt;用一组&lt;strong&gt;地址连续&lt;/strong&gt;的存储单元依次存储，&lt;strong&gt;自栈顶到栈底&lt;/strong&gt;的数据元素&lt;/p&gt;
&lt;p&gt;存储空间是&lt;strong&gt;预先定义或申请&lt;/strong&gt;的，因此&lt;strong&gt;可能会出现栈满的情况&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每一个元素入栈时都要判断栈是否已满。&lt;/li&gt;
&lt;li&gt;需要设置一个头指针指到栈顶。&lt;/li&gt;
&lt;li&gt;需要附设指针top指示栈顶元素的位置。（top = -1表示空栈）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202503/images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2025-03-31-124113.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;链栈&lt;/h3&gt;
&lt;p&gt;用链表存储栈中的元素&lt;/p&gt;
&lt;p&gt;栈中元素的&lt;strong&gt;插入和删除仅在栈顶进行&lt;/strong&gt;，因此&lt;strong&gt;不必设置头节点&lt;/strong&gt;，链表的头指针就是栈顶指针&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202503/images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2025-03-31-125118.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;队列&lt;/h2&gt;
&lt;p&gt;• 队列是一种“&lt;strong&gt;先进先出&lt;/strong&gt;”的线性表，&lt;strong&gt;队尾入 队头出&lt;/strong&gt;。&lt;/p&gt;
&lt;h3&gt;顺序队列&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202503/images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2025-03-31-125419.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;循环队列&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202503/images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2025-03-31-125507.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;链队列&lt;/h3&gt;
&lt;p&gt;给链队列添加一个头节点并令头指针指向头节点&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;队列为空&lt;/strong&gt;的判定条件就是&lt;strong&gt;头指针和尾指针的的值相同&lt;/strong&gt;，并且均&lt;strong&gt;指向头节点&lt;/strong&gt;。&lt;/p&gt;
&lt;h2&gt;&lt;img src=&quot;./guide/202503/images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2025-03-31-130632.png&quot; alt=&quot;&quot; /&gt;串&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;仅由字符&lt;/strong&gt;构成的&lt;strong&gt;有限序列&lt;/strong&gt;，&lt;strong&gt;取值范围受限&lt;/strong&gt;的线性表&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;串长：即串的长度，指字符串中的字符个数。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;空串：长度为0的空串，空串不包含任何字符。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;空格串：由一个或多个空格组成的串。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;子串：由串中任意长度的连续字符构成的序列称为子串。&lt;/li&gt;
&lt;li&gt;串相等：指两个串长度相等且对应位置上的字符也相同。&lt;/li&gt;
&lt;li&gt;串比较：两个串比较大小时以字符的ASCII码值作为依据。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;顺序串&lt;/h3&gt;
&lt;p&gt;用一组地址连续的存储单元来存储串值的字符序列&lt;/p&gt;
&lt;h3&gt;链式串&lt;/h3&gt;
&lt;p&gt;字符串可以采用链表作为存储结构，当用链表存储串中的字符时，&lt;strong&gt;每个结点&lt;/strong&gt;中可以&lt;strong&gt;存储一个字符或多个&lt;/strong&gt;字符。&lt;/p&gt;
&lt;h1&gt;数组和矩阵&lt;/h1&gt;
&lt;h2&gt;数组&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;一维数组是&lt;strong&gt;长度固定的线性表&lt;/strong&gt;，数组中的&lt;strong&gt;每个数据元素类型相同&lt;/strong&gt;。n维数组是定长线性表在维数上的扩张，即线性表中的元素又是一个线性表&lt;/li&gt;
&lt;li&gt;由于数组&lt;strong&gt;一般不做插入和删除&lt;/strong&gt;，且元素个数和元素之间的关系不再发生变动，那么数组&lt;strong&gt;适合采用顺序存储&lt;/strong&gt;结构&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;数组元素的存储方式及相关计算&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;二维数组&lt;/strong&gt;的存储结构可分为以行为主序（&lt;strong&gt;按行存储&lt;/strong&gt;）和以列为主序（&lt;strong&gt;按列存储&lt;/strong&gt;）两种方法。&lt;/p&gt;
&lt;p&gt;设每个数据元素占用L个单元，m、n为数组的行数和列数&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;按行存储地址计算&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;$$
Loc(a_{ij}) = Loc(a_{11})+((i-1)×n+(j-1))×L
$$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;按列存储地址计算&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;$$
Loc(a_{ij}) = Loc(a_{11})+((j-1)×m+(i-1))×L
$$&lt;/p&gt;
&lt;p&gt;$$
\begin{matrix}
a_{11}  a_{12}  a_{13} \
a_{21}  a_{22}  a_{23} \
a_{31}  a_{32}  a_{33} \
a_{41}  a_{42}  a_{43}
\end{matrix}
$$&lt;/p&gt;
&lt;h2&gt;矩阵&lt;/h2&gt;
&lt;h3&gt;对称矩阵&lt;/h3&gt;
&lt;p&gt;矩阵An*n的元素 aij = aji(1≤i,j≤n)的特点，则称之为对称矩阵&lt;/p&gt;
&lt;p&gt;$$
\begin{matrix}
1 ,3,5,7 \
3, 4, 9, 8\
5, 9, 7, 6\
7, 8, 6, 0
\end{matrix}
$$&lt;/p&gt;
&lt;p&gt;矩阵An*n的元素可以压缩存储在&lt;strong&gt;n(n+1)/2的&lt;/strong&gt;空间中，按行存储下三角&lt;/p&gt;
&lt;p&gt;$$
k = \left{\begin{matrix}
\frac{i(i+1)}{2}+j-1  当 i\ge j \
\frac{j(j+1)}{2}+i-1  当 i&amp;lt; j
\end{matrix}\right.
$$&lt;/p&gt;
&lt;h3&gt;三对角矩阵&lt;/h3&gt;
&lt;p&gt;对角矩阵是指矩阵中的非零元素都集中在以主对角线为中心的带状区域中，其余的矩阵元素都为零。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;即只有主对角线及其左右两边&lt;/strong&gt;为非零元素。&lt;/p&gt;
&lt;p&gt;$$
\begin{pmatrix}
a_{1,1} &amp;amp; a_{1,2} &amp;amp; &amp;amp; &amp;amp; &amp;amp; &amp;amp; &amp;amp; \
a_{2,1} &amp;amp; a_{2,2} &amp;amp; a_{2,3} &amp;amp; &amp;amp; &amp;amp; &amp;amp; &amp;amp; \
&amp;amp; a_{3,2} &amp;amp; a_{3,3} &amp;amp; a_{3,4} &amp;amp; &amp;amp; &amp;amp; &amp;amp; \
&amp;amp; &amp;amp; \cdots &amp;amp; \cdots &amp;amp; \cdots &amp;amp; &amp;amp; &amp;amp; \
&amp;amp; &amp;amp; &amp;amp; a_{1,i-1} &amp;amp; a_{1,i} &amp;amp; a_{1,i+1} &amp;amp; &amp;amp; \
&amp;amp; &amp;amp; &amp;amp; &amp;amp; \cdots &amp;amp; \cdots &amp;amp; \cdots &amp;amp; \cdots \
&amp;amp; &amp;amp; &amp;amp; &amp;amp; &amp;amp; &amp;amp; a_{n,n-1} &amp;amp; a_{n,n}
\end{pmatrix}
$$&lt;/p&gt;
&lt;p&gt;按行存储N阶三对角矩阵An*n的非零元素，在一维数组B[k]（0≤k&amp;lt;3n-2）中，&lt;/p&gt;
&lt;p&gt;$$
k = 3(i-1)-1 + j-i+1 = 2i+j-3   (1≤i,j≤n)
$$&lt;/p&gt;
&lt;h3&gt;稀疏矩阵&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;在一个矩阵中，&lt;strong&gt;若非零元素的个数远远少于零元素的个数&lt;/strong&gt;，且非零元素的&lt;strong&gt;分布没有规律&lt;/strong&gt;，称之为稀疏矩阵&lt;/li&gt;
&lt;li&gt;用一个三元组(i,j,aij）唯一确定矩阵中的一个元素&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;树和二叉树&lt;/h1&gt;
&lt;h2&gt;树&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;树是n(n≥0)个结点的&lt;strong&gt;有限集合&lt;/strong&gt;。当n=0时称为空树；&lt;/li&gt;
&lt;li&gt;在任一非空树中，&lt;strong&gt;有且仅有一个称为根的结点，&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;其余结点可分为m(m≥0)个互不相交的有限集T，&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;每个集合又都是一棵树&lt;/strong&gt;，并且称为根结点的子树。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;相关概念&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;结点的度：一个结点的&lt;strong&gt;子树的个数&lt;/strong&gt;记为该结点的&lt;strong&gt;度&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;叶子结点：也称为终端结点，指&lt;strong&gt;度为零的结点&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;结点的层次：根为第一层，根的孩子在第二层，依此类推。&lt;/li&gt;
&lt;li&gt;树的高度：一棵树的&lt;strong&gt;最大层次数&lt;/strong&gt;记为树的高度（或深度）。&lt;/li&gt;
&lt;li&gt;有序（无序）树：若将树中结点的各子树看成是从左到右具有次序的，即不能交换，则称该树为有序树，否则称为无序树。&lt;/li&gt;
&lt;li&gt;森林：m(m≥0)棵互不相交的树的集合。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;二叉树&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;由一个根结点及&lt;strong&gt;两棵不相交的&lt;/strong&gt;、分别称为&lt;strong&gt;左子树&lt;/strong&gt;和&lt;strong&gt;右子树&lt;/strong&gt;的二叉树所组成&lt;/li&gt;
&lt;li&gt;或者是空树(n=0)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;树和二叉树的区别：&lt;/p&gt;
&lt;p&gt;（1）二叉树中结点的子树要区分左子树和右子树，即使只有一棵子树，而树中不用区分。&lt;/p&gt;
&lt;p&gt;（2）二叉树中结点的最大度为2，而树中无限制。&lt;/p&gt;
&lt;h3&gt;二叉树的性质&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;第i层至多有2^(i-1)个节点&lt;/li&gt;
&lt;li&gt;深度为K的二叉树至多有（2^k）-1个节点&lt;/li&gt;
&lt;li&gt;对任何一棵二叉树，若其终端结点数为n0，度为2的结点数为n2，则n0=n2+1。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;满二叉树和完全二叉树&lt;/h2&gt;
&lt;p&gt;满二叉树：顾名思义&lt;/p&gt;
&lt;p&gt;完全二叉树：当深度为k、有n个结点的二叉树，当且仅当其每一个结点都与深度为k的满二叉树中编号为1～n的结点一一对应时，称之为完全二叉树。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202503/images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2025-03-31-144034.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;二叉树存储结构&lt;/h2&gt;
&lt;h3&gt;顺序存储&lt;/h3&gt;
&lt;p&gt;在顺序存储中，需要要为空值留下位置&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202503/images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2025-03-31-144259.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;链式存储&lt;/h3&gt;
&lt;p&gt;二叉节点：左指针域 | 节点内容 | 右指针域&lt;/p&gt;
&lt;p&gt;三叉节点：左指针域 | 节点内容 | 右指针域 | 父节点域&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202503/images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2025-03-31-144437.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;二叉树遍历法&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;中序遍历法：左、根、右&lt;/li&gt;
&lt;li&gt;前序遍历法：根、左、右&lt;/li&gt;
&lt;li&gt;后序遍历法：左、右、根&lt;/li&gt;
&lt;li&gt;层序遍历法：按行从左往右、按层从上往下&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;最优二叉树/哈夫曼树&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;是一类带权路径长度最短的树。&lt;/li&gt;
&lt;li&gt;权：是一个人为的概念，表示计算机对每个结点的访问频率。&lt;/li&gt;
&lt;li&gt;路径长度：是&lt;strong&gt;每一个结点到根结点的路径的长度&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;结点的带权路径长度&lt;/strong&gt;：是指从&lt;strong&gt;该结点到根结点之间的路径长度与该结点权的乘积&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;树的带权路径长度&lt;/strong&gt;为树中所有叶子结点的带权路径长度&lt;strong&gt;之和&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;生成的在最优二叉树&lt;strong&gt;并不唯一&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;应用：最优二叉树的一个应用是对字符集中的字符进行&lt;strong&gt;编码和译码。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如何生成最优二叉树&lt;/p&gt;
&lt;p&gt;例如：给定的n个权值{[4，5，8，9，11，13]，构成n棵二叉树的集合F&lt;/p&gt;
&lt;p&gt;通过取二个最小的数值，进行比较；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202503/images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2025-03-31-150212.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;二叉查找树/二叉排序树&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;二叉查找树又称为二叉排序树。&lt;/li&gt;
&lt;li&gt;它或者是一棵空树&lt;/li&gt;
&lt;li&gt;左边节点小于父节点，左子树所有节点小于根节点&lt;/li&gt;
&lt;li&gt;右边节点大于父节点，右子树所有节点大于根节点&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对二叉查找树进行&lt;strong&gt;中序遍历&lt;/strong&gt;，可得到一个&lt;strong&gt;关键码递增有序&lt;/strong&gt;的结点序列&lt;/p&gt;
&lt;p&gt;二叉查找树的作用：使用二叉查找树来&lt;strong&gt;查找树中的数值&lt;/strong&gt;比普通的二叉树更为&lt;strong&gt;方便&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202503/images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2025-03-31-150823.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h1&gt;图&lt;/h1&gt;
&lt;h2&gt;定义&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;图Graph记作G=(V，E)&lt;/li&gt;
&lt;li&gt;顶点集Vertex和边集Edge分别记为V（G）和E（G）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;有向图&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;图中每条边都是有方向的。有向边也称为弧。&lt;/li&gt;
&lt;li&gt;起点称为弧尾，终点称为弧头。&lt;/li&gt;
&lt;li&gt;顶点vj 到顶点vi 表示为&amp;lt;vj ,vi&amp;gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202503/images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2025-03-31-151502.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;无向图&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;图中每条边都是无方向的。&lt;/li&gt;
&lt;li&gt;顶点vj 到顶点vi与顶点vi到顶点vj边代表一个边&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202503/images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2025-03-31-151757.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;完全图&lt;/h3&gt;
&lt;p&gt;无向完全图&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个无向图具有n个顶点，而每一个顶点与其他n-1个顶点之间都有边&lt;/li&gt;
&lt;li&gt;共有n(n-1)/2条边&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有向完全图&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;n(n-1)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;（强）连通图、网&lt;/h3&gt;
&lt;p&gt;度顶点有几条边相连&lt;/p&gt;
&lt;p&gt;出度、入度：&lt;/p&gt;
&lt;p&gt;子图：子图G‘的V&apos;、E&apos;∈图G的V、E&lt;/p&gt;
&lt;p&gt;路径：顶点可到达另一个顶点&lt;/p&gt;
&lt;p&gt;连通图：各顶点通过路径（任意两个顶点）相连，对于无向图&lt;/p&gt;
&lt;p&gt;强连通图：各顶点通过路径（任意两个顶点）相连，对于有向图&lt;/p&gt;
&lt;p&gt;网：每一条边都有权值&lt;/p&gt;
&lt;h2&gt;图的存储结构&lt;/h2&gt;
&lt;h3&gt;邻接矩阵表示法&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;0：无边；1：有边&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202503/images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2025-03-31-153237.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;网（带有权值的图）的邻接矩阵的表示&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;有边：权值&lt;/li&gt;
&lt;li&gt;无边：∞&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202503/images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2025-03-31-153524.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;邻接链表表示法&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202503/images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2025-03-31-153721.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202503/images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2025-03-31-153806.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;带权值的网的邻接链表表示法&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202503/images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2025-03-31-153844.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</content:encoded></item><item><title>数据库系统工程师—2.程序语言基础知识</title><link>https://minthana.github.io/blog/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%B7%A5%E7%A8%8B%E5%B8%88-2-%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</link><guid isPermaLink="true">https://minthana.github.io/blog/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%B7%A5%E7%A8%8B%E5%B8%88-2-%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</guid><pubDate>Sun, 30 Mar 2025 14:13:00 GMT</pubDate><content:encoded>&lt;h1&gt;程序语言基础知识&lt;/h1&gt;
&lt;h2&gt;程序语言概述&lt;/h2&gt;
&lt;h3&gt;低级语言与高级语言&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;低级语言：&lt;strong&gt;面向机器的语言&lt;/strong&gt;，&lt;strong&gt;机器&lt;/strong&gt;语言、&lt;strong&gt;汇编&lt;/strong&gt;语言；&lt;strong&gt;可读性差&lt;/strong&gt;。程序设计效率低&lt;/li&gt;
&lt;li&gt;高级语言：面向各类应用的程序语言，与人类语言相近，便于理解，提高了程序设计的效率。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;汇编、解释、编译&lt;/h3&gt;
&lt;p&gt;高级程序语言必须进行&lt;strong&gt;翻译才能为计算机硬件所理解&lt;/strong&gt;，常用的翻译方式有汇编、解释和编译。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用汇编语言编写的：需要&lt;strong&gt;汇编程序翻译成目标程序&lt;/strong&gt;，然后执行目标程序。&lt;/li&gt;
&lt;li&gt;用高级语言编写的：需要&lt;strong&gt;解释程序或编译程序进行翻译&lt;/strong&gt;，然后再运行。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;编绎程序和解释程序&lt;/h3&gt;
&lt;p&gt;1. 编译程序（编译器）&lt;/p&gt;
&lt;p&gt;将源程序&lt;strong&gt;翻译成目标程序&lt;/strong&gt;（目标代码），然后再在计算机上运行目标程序。&lt;/p&gt;
&lt;p&gt;一般分为两个阶段：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;编译阶段：把源程序翻译成目标程序。&lt;/li&gt;
&lt;li&gt;运行阶段：执行目标程序&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2.解释程序（解释器）&lt;/p&gt;
&lt;p&gt;要么&lt;strong&gt;直接解释执行源程序&lt;/strong&gt;，要么将源程序翻译成某种中间代码后再加以执行。它&lt;strong&gt;按源程序中语句的执行顺序&lt;/strong&gt;，逐条翻译并立即执行相关功能。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;不生成目标代码&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;对比项&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;编译方式&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;解释方式&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;目标程序生成&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;生成独立的目标程序，源程序和编译程序&lt;strong&gt;不参与后续执行&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;不生成独立的目标程序，逐条解释并执行，源程序和解释程序&lt;strong&gt;参与运行&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;执行效率&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;更高&lt;/strong&gt;（编译时进行优化，直接执行机器码）&lt;/td&gt;
&lt;td&gt;较低（需逐行解释，运行时动态翻译）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;灵活性&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;较低（修改代码需重新编译）&lt;/td&gt;
&lt;td&gt;更高（支持动态修改，即时调试）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;可移植性&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;较差（依赖特定平台的目标代码）&lt;/td&gt;
&lt;td&gt;更好（通过虚拟机或解释器实现跨平台）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;控制权归属&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;目标程序直接由操作系统/硬件执行，控制权在用户程序&lt;/td&gt;
&lt;td&gt;解释器掌控运行流程，控制权在解释程序&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;典型语言&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;C、C++、Go（编译型）&lt;/td&gt;
&lt;td&gt;Python、JavaScript、Ruby（解释型）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;适用场景&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;对性能要求高的系统级开发、嵌入式等&lt;/td&gt;
&lt;td&gt;快速开发、脚本任务、跨平台应用&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;即&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;解释方式可移植性高、灵活；源程序和解释程序参与运行&lt;/li&gt;
&lt;li&gt;编译方式效率更高；源程序和编译程序不参与后续执行&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;程序语言的数据成分&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;常量和变量&lt;/li&gt;
&lt;li&gt;全局变量和局部变量&lt;/li&gt;
&lt;li&gt;数据类型
&lt;ul&gt;
&lt;li&gt;基本类型：整型、字符型、实型(科学计数法、浮点)和布尔类型&lt;/li&gt;
&lt;li&gt;特殊类型：空类型&lt;/li&gt;
&lt;li&gt;用户定义类型：枚举类型&lt;/li&gt;
&lt;li&gt;构造类型：数组、结构、联合&lt;/li&gt;
&lt;li&gt;指针类型：type *&lt;/li&gt;
&lt;li&gt;抽象数据类型：类类型（类似Java的类）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;程序语言的控制成分&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;顺序结构&lt;/li&gt;
&lt;li&gt;选择结构&lt;/li&gt;
&lt;li&gt;循环结构&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;编译过程&lt;/h2&gt;
&lt;p&gt;高级语言相关&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;词法分析：检查&lt;strong&gt;单词、符号&lt;/strong&gt;是否有问题。int main = 0 (变量名与关键词冲突)&lt;/li&gt;
&lt;li&gt;语法分析：检查短句或句子是否&lt;strong&gt;语法&lt;/strong&gt;正确。a = 1;b = 1;=a-b;(语法不存在或不合法)&lt;/li&gt;
&lt;li&gt;语义分析：检查每个短句&lt;strong&gt;内容合不合法&lt;/strong&gt;；例如 a = 1;b = &quot;2&quot;;c=a+b  (类型错误)&lt;/li&gt;
&lt;li&gt;中间代码生成：根据语义分析的输出，生成中间代码
&lt;ul&gt;
&lt;li&gt;常用的中间代码有：后缀式（逆波兰式）、&lt;strong&gt;四元式（三地址码）常用&lt;/strong&gt;、树形表示&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;低级语言相关&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;代码优化&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;由于编译器将源程序翻译成中间代码的工作是机械的、按固定模式进行的，因此，生成的中间代码往往在时间和空间方面的效率较差。当需要生成高效的目标代码时，就必须进行优化。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可以在中间代码生成阶段进行，也可以在目标代码生成阶段进行&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;目标代码生成&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;目标代码生成是编译器工作的最后一个阶段&lt;/li&gt;
&lt;li&gt;把中间代码&lt;strong&gt;变换成特定机器上的绝对指令代码、可重定位的指令代码和汇编指令代&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;符号表管理：记录源程序中各种符号的必要信息，以辅助语义的正确性检查和代码生成，在编译过程中需要对符号表进行快速有效地查找、插入、修改和删除等操作。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;出错处理&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;四元式&lt;/h2&gt;
&lt;p&gt;只做了解&lt;/p&gt;
&lt;p&gt;X：Y+Z*60&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;①（inttoreal,60,_,t1）# 将整数60转换为实型，结果存入临时变量t1&lt;/li&gt;
&lt;li&gt;②（*,id3,t1,t2） # 将变量id3与t1相乘，结果存入t2&lt;/li&gt;
&lt;li&gt;③（+,id2,t2,t3）# 将变量id2与t2相加，结果存入t3&lt;/li&gt;
&lt;li&gt;④（:=,t3,_,id1） # 将t3的值赋给变量id1&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;中缀、前缀、后缀表达式&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;中缀表达式：即我们通常所使用的表达式。如(a+b)*c-d&lt;/li&gt;
&lt;li&gt;前缀表达式（波兰式）：将运算符写在前面，操作数写在后面，且不使用括号。-*+abcd&lt;/li&gt;
&lt;li&gt;后缀表达式（逆波兰式）：将运算符写在后面，操作数写在前面，且不使用括号。ab+c*d-&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;传值调用和引用调用&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;传值调用：传值，单向&lt;/li&gt;
&lt;li&gt;引用调用：传地址，双向&lt;/li&gt;
&lt;/ul&gt;
</content:encoded></item><item><title>数据库系统工程师—1.3安全性、可靠性与系统性能评测基础知识</title><link>https://minthana.github.io/blog/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%B7%A5%E7%A8%8B%E5%B8%88-13%E5%AE%89%E5%85%A8%E6%80%A7%E5%8F%AF%E9%9D%A0%E6%80%A7%E4%B8%8E%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD%E8%AF%84%E6%B5%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</link><guid isPermaLink="true">https://minthana.github.io/blog/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%B7%A5%E7%A8%8B%E5%B8%88-13%E5%AE%89%E5%85%A8%E6%80%A7%E5%8F%AF%E9%9D%A0%E6%80%A7%E4%B8%8E%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD%E8%AF%84%E6%B5%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</guid><pubDate>Sun, 30 Mar 2025 13:25:00 GMT</pubDate><content:encoded>&lt;h1&gt;安全性、可靠性与系统性能评测基础知识&lt;/h1&gt;
&lt;h2&gt;对称加密技术&lt;/h2&gt;
&lt;p&gt;文件&lt;strong&gt;加密&lt;/strong&gt;和文件&lt;strong&gt;解密&lt;/strong&gt;使用&lt;strong&gt;相同密钥&lt;/strong&gt;，或者虽然不同，也可以从其中一个推导出另一个&lt;/p&gt;
&lt;p&gt;代表算法：DES、3DES、RC-5、IDEA、AES&lt;/p&gt;
&lt;h2&gt;非对称加密技术&lt;/h2&gt;
&lt;p&gt;一对加密、解密密钥，一个公开，一个私有&lt;/p&gt;
&lt;h3&gt;加密模型&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;发送者A&lt;/strong&gt; 通过&lt;strong&gt;B的公钥&lt;/strong&gt;加密明文&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;接收者B&lt;/strong&gt; 通过&lt;strong&gt;B的私钥&lt;/strong&gt;解密明文&lt;/p&gt;
&lt;h3&gt;认证模型&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;发送者A&lt;/strong&gt; 通过&lt;strong&gt;A的私钥&lt;/strong&gt;加密明文&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;接受者B&lt;/strong&gt; 通过&lt;strong&gt;A的公钥&lt;/strong&gt;解密明文&lt;/p&gt;
&lt;p&gt;非对称加密算法的保密性较好，它消除了最终用户频繁交换密钥的需要，但加密和解密花费时间长、速度慢，&lt;strong&gt;不适合于对文件加密&lt;/strong&gt;，而只&lt;strong&gt;适用于对少量数据加密&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;代表算法：RSA&lt;/p&gt;
&lt;h2&gt;信息摘要&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Hash函数：将一个长度&lt;strong&gt;不固定&lt;/strong&gt;的字符串，&lt;strong&gt;转化为一个固定的&lt;/strong&gt;字符串，称为哈希值&lt;/li&gt;
&lt;li&gt;单向Hash函数用于产生信息摘要。&lt;/li&gt;
&lt;li&gt;对于特定的文件而言，信息摘要是唯一的。&lt;/li&gt;
&lt;li&gt;Hash操作是不可逆的。&lt;/li&gt;
&lt;li&gt;MD2、MD4和MD5是被广泛使用的Hash函数，它们产生一种128位的信息摘要。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;数字签名&lt;/h2&gt;
&lt;p&gt;可以确认信息发送者的身份和信息是否被修改过。但不能保证发送信息的保密性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;发送者A&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过Hash函数&lt;strong&gt;生成信息摘要&lt;/strong&gt;Z&lt;/li&gt;
&lt;li&gt;用A的私钥&lt;strong&gt;加密信息摘要&lt;/strong&gt;Z为E&lt;/li&gt;
&lt;li&gt;发送信息和E&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;接收者B&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过相同的Hash函数生成信息摘要Z&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;用A的公钥解密 加密的信息摘要E&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;对比两个信息摘要&lt;/strong&gt;Z是否相同&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;数字加密（数字信封）&lt;/h2&gt;
&lt;p&gt;可以保证发送信息的保密性，但是不能确认发送者的身份。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;发送者A&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用&lt;strong&gt;对称密钥，加密信息&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;使用B的&lt;strong&gt;公钥加密对称密钥&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;发送加密信息和加密后的密钥&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;发送者B&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用B的&lt;strong&gt;私钥解密对称密钥&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;使用&lt;strong&gt;对称密钥解密信息&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;计算机可靠性&lt;/h2&gt;
&lt;p&gt;串联系统可靠性&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;R = R_{1}* R_{2}* R_{3}*...* R_{N}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;并联系统可靠性&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;R = 1-（1-R_{1}）* （1-R_{2}）*（1- R_{3}）*...*（1- R_{N}）
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>数据库系统工程师—1.2计算机体系结构与存储系统</title><link>https://minthana.github.io/blog/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%B7%A5%E7%A8%8B%E5%B8%88-12%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/</link><guid isPermaLink="true">https://minthana.github.io/blog/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%B7%A5%E7%A8%8B%E5%B8%88-12%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/</guid><pubDate>Sun, 30 Mar 2025 12:41:00 GMT</pubDate><content:encoded>&lt;h1&gt;计算机体系结构分类与存储系统&lt;/h1&gt;
&lt;h2&gt;计算机体系结构分类&lt;/h2&gt;
&lt;p&gt;（1）按处理机的数量进行分类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单处理系统&lt;/li&gt;
&lt;li&gt;并行处理与多处理系统&lt;/li&gt;
&lt;li&gt;分布式处理系统&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;（2）微观上按并行程度分类：Flynn分类法、冯泽云分类法、Handler分类法等等&lt;/p&gt;
&lt;h2&gt;CISC和RISC&lt;/h2&gt;
&lt;p&gt;RISC全称Reduced Instruction Set Compute，精简指令集计算机。&lt;br /&gt;
CISC全称Complex Instruction Set Computers，复杂指令集计算机。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;对比项&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;CISC（复杂指令集）&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;RISC（精简指令集）&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;指令集复杂度&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;指令集&lt;strong&gt;庞大且复杂&lt;/strong&gt;，&lt;strong&gt;单条指令可执行多个操作&lt;/strong&gt;（如内存访问、运算等）&lt;/td&gt;
&lt;td&gt;指令集&lt;strong&gt;精简且统一&lt;/strong&gt;，每条指令&lt;strong&gt;仅执行单一操作&lt;/strong&gt;，&lt;strong&gt;复杂功能&lt;/strong&gt;由简单指令&lt;strong&gt;组合实现&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;指令长度&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;变长指令，灵活但解码复杂&lt;/td&gt;
&lt;td&gt;固定长度指令，解码简单且易于流水线处理&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;执行时间&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;单条指令可能需要多个时钟周期完成&lt;/td&gt;
&lt;td&gt;大多数指令在一个时钟周期内完成，&lt;strong&gt;采用流水线技术&lt;/strong&gt;提升效率&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;硬件设计&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;硬件复杂度高，需支持多种指令操作，通常采用微程序控制&lt;/td&gt;
&lt;td&gt;硬件设计简单，多采用组合逻辑控制，易于集成流水线和超标量技术&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;寄存器数量&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;寄存器数量较少，频繁访问内存&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;通用寄存器数量多&lt;/strong&gt;，减少内存访问，操作主要在寄存器间完成&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;寻址方式&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;支持多种复杂寻址模式（如间接、基址、索引等）&lt;/td&gt;
&lt;td&gt;寻址方式简单，通常仅支持少数基本模式（如寄存器、立即数等）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;编译器优化&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;编译器优化难度大，但生成代码紧凑&lt;/td&gt;
&lt;td&gt;编译器优化容易，但代码量可能较大&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;应用场景&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;适用于通用计算（如桌面PC、服务器），强调向后兼容性&lt;/td&gt;
&lt;td&gt;适用于高效能低功耗场景（如移动设备、嵌入式系统）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;典型代表架构&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;x86（Intel/AMD）&lt;/td&gt;
&lt;td&gt;ARM、MIPS、RISC-V2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;功耗与能效&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;功耗较高，能效比相对较低&lt;/td&gt;
&lt;td&gt;功耗低，能效比高&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;中断响应&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;在指令执行结束后响应中断&lt;/td&gt;
&lt;td&gt;可在指令执行过程中适当时机响应中断&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;流水线技术&lt;/h2&gt;
&lt;p&gt;流水线周期：一个指令中，时间最费时（最慢）的子任务时间&lt;/p&gt;
&lt;p&gt;串行执行时间：N*一个指令总时长&lt;/p&gt;
&lt;p&gt;流水线执行时间：一条指令时长+（N-1）*流水线周期&lt;/p&gt;
&lt;p&gt;吞吐量：p=1/流水线周期&lt;/p&gt;
&lt;h2&gt;存储系统&lt;/h2&gt;
&lt;h3&gt;分类&lt;/h3&gt;
&lt;p&gt;1、存储器的分类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;按存储器所处的位置：可分为内存和外存。&lt;/li&gt;
&lt;li&gt;按构成存储器的材料：可分为磁存储器、半导体存储器和光存储器。&lt;/li&gt;
&lt;li&gt;按存储器的工作方式：可分为读写存储器和只读存储器。&lt;/li&gt;
&lt;li&gt;按访问方式：可分为按地址访问的存储器和按内容访问的存储器。&lt;/li&gt;
&lt;li&gt;按寻址方式：可分为随机存储器、顺序存储器和直接存储器。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2、随机访问存储器：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;静态随机访问存储器（SRAM）&lt;/li&gt;
&lt;li&gt;动态随机访问存储器（DRAM）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;3.高速缓存&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Cache是介于&lt;strong&gt;CPU与主存之间&lt;/strong&gt;的&lt;strong&gt;一级存储器&lt;/strong&gt;，其&lt;strong&gt;容量较小&lt;/strong&gt;，但&lt;strong&gt;速度较快&lt;/strong&gt;，一般比主存快5～10倍。&lt;/li&gt;
&lt;li&gt;它的主要作用是：&lt;strong&gt;调和&lt;/strong&gt;CPU的速度与内存存取&lt;strong&gt;速度之间的差&lt;/strong&gt;异，从而提升系统性能。&lt;/li&gt;
&lt;li&gt;它使用的是程序的&lt;strong&gt;局部性原理&lt;/strong&gt;，其内容是&lt;strong&gt;主存局部域的副本&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;当&lt;strong&gt;CPU需要读取数据&lt;/strong&gt;时，&lt;strong&gt;首先&lt;/strong&gt;判断要&lt;strong&gt;访问&lt;/strong&gt;的信息是否在&lt;strong&gt;Cache&lt;/strong&gt;中，如果在即为命中，如果&lt;strong&gt;不在&lt;/strong&gt;，就要&lt;strong&gt;按替换算法&lt;/strong&gt;把主存中的一块信息&lt;strong&gt;调入Cache中&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;替换算法有：随机替换算法、先进先出替换算法、近期最少使用替换算法、优化替换算法等。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CPU工作时给出的是主存的地址&lt;/strong&gt;，要从Cache存储器中读写信息，就需要将&lt;strong&gt;主存地址转换成Cache存储器的地址&lt;/strong&gt;，这种地址的转换叫作&lt;strong&gt;地址映像&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;4.虚拟存储器、相联存储器&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;虚拟存储器实际上是一种逻辑存储器。&lt;/li&gt;
&lt;li&gt;相联存储器是一种按内容访问的存储器。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;地址映射&lt;/h3&gt;
&lt;h4&gt;直接映射&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202503/images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2025-03-30-115549.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;主存的块与Cache块的对应&lt;strong&gt;关系是固定的&lt;/strong&gt;，主存中的块&lt;strong&gt;只能存放在&lt;/strong&gt;Cache存储器的&lt;strong&gt;相同块号中&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;优点：地址变换简单、访问速度快。&lt;/p&gt;
&lt;p&gt;缺点：&lt;strong&gt;块冲突率高&lt;/strong&gt;、Cache空间&lt;strong&gt;得不到充分利用&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;主存地址：主存区号 | 区内块号 | 块内地址&lt;/p&gt;
&lt;h4&gt;全相联映射&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202503/images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2025-03-30-115511.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;主存与Cache存储器&lt;strong&gt;均分成容量相同的块&lt;/strong&gt;。允许主存的&lt;strong&gt;任一块可以调入&lt;/strong&gt;Cache存储器的&lt;strong&gt;任何一个块的空间中&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;优点：&lt;strong&gt;灵活，块冲突率低&lt;/strong&gt;，只有在Cache中的块全部&lt;strong&gt;装满后才会出现冲突&lt;/strong&gt;，Cache&lt;strong&gt;利用率高&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;缺点：&lt;strong&gt;无法&lt;/strong&gt;从主存块号中&lt;strong&gt;直接获得所对应Cache的块号&lt;/strong&gt;，变换比较复杂，地址变换速度慢，成本高。&lt;/p&gt;
&lt;p&gt;主存地址：主存块号 | 块内地址&lt;/p&gt;
&lt;h4&gt;组相联映像&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202503/images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2025-03-30-115425.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;是前两种方式的折衷。&lt;/p&gt;
&lt;p&gt;将Cache中的块再分成组（&lt;strong&gt;分块、分组&lt;/strong&gt;）。&lt;strong&gt;组采用直接映像方式&lt;/strong&gt;而&lt;strong&gt;块采用全相联映像方式&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;主存的任何区的0组只能存Cache的0组中，1组只能存放到1组中，依此类推。而组内的块可以存入Cache中相同组的任一块中&lt;/p&gt;
&lt;p&gt;主存地址位数＝区号+组号+主存块号+块内地址&lt;/p&gt;
&lt;p&gt;Cache地址位数＝组号+组内块号+块内地址&lt;/p&gt;
&lt;h3&gt;性能分析&lt;/h3&gt;
&lt;p&gt;Cache的性能分析：&lt;/p&gt;
&lt;p&gt;设Hc为Cache的命中率，tc为Cache的存取时间，tm为主存的访问时间，则Cache存储器的等效加权平均访问时间ta为：&lt;/p&gt;
&lt;p&gt;$$
t_{a} =H_{c}t_{c}+(1-H_{c})t_{m}
$$&lt;/p&gt;
&lt;h4&gt;编址相关计算&lt;/h4&gt;
&lt;p&gt;内存单元按字节编址&lt;/p&gt;
&lt;p&gt;存储单元数量 = 末地址-首地址+1&lt;/p&gt;
</content:encoded></item><item><title>数据库系统工程师—1.1计算机硬件基础知识</title><link>https://minthana.github.io/blog/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%B7%A5%E7%A8%8B%E5%B8%88-11%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</link><guid isPermaLink="true">https://minthana.github.io/blog/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%B7%A5%E7%A8%8B%E5%B8%88-11%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</guid><pubDate>Sun, 30 Mar 2025 11:15:00 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;p&gt;文章内容仅为粗略总结知识，便于个人复习思考&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1&gt;计算机硬件基础知识&lt;/h1&gt;
&lt;p&gt;计算机硬件系统包括：**CPU、**&lt;strong&gt;存储器、输入输出设备&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;CPU组成&lt;/h2&gt;
&lt;h3&gt;运算器&lt;/h3&gt;
&lt;p&gt;运算器执行所有的算数运算（加减乘除、附加运算）、逻辑运算&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;算数逻辑单元（ALU）：负责处理数据，实现算数、逻辑运算&lt;/li&gt;
&lt;li&gt;累加寄存器（AC）:为ALU提供一个工作区&lt;/li&gt;
&lt;li&gt;数据缓存寄存器（DR）：CPU和内存、外设之间操作速度的缓存区、中转站&lt;/li&gt;
&lt;li&gt;状态条件寄存器（PSW）：保存根据算术指令和逻辑指令运行或测试的结果建立的各种条件码的内容，主要分为状态标志和控制标志。如运算结果进位标志(C)、运算结果溢出标志(V)、运算结果为0标志(Z)、运算结果为负标志(N)、中断标志(I)、方向标志(D)等。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;控制器&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;指令寄存器(IR)：用来暂时存放一条指令。&lt;/li&gt;
&lt;li&gt;程序计数器(PC)：存放的是将要执行的下一条指令的地址。&lt;/li&gt;
&lt;li&gt;地址寄存器(AR)：保存当前CPU所访问的内存单元的地址。&lt;/li&gt;
&lt;li&gt;指令译码器(ID)：对指令中的操作码字段进行分析解释，识别该指令规定的操作，然后向操作控制器发出具体的控制信号。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;指令&lt;/h3&gt;
&lt;p&gt;是机器进行程序控制的最小单元，包括&lt;strong&gt;操作码&lt;/strong&gt;和&lt;strong&gt;操作数本身或其地址&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;操作码由指令译码器识别&lt;/p&gt;
&lt;h3&gt;内部总线&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;数据总线(DB)：用来传送数据信息，是&lt;strong&gt;双向&lt;/strong&gt;的。DB的宽度决定了CPU和计算机其他设备之间每次交换数据的位数。&lt;/li&gt;
&lt;li&gt;地址总线(AB)：用于传送CPU发出的地址信息，是&lt;strong&gt;单向&lt;/strong&gt;的。地址总线的宽度决定了CPU的最大寻址能力。&lt;/li&gt;
&lt;li&gt;控制总线(CB)：用来传送控制信号、时序信号和状态信息等。CB中的每一条线的信息传送方向是单方向且确定的，但CB作为一个整体则是双向的。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;输入输出控制&lt;/h2&gt;
&lt;h3&gt;程序控制方式&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;无条件传送：&lt;strong&gt;外设总是准备好&lt;/strong&gt;的，&lt;strong&gt;无条件&lt;/strong&gt;，&lt;strong&gt;随时&lt;/strong&gt;接收和提供数据。&lt;/li&gt;
&lt;li&gt;程序查询方式：&lt;strong&gt;CPU利用程序来查询&lt;/strong&gt;外设的状态，准备好了再传数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;中断方式&lt;/h3&gt;
&lt;p&gt;CPU不等待，也不执行程序去查询外设的状态，而是由&lt;strong&gt;外设在准备好以后&lt;/strong&gt;，&lt;strong&gt;向CPU发出中断请求信号&lt;/strong&gt;通知CPU，CPU&lt;strong&gt;收到中断请求信号&lt;/strong&gt;以后，&lt;strong&gt;保存&lt;/strong&gt;正在执行程序的&lt;strong&gt;现场&lt;/strong&gt;，&lt;strong&gt;转入I/O中断服务程序&lt;/strong&gt;的执行，然后&lt;strong&gt;再返回&lt;/strong&gt;到被打断的程序&lt;strong&gt;继续执行&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;常用的处理方法有中断信号线法、中断软件查询法、菊花链法，总线仲裁法，中断向量表法。&lt;/p&gt;
&lt;p&gt;中断向量法：中断向量提供&lt;strong&gt;中断服务程序的入口地址&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;DMA直接内存存取&lt;/h3&gt;
&lt;p&gt;直接内存存取（DMA）方式：数据的传输是在&lt;strong&gt;主存和外设之间&lt;/strong&gt;直接进行，&lt;strong&gt;不需要CPU&lt;/strong&gt;的干预，只需要CPU在过程开始和结束时发出一些命令，实际操作是由DMA硬件直接执行完成的，CPU在传送的过程中可以处理别的任务。&lt;/p&gt;
&lt;h3&gt;通道方式和外围处理机方式&lt;/h3&gt;
&lt;p&gt;更进一步减轻了CPU对I/O操作的控制，更进一步提高了CPU的工作效率，但是是以增加更多硬件为代价的。&lt;/p&gt;
&lt;h2&gt;周期&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;指令周期：是指&lt;strong&gt;执行一条指令&lt;/strong&gt;所需要的时间。&lt;/li&gt;
&lt;li&gt;时钟周期：也称为振荡周期，是&lt;strong&gt;计算机中最基本的、最小的时间单位&lt;/strong&gt;。在一个时钟周期内，CPU仅仅完成一个最基本的动作。&lt;/li&gt;
&lt;li&gt;总线周期：通常把&lt;strong&gt;CPU通过总线&lt;/strong&gt;对存储器或I/0接口进行一次访问&lt;strong&gt;所需要的时间&lt;/strong&gt;称为一个总线周期。&lt;/li&gt;
&lt;li&gt;CPU周期：又称为机器周期。&lt;strong&gt;CPU&lt;/strong&gt;的操作速度快，但访问内存的速度却慢得多，我们把&lt;strong&gt;从内存读取一条指令的最短时间&lt;/strong&gt;，称之为机器周期。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;进制&lt;/h2&gt;
&lt;p&gt;二进制是Binary，简写为B。&lt;/p&gt;
&lt;p&gt;八进制是Octal，简写为O。&lt;/p&gt;
&lt;p&gt;十进制为Decimal，简写为D。&lt;/p&gt;
&lt;p&gt;十六进制为Hexadecimal，简写为H。&lt;/p&gt;
&lt;h2&gt;数的表示&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;原码&lt;/strong&gt;：最高为符号位，&lt;strong&gt;0为正，1为负&lt;/strong&gt;。其余n-1表示数的绝对值&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;反码&lt;/strong&gt;：&lt;strong&gt;正数&lt;/strong&gt;的反码和&lt;strong&gt;原码一样&lt;/strong&gt;，&lt;strong&gt;负数&lt;/strong&gt;的反码是其&lt;strong&gt;原码按位取反&lt;/strong&gt;。符号位不变&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;原码和反码的取值范围为：&lt;/p&gt;
&lt;p&gt;$$
-（2^{n-1} - 1）\rightleftharpoons （2^{n-1} - 1）
$$&lt;/p&gt;
&lt;p&gt;可以表示的数的量为&lt;/p&gt;
&lt;p&gt;$$
(2^{n-1} - 1)×2+1=2^n - 1
$$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;补码&lt;/strong&gt;：&lt;strong&gt;正数&lt;/strong&gt;的补码&lt;strong&gt;和原码一样&lt;/strong&gt;，&lt;strong&gt;负数&lt;/strong&gt;是其反码&lt;strong&gt;尾数+1&lt;/strong&gt;。符号位不变&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;移码&lt;/strong&gt;：&lt;strong&gt;补码的符号位取反&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;补码和移码的取值范围：因为负数的补码+1后比正数的补码多一位&lt;/p&gt;
&lt;p&gt;$$
-2^{n-1} \rightleftharpoons（2^{n-1} - 1）
$$&lt;/p&gt;
&lt;p&gt;可以表示的数的量为：
$$
-2^{n-1}  +（2^{n-1} - 1） +1=2^n
$$&lt;/p&gt;
&lt;h2&gt;校验码&lt;/h2&gt;
&lt;p&gt;海明校验码 ：n表示数据位，k表示校验位，需要满足以下最小关系
$$
2^{k}-1  \ge n+k
$$&lt;/p&gt;
</content:encoded></item><item><title>Spark</title><link>https://minthana.github.io/blog/posts/spark/</link><guid isPermaLink="true">https://minthana.github.io/blog/posts/spark/</guid><pubDate>Fri, 28 Feb 2025 13:53:00 GMT</pubDate><content:encoded>&lt;h1&gt;概述&lt;/h1&gt;
&lt;p&gt;Spark最初由美国加州伯克利大学(UCBerkeley)的AMP(Algorithms,Machinesand People)实验室于2009年开发，是基于内存计算的大数据并行计算框架，可用于构建大型的、低延迟的数据分析应用程序。Spark在诞生之初属于研究性项目，其诸多核心理念均源自学术研究论文。2013年，Spark加入Apache孵化器项目后，开始获得迅猛的发展，如今已成为Apache软件基金会最重要的三大分布式计算系统开源项目之一(即Hadoop、Spark、Storm)&lt;/p&gt;
&lt;h2&gt;特点&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;运行速度快&lt;/strong&gt;：Spark使用先进的DAG（Directed Acyclic Graph，有向无环图）执行引擎，以支持循环数据流与内存计算，基于内存的执行速度可比Hadoop MapReduce快上百倍，基于磁盘的执行速度也能快十倍;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;容易使用&lt;/strong&gt;：Spark支持使用Scala、Java、Python和R语言进行编程，简洁的API设计有助于用户轻松构建并行程序，并且可以通过SparkShell进行交互式编程&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;通用性&lt;/strong&gt;：Spark提供了完整而强大的技术栈，包括SQL查询、流式计算、机器学习和图算法组件，这些组件可以无缝整合在同一个应用中，足以应对复杂的计算;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;运行模式多样&lt;/strong&gt;：Spark可运行于独立的集群模式中，或者运行于Hadoop中，也可运行于Amazon EC2等云环境中，并且可以访问HDFS、Cassandra、HBase、Hive等多种数据源。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Spark与Hadoop的对比&lt;/h2&gt;
&lt;p&gt;Spark在借鉴Hadoop MapReduce优点的同时，很好地解决了MapReduce所面临的问题。相比于MapReduce，Spark主要具有如下优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Spark的计算模式也属于MapReduce，但不局限于Map和Reduce操作，还提供了多种数据集操作类型，编程模型比MapReduce更灵活;&lt;/li&gt;
&lt;li&gt;Spark提供了内存计算，中间结果直接放到内存中，带来了更高的迭代运算效率;&lt;/li&gt;
&lt;li&gt;Spark基于DAG的任务调度执行机制，要优于MapReduce的迭代执行机制&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;Spark最大的特点就是将计算数据、中间结果都存储在内存中，大大减少了IO开销，因而，Spark&lt;strong&gt;更适合于迭代运算比较多的数据挖掘与机器学习运算&lt;/strong&gt;。使用Hadoop进行迭代计算非常耗资源，因为每次迭代都需要从磁盘中写入、读取中间数据IO开销大。而Spark将数据载入内存后，之后的迭代计算都可以直接使用内存中的中间结果作运算，避免了从磁盘中频繁读取数据。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;Spark生态系统&lt;/h2&gt;
&lt;p&gt;Spark的生态系统主要包含了&lt;strong&gt;SparkCore、Spark SQL、Spark Streaming、MLLib和Graphx&lt;/strong&gt; 等组件&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Spark Core&lt;strong&gt;包含Spark的基本功能&lt;/strong&gt;，如内存计算、任务调度、部署模式、故障恢复、存储管理等。Spark建立在统一的抽象RDD之上，使其可以以基本一致的方式应对不同的大数据处理场景；通常所说的Apache Spark，就是指SparkCore&lt;/li&gt;
&lt;li&gt;Spark SQL允许开发人员直接处理RDD，同时也可查询Hive、HBase等外部数据源。Spark SQL的一个重要特点是其能够&lt;strong&gt;统一处理关系表和RDD&lt;/strong&gt;，使得开发人员可以轻松地&lt;strong&gt;使用SQL命令进行查询&lt;/strong&gt;，并&lt;strong&gt;进行更复杂的数据分析&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Spark Streaming支持&lt;strong&gt;高吞吐量&lt;/strong&gt;、&lt;strong&gt;可容错处理&lt;/strong&gt;的&lt;strong&gt;实时流数据处理&lt;/strong&gt;，其核心思路是将&lt;strong&gt;流式计算分解成一系列短小的批处理作业&lt;/strong&gt;。SparkStreaming支持多种数据输入源，如Kafka、Flume和TCP套接字等&lt;/li&gt;
&lt;li&gt;Mlib(机器学习) 提供了常用机器学习算法的实现，包括&lt;strong&gt;聚类、分类、回归、协同过滤&lt;/strong&gt;等，降低了机器学习的门槛，开发人员只要具备一定的理论知识就能进行机器学习的工作&lt;/li&gt;
&lt;li&gt;GraphX(图计算)是Spark中用于图计算的API，可认为是Pregel在Spark上的重写及优化，Graphx性能良好，拥有丰富的功能和运算符，能在海量数据上自如地运行复杂的图算法。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202502/images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2025-02-28-112103.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;基本概念&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;RDD：是弹性分布式数据集(Resilient Distributed Dataset)的简称，是分布式内存的一个抽象概念，提供了一种高度受限的共享内存模型&lt;/li&gt;
&lt;li&gt;DAG：是Directed Acyclic Graph(有向无环图)的简称，反映RDD之间的依赖关系&lt;/li&gt;
&lt;li&gt;Executor(执行者)：是运行在工作节点(Worker Node)上的一个进程，负责运行任务，并为应用程序存储数据&lt;/li&gt;
&lt;li&gt;应用：用户编写的Spark应用程序&lt;/li&gt;
&lt;li&gt;任务：运行在Executor上的工作单元&lt;/li&gt;
&lt;li&gt;作业：一个作业包含多个RDD及作用于相应RDD上的各种操作&lt;/li&gt;
&lt;li&gt;阶段：是作业的基本调度单位，一个作业会分为多组任务，每组任务被称为“阶段”，或者也被称为“任务集”&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Spark架构&lt;/h2&gt;
&lt;h3&gt;运行架构组成&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;集群资源管理器(Cluster Manager)&lt;/li&gt;
&lt;li&gt;运行作业任务的工作节点(Worker Node)&lt;/li&gt;
&lt;li&gt;每个应用的任务控制节点(Driver)&lt;/li&gt;
&lt;li&gt;每个工作节点上负责具体任务的执行进程(Executor)&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;集群资源管理器可以是Spark自带的资源管理器，也可以是YARN或Mesos等资源管理框架。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202502/images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2025-02-28-113038.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;Executor对比MapReduce&lt;/h3&gt;
&lt;p&gt;相较于Hadoop的MapReduce计算架构，Spark的Executor有两个优点&lt;/p&gt;
&lt;p&gt;优点一：利用&lt;strong&gt;多线程&lt;/strong&gt;来执行具体的任务(Hadoop MapReduce采用的是&lt;strong&gt;进程模型&lt;/strong&gt;)减少任务的启动开销&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;特征&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;Spark多线程模型&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;MapReduce多进程模型&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;任务执行单元&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;线程（Thread）&lt;/td&gt;
&lt;td&gt;进程（Process）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;资源管理&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;共享JVM进程资源（内存、连接池）&lt;/td&gt;
&lt;td&gt;每个任务独占独立JVM进程资源&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;启动开销&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;毫秒级（线程池复用）&lt;/td&gt;
&lt;td&gt;秒级（每次启动新进程）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;资源隔离性&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;弱（线程间可能资源争用）&lt;/td&gt;
&lt;td&gt;强（进程间资源隔离）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;适用场景&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;低延迟、内存密集型任务&lt;/td&gt;
&lt;td&gt;高资源隔离需求的批处理任务&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;进程模型（MapReduce）&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每个Map/Reduce Task启动独立JVM进程&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;开销来源&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;进程创建需要申请内存、加载JVM（约1秒）&lt;/li&gt;
&lt;li&gt;任务结束后进程销毁，资源无法复用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;示例：处理1000个任务需启动1000次JVM进程&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;线程模型（Spark）&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Executor进程内预分配线程池（如100线程）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;优化机制&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;线程复用：任务结束后线程返回池中待用&lt;/li&gt;
&lt;li&gt;共享内存：同一Executor内任务共享堆内存（如广播变量）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;示例：1000个任务在10个Executor（各100线程）中仅需10次JVM启动&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;优点二：Executor中有一个&lt;strong&gt;Block Manager存储模块&lt;/strong&gt;，会将&lt;strong&gt;内存和磁盘共同作为存储设备&lt;/strong&gt;，当需要&lt;strong&gt;多轮迭代计算&lt;/strong&gt;时，可以将&lt;strong&gt;中间结果存储到这个存储模块&lt;/strong&gt;里，下次需要时，就可以直接读该存储模块里的数据，而不需要读写到HDFS等文件系统里，因而有效&lt;strong&gt;减少了IO开销&lt;/strong&gt;；或者在交互式查询场景下，预先将表缓存到该存储系统上，从而可以&lt;strong&gt;提高读写IO性能&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;维度&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;Block Manager存储&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;HDFS存储&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;存储层级&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;内存优先，磁盘兜底（LRU淘汰策略）&lt;/td&gt;
&lt;td&gt;纯磁盘存储（3副本冗余）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;数据生命周期&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;任务/会话级（随Executor进程释放）&lt;/td&gt;
&lt;td&gt;持久化存储（需手动删除）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;访问速度&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;内存：纳秒级；本地磁盘：微秒级&lt;/td&gt;
&lt;td&gt;网络磁盘：毫秒级（跨节点传输）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;适用场景&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;迭代计算中间结果/热点数据缓存&lt;/td&gt;
&lt;td&gt;原始数据持久化/冷数据存储&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;应用组成&lt;/h3&gt;
&lt;p&gt;在Spark中&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个应用(Application)由一个任务控制节点(Driver)和若干个作业(Job)构成&lt;/li&gt;
&lt;li&gt;一个作业由多个阶段(Stage)构成，一个阶段由多个任务(Task)组成。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当&lt;strong&gt;执行一个应用&lt;/strong&gt;时，&lt;strong&gt;任务控制节点&lt;/strong&gt;会向集群管理器(Cluster Manager)&lt;strong&gt;申请资源，启动Executor&lt;/strong&gt;，并向Executor&lt;strong&gt;发送应用程序代码和文件&lt;/strong&gt;，然后在Executor上执行任务，运行结束后，&lt;strong&gt;执行结果会返回给任务控制节点&lt;/strong&gt;，或者&lt;strong&gt;写到HDFS或者其他数据库中&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202502/images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2025-02-28-115329.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;运行流程&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;当一个Spank&lt;strong&gt;应用被提交时&lt;/strong&gt;，首先需要为这个应用&lt;strong&gt;构建起基本的运行环境&lt;/strong&gt;，即由任务控制节点(Driver)&lt;strong&gt;创建一个SparkContext&lt;/strong&gt;，由&lt;strong&gt;SparkContext负责&lt;/strong&gt;和资源管理器(ClusterManager)的&lt;strong&gt;通信以及进行资源的申请、任务的分配和监控等&lt;/strong&gt;。SparkContext&lt;strong&gt;会向资源管理器注册并申请运行Executor的资源&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;资源管理器为Executor&lt;strong&gt;分配资源&lt;/strong&gt;，并启动Executor进程，Executor运行情况将**随着“心跳”**发送到资源管理器上；
&lt;ul&gt;
&lt;li&gt;存活确认：证明Executor进程正常运行（默认间隔3秒）&lt;/li&gt;
&lt;li&gt;资源状态上报：包含CPU/内存使用量、缓存数据量等指标&lt;/li&gt;
&lt;li&gt;任务状态同步：汇报正在执行的任务进度（如Task完成度百分比）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;SparkContext&lt;strong&gt;根据RDD的依赖关系构建DAG图&lt;/strong&gt;，DAG图&lt;strong&gt;提交给DAG调度器&lt;/strong&gt;(DAGScheduler)进行&lt;strong&gt;解析&lt;/strong&gt;，将&lt;strong&gt;DAG图分解成多个“阶段”&lt;/strong&gt;(每个阶段都是一个任务集)，并且&lt;strong&gt;计算出各个阶段之间的依赖关系&lt;/strong&gt;，然后把&lt;strong&gt;一个个“任务集”提交给底层的任务调度器&lt;/strong&gt;(TaskScheduler)进行&lt;strong&gt;处理&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;Executor向SparkContext&lt;strong&gt;申请任务&lt;/strong&gt;，&lt;strong&gt;任务调度器将任务分发给Executor运行&lt;/strong&gt;，同时，SparkContext将&lt;strong&gt;应用程序代码发放给Executor&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;任务在Executor上&lt;strong&gt;运行&lt;/strong&gt;，把执行结果&lt;strong&gt;反馈&lt;/strong&gt;给任务调度器，然后&lt;strong&gt;反馈&lt;/strong&gt;给DAG调度器，运行完毕后引入数据并释放所有资源。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202502/images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2025-02-28-121600.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;运行架构特点&lt;/h3&gt;
&lt;p&gt;(1)每个应用都有自己&lt;strong&gt;专属的Executor进程&lt;/strong&gt;，并且该进程在&lt;strong&gt;应用运行期间一直驻留&lt;/strong&gt;Executor进程以&lt;strong&gt;多线程&lt;/strong&gt;的方式运行任务，&lt;strong&gt;减少了多进程任务频繁的启动开销&lt;/strong&gt;，使得任务执行变得非常高效和可靠&lt;/p&gt;
&lt;p&gt;(2)Spark&lt;strong&gt;运行过程与资源管理器无关&lt;/strong&gt;，只要能够获取Executor进程并&lt;strong&gt;保持通信即可&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;(3)Executor上有一个BlockManager存储模块，类似于键值存储系统(把&lt;strong&gt;内存和磁盘共同作为存储设备&lt;/strong&gt;)，在处理迭代计算任务时，不需要把中间结果写入到HDFS等文件系统，而是直接放在这个存储系统上，后续有需要时就可以直接读取；在交互式查询场景下，也可以把表提前缓存到这个存储系统上，提高读写IO性能&lt;/p&gt;
&lt;p&gt;(4)任务采用了数据本地性和推测执行等优化机制。数据本地性是尽量将&lt;strong&gt;计算移到数据所在的节点上进行&lt;/strong&gt;，即“&lt;strong&gt;计算向数据靠拢”，&lt;strong&gt;因为&lt;/strong&gt;移动计算&lt;/strong&gt;比移动数据所占的网络资源要少得多。而且，Spark采用了延时调度机制，可以在更大的程度上实现执行过程优化。比如，拥有数据的节点当前正被其他的任务占用，那么，在这种情况下是否需要将数据移动到其他的空闲节点呢?答案是不一定。因为，如果经过预测发现当前节点&lt;strong&gt;结束当前任务的时间&lt;/strong&gt;要比&lt;strong&gt;移动数据的时间&lt;/strong&gt;还要&lt;strong&gt;少&lt;/strong&gt;，那么，&lt;strong&gt;调度就会等待&lt;/strong&gt;，直到当前节点可用。&lt;/p&gt;
&lt;h1&gt;RDD&lt;/h1&gt;
&lt;p&gt;RDD：弹性分布式数据集(Resilient Distributed Dataset)&lt;/p&gt;
&lt;p&gt;RDD提供一个&lt;strong&gt;抽象的数据架构&lt;/strong&gt;，我们不必担心底层数据的分布特性，只需要将具体的应用逻辑表达为一系列转换处理，不同RDD之间的转换操作形成依赖关系，可以实现管道化，从而避免中间结果的存储，大大降低数据复制、磁盘IO和序列化开销。&lt;/p&gt;
&lt;h2&gt;概念&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;一个RDD就是一个&lt;strong&gt;分布式对象集合&lt;/strong&gt;，本质上是一个&lt;strong&gt;只读的分区记录集合&lt;/strong&gt;，每个&lt;strong&gt;RDD可分成多个分区&lt;/strong&gt;，每个分区就是一个数据集片段，并且一个RDD的&lt;strong&gt;不同分区可以被保存到&lt;/strong&gt;集群中&lt;strong&gt;不同的节点&lt;/strong&gt;上，从而可以在集群中的&lt;strong&gt;不同节点上进行并行计算。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;RDD提供了一种&lt;strong&gt;高度受限的共享内存模型&lt;/strong&gt;，即RDD是&lt;strong&gt;只读&lt;/strong&gt;的记录分区的集合，&lt;strong&gt;不能直接修改&lt;/strong&gt;，只能基于稳定的&lt;strong&gt;物理存储中的数据集创建RDD&lt;/strong&gt;，或者通过在&lt;strong&gt;其他RDD上执行确定的转换&lt;/strong&gt;操作(如map、join和group by)而创建&lt;strong&gt;得到新的RDD。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;RDD&lt;strong&gt;提供&lt;/strong&gt;了一组丰富的操作以支持常见的&lt;strong&gt;数据运算&lt;/strong&gt;，分为“&lt;strong&gt;行动&lt;/strong&gt;”(Action)和“&lt;strong&gt;转换&lt;/strong&gt;”(Transformation)两种类型，&lt;strong&gt;前者&lt;/strong&gt;用于&lt;strong&gt;执行计算并指定输出&lt;/strong&gt;的形式，&lt;strong&gt;后者&lt;/strong&gt;指定&lt;strong&gt;RDD之间的相互依赖关系&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;行动与转换操作&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;转换操作&lt;/strong&gt;：接受RDD并返回RDD。例如map、filter、groupBy、join等&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;行动操作&lt;/strong&gt;：接受RDD返回非RDD（输出一个值或结果）。例如count、collect&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;RDD提供的转换接口都非常简单，都是类似map、filter、groupBy、join等&lt;strong&gt;粗粒度&lt;/strong&gt;的数据转换操作，而不是针对某个数据项的细粒度修改。因此，RDD比较适合对于数据集中元素&lt;strong&gt;执行相同操作的批处理式应用&lt;/strong&gt;，而&lt;strong&gt;不适合&lt;/strong&gt;用于需要&lt;strong&gt;异步&lt;/strong&gt;、&lt;strong&gt;细粒度状态的应用&lt;/strong&gt;，比如Web应用系统、增量式的网页爬虫等。&lt;/p&gt;
&lt;p&gt;RDD可以很好地&lt;strong&gt;应用于许多并行计算应用&lt;/strong&gt;中，可以具备很多现有计算框架(比如MapReduce、SQL、Pregel等)的表达能力，并且可以应用于这些框架处理不了的交互式数据挖掘应用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;执行过程&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;RDD&lt;strong&gt;读入&lt;/strong&gt;外部数据源（或者内存中的集合）进行&lt;strong&gt;创建&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;RDD经过一系列的“&lt;strong&gt;转换&lt;/strong&gt;”操作，每一次都会&lt;strong&gt;产生不同的RDD&lt;/strong&gt;，&lt;strong&gt;供给&lt;/strong&gt;下一个“转换”&lt;strong&gt;使用&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;最后一个RDD经“&lt;strong&gt;行动&lt;/strong&gt;”操作进行处理，并&lt;strong&gt;输出到外部数据源&lt;/strong&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这一系列处理称为一个Lineage(血缘关系)，即DAG&lt;strong&gt;拓扑排序的结果&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;优点:惰性调用、管道化、避免同步等待、不需要保存中间结果、每次操作变得简单&lt;/p&gt;
&lt;h2&gt;运行原理&lt;/h2&gt;
&lt;p&gt;RDD采用了&lt;strong&gt;惰性调用&lt;/strong&gt;，即在RDD的执行过程中，&lt;strong&gt;真正的计算发生在&lt;/strong&gt;RDD的“&lt;strong&gt;行动&lt;/strong&gt;”操作，对于“行动”之前的所有“&lt;strong&gt;转换&lt;/strong&gt;”操作，Spark&lt;strong&gt;只是记录&lt;/strong&gt;下“转换”操作应用的一些&lt;strong&gt;基础数据集&lt;/strong&gt;以及&lt;strong&gt;RDD生成的轨迹&lt;/strong&gt;，即相互之间的&lt;strong&gt;依赖关系&lt;/strong&gt;，而&lt;strong&gt;不会触发&lt;/strong&gt;真正的计算。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202502/images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2025-02-28-143528.png&quot; alt=&quot;&quot; /&gt;&lt;img src=&quot;./guide/202502/images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2025-02-28-143744.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;逻辑上生成RDD，只有在进行“行动”操作时候，Spark才会根据RDD的依赖关系生成DAG，并从起点开始真正的计算&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;采用惰性调用，&lt;strong&gt;通过血缘关系连接起来&lt;/strong&gt;的一系列&lt;strong&gt;RDD&lt;/strong&gt;操作就可以&lt;strong&gt;实现管道化&lt;/strong&gt;(pipeline)，避免了多次转换操作之间数据同步的等待，而且&lt;strong&gt;不用担心有过多的中间数据&lt;/strong&gt;，因为这些具有血缘关系的操作都管道化了，一个操作得到的结果不需要保存为中间数据，而是直接管道式地流入到下一个操作进行处理。同时，这种通过血缘关系把一系列操作进行管道化连接的设计方式，也使得管道中每次操作的计算变得相对简单，保证了每个操作在处理逻辑上的单一性；相反，在MapReduce的设计中，为了尽可能地减少MapReduce过程在单个MapReduce中会写入过多复杂的逻辑。&lt;/p&gt;
&lt;h2&gt;RDD之间的依赖关系&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;RDD中不同的操作会使得不同RDD中的分区会产生不同的依赖。&lt;/p&gt;
&lt;p&gt;RDD中的依赖关系分为窄依赖(NarrowDependency)与宽依赖(Wide Dependency)。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;窄依赖表现为一个父RDD的分区对应于一个子RDD的分区，或多个父RDD的分区对应于一个子RDD的分区&lt;/li&gt;
&lt;li&gt;宽依赖则表现为存在一个父RDD的一个分区对应一个子RDD的多个分区。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202502/images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2025-02-28-144751.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Spark的这种依赖关系设计，使其具有了天生的&lt;strong&gt;容错性&lt;/strong&gt;，大大&lt;strong&gt;加快了Spark的执行速度&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;因为，RDD数据集通过“&lt;strong&gt;血缘关系&lt;/strong&gt;”&lt;strong&gt;记住&lt;/strong&gt;了它是如何从其它RDD中&lt;strong&gt;演变&lt;/strong&gt;过来的；&lt;/li&gt;
&lt;li&gt;血缘关系记录的是粗颗粒度的转换操作行为，当这个RDD的部分分区&lt;strong&gt;数据丢失时&lt;/strong&gt;，它可以&lt;strong&gt;通过血缘关系&lt;/strong&gt;获取足够的信息来&lt;strong&gt;重新运算和恢复丢失的数据分区&lt;/strong&gt;，由此带来了性能的提升。&lt;/li&gt;
&lt;li&gt;相对而言，在两种依赖关系中，&lt;strong&gt;窄依赖的失败恢复更为高效&lt;/strong&gt;，它只需要&lt;strong&gt;根据父RDD分区重新计算丢失的分区即可&lt;/strong&gt;(不需要重新计算所有分区)，而且可以并行地在不同节点进行重新计算。而对于&lt;strong&gt;宽依赖&lt;/strong&gt;而言，单个节点失效通常意味着&lt;strong&gt;重新计算过程会涉及多个父RDD分区，开销较大&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;此外，Spark还提供了&lt;strong&gt;数据检查点和记录日志&lt;/strong&gt;，用于&lt;strong&gt;持久化中间RDD&lt;/strong&gt;，从而使得在进行失败恢复时&lt;strong&gt;不需要&lt;/strong&gt;追溯到最开始的阶段。在进行故障恢复时Spark会对数据检查点开销和重新计算RDD分区的开销进行比较，从而自动选择最优的恢复策略。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;RDD编程基础&lt;/h1&gt;
&lt;h2&gt;RDD创建&lt;/h2&gt;
&lt;p&gt;1.  通过**parallelize(并行化)**方法创建RDD，可以调用SparkContext的parallelize方法，在Driver中一个已经存在的数组上创建。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; words=(&quot;Hadoop is good&quot;, &quot;Spark is fast&quot;, &quot;Spark is better&quot;)
&amp;gt;&amp;gt;&amp;gt; rdd = sc.parallelize(words)
&amp;gt;&amp;gt;&amp;gt; rdd.foreach(print)
Spark is better 
Hadoop is good
Spark is fast
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2. RDD本地写入&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;rdd.saveAsTextFile(&quot;file:///root/writeback&quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202502/images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2025-02-28-151016.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;3. 本地加载数据创建RDD&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; lines = sc.textFile(&quot;file:///root/data.txt&quot;)
&amp;gt;&amp;gt;&amp;gt; lines.foreach(print)
Spark is better 
Hadoop is good
Spark is fast
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4. 从Hdfs加载数据创建RDD&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; lines = sc.textFile(&quot;/data.txt&quot;)
&amp;gt;&amp;gt;&amp;gt; lines.foreach(print)
Hadoop is good
Spark is fast
Spark is better
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;RDD转换&lt;/h2&gt;
&lt;p&gt;1.  filter(func)：筛选出满足函数func的元素，并返回一个新的数据集&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; lines = sc.textFile(&quot;/data.txt&quot;)
&amp;gt;&amp;gt;&amp;gt; lines.filter(lambda line:&quot;Spark&quot; in line).foreach(print).count()
Spark is fast (0 + 2) / 2]
Spark is better
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2. map(func)：将每个元素传递到函数func中，并将结果返回为一个新的数据集&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; lines.map(lambda line : line.split(&quot; &quot;)).foreach(print)[&apos;Hadoop&apos;, &apos;is&apos;, &apos;good&apos;][&apos;Spark&apos;, &apos;is&apos;, &apos;fast&apos;][&apos;Spark&apos;, &apos;is&apos;, &apos;better&apos;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3. flatMap(func)：与map()相似，但每个输入元素都可以映射到0或多个输出结果&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; lines.flatMap(lambda line : line.split(&quot; &quot;)).foreach(print)
Hadoop
is
good
Spark
is
fast
Spark
is
better
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;RDD行动&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;count() 返回数据集中的元素个数&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; lines.flatMap(lambda line : line.split(&quot; &quot;)).count()
9
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;collect() 以数组的形式返回数据集中的所有元素&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; lines.flatMap(lambda line : line.split(&quot; &quot;)).collect()
[&apos;Hadoop&apos;, &apos;is&apos;, &apos;good&apos;, &apos;Spark&apos;, &apos;is&apos;, &apos;fast&apos;, &apos;Spark&apos;, &apos;is&apos;, &apos;better&apos;]
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;first() 返回数据集中的第一个元素&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; lines.flatMap(lambda line : line.split(&quot; &quot;)).first()
&apos;Hadoop&apos;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;take(n) 以数组的形式返回数据集中的前n个元素&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; lines.flatMap(lambda line : line.split(&quot; &quot;)).take(5)
[&apos;Hadoop&apos;, &apos;is&apos;, &apos;good&apos;, &apos;Spark&apos;, &apos;is&apos;]
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;reduce(func) 通过函数func（输入两个参数并返回一个值）聚合数据集中的元素&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;lines.map(lambda line : len(line.split(&quot; &quot;))).foreach(print)
3
3
3
lines.map(lambda line : len(line.split(&quot; &quot;))).reduce(lambda a, b : a + b )
9
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;foreach(func) 将数据集中的每个元素传递到函数func中运行&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;持久化&lt;/h2&gt;
&lt;p&gt;在Spark中，RDD采用惰性求值的机制，每次遇到行动操作，都会从头开始执行计算。这对于迭代计算而言，代价是很大的，可以使用&lt;strong&gt;persist()方法对一个RDD标记为持久化&lt;/strong&gt;，持久化后的RDD将会被保留在计算节点的内存中被后面的行动操作&lt;strong&gt;重复使用&lt;/strong&gt;。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;persist(MEMORY_ONLY)表示将RDD作为反序列化的对象存储于JVM中，如果内存不足，就要按照LRU原则替换缓存中的内容。&lt;/li&gt;
&lt;li&gt;persist(MEMORY_AND_DISK)表示将RDD作为反序列化的对象存储在JVM中，如果内存不足，超出的分区将会被存放在硬盘上。&lt;/li&gt;
&lt;li&gt;一般而言，使用cache()方法时，会调用persist(MEMORY_ONLY)。&lt;/li&gt;
&lt;li&gt;使用unpersist()方法手动地把持久化的RDD从缓存中移除&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; list = [&quot;Hadoop&quot;,&quot;Spark&quot;,&quot;Hive&quot;]
&amp;gt;&amp;gt;&amp;gt; rdd = sc.parallelize(list)
&amp;gt;&amp;gt;&amp;gt; rdd.cache()ParallelCollectionRDD[0] at readRDDFromFile at PythonRDD.scala:289
&amp;gt;&amp;gt;&amp;gt; print(rdd.count())3 
&amp;gt;&amp;gt;&amp;gt; print(&apos;,&apos;.join(rdd.collect()))Hadoop,Spark,Hive
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;广播变量&lt;/h2&gt;
&lt;p&gt;广播变量是一种在Spark中用来共享变量的工具。它允许程序开发者在每个机器上缓存一个只读的变量，而不需要为每个任务都复制一份。这节省了内存和计算资源。广播变量的主要用途是在多个阶段的任务之间共享数据。&lt;/p&gt;
&lt;p&gt;广播变量的不可变性： &lt;strong&gt;一旦你创建了广播变量，它的值就不能再被修改&lt;/strong&gt;。这确保了在整个集群中，所有节点都获得相同的值。&lt;/p&gt;
&lt;p&gt;通过SparkContext.broadcast(v)来将一个普通变量v转化为广播变量。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;broadcastVar = sc.broadcast([1, 2, 3]) 
broadcastVar.value  
[1,2,3]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;累加器&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;什么是累加器？&lt;/strong&gt; 累加器就像一个特殊的计数器，可以在不同的计算节点上进行累加操作。它用于跟踪和记录计数或求和的结果。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如何创建累加器？&lt;/strong&gt; 你可以使用SparkContext.accumulator()来创建一个数值型累加器。这个累加器可以在集群中的任务中使用add方法来将数值累加到其中。但要注意，任务只能进行累加操作，不能直接读取累加器的值。只有任务控制节点（Driver Program）可以使用value方法来读取累加器的值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;为什么使用累加器？&lt;/strong&gt; 累加器非常有用，因为它们允许在分布式环境中有效地进行累加操作，而不需要担心数据同步和并发问题。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; accum = sc.accumulator(0)
&amp;gt;&amp;gt;&amp;gt; sc.parallelize([1, 2, 3, 4]).foreach(lambda x : accum.add(x))
&amp;gt;&amp;gt;&amp;gt; accum.value10
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;分区&lt;/h2&gt;
&lt;p&gt;RDD 分区的一个原则是使得分区的个数尽量等于集群中的 CPU 核心（Core）数目。对于不同的Spark 部署模式（Local 模式、Standalone 模式、YARN 模式、Mesos 模式）而言，都可以通过设置&lt;strong&gt;spark.default.parallelism&lt;/strong&gt; 这个参数的值，来配置默认的分区数目。一般而言，各种模式下的默认分区数目如下。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Local 模式：默认为本地机器的 CPU 数目，若设置了 local[N]，则默认为 N。&lt;/li&gt;
&lt;li&gt;Standalone 或 YARN 模式：在“集群中所有 CPU 核心数目总和”和“2”这二者中取较大值作为默认值。&lt;/li&gt;
&lt;li&gt;Mesos 模式：默认的分区数为 8。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;1. 手动设置分区&lt;/p&gt;
&lt;p&gt;创建 RDD 时手动指定分区个数,在调用 textFile()和 parallelize()方法的时候手动指定分区个数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; list = [1,2,3,4,5] 
&amp;gt;&amp;gt;&amp;gt; rdd = sc.parallelize(list,2) //设置两个分区
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;对于 parallelize()而言，如果没有在方法中指定分区数，则默认为spark.default.parallelism 。&lt;/p&gt;
&lt;p&gt;对于textFile()而言，如果没有在方法中指定分区数，则默认为 min(spark.default.parallelism,2)，如果是从 HDFS 中读取文件，则分区数为文件分片数（比如，128MB/片）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;2. 使用 repartition 方法重新设置分区个数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; data = sc.parallelize([1,2,3,4,5],2) 
&amp;gt;&amp;gt;&amp;gt; len(data.glom().collect()) #显示 data 这个 RDD 的分区数量
2
&amp;gt;&amp;gt;&amp;gt; rdd = data.repartition(1) #对 data 这个 RDD 进行重新分区
&amp;gt;&amp;gt;&amp;gt; len(rdd.glom().collect()) #显示 rdd 这个 RDD 的分区数量
1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3. 自定义分区&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 生成键值对数据
data = [(i, f&quot;value_{i}&quot;) for i in range(10)]

# 转换为键值对RDD
rdd = sc.parallelize(data)

# 使用partitionBy，这里选择10个分区，根据键将数据分到对应的分区
partitionedRDD = rdd.partitionBy(10)

# 查看每个分区的数据
result = partitionedRDD.glom().collect()
for i, partition in enumerate(result):
    print(f&quot;Partition {i}: {list(partition)}&quot;)

# 保存到文件系统
partitionedRDD.saveAsTextFile(&quot;file:///root/partitionBy&quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;键值对RDD&lt;/h1&gt;
&lt;h2&gt;键值对RDD的创建&lt;/h2&gt;
&lt;p&gt;我们可以采用多种方式创建键值对RDD，通过并行集合（列表）创建RDD&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;list = [&quot;Hadoop&quot;,&quot;Spark&quot;,&quot;Hive&quot;,&quot;Spark&quot;]
rdd = sc.parallelize(list)
rdd.saveAsTextFile(&quot;file:///root/kvRDD&quot;)
pairRDD = rdd.map(lambda word : (word,1))
pairRDD.foreach(print)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用map()函数来实现&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;lines = sc.textFile(&quot;file:///root/kvRDD&quot;)
pairRDD = lines.flatMap(lambda line : line.split(&quot; &quot;)).map(lambda word : (word,1))
pairRDD.foreach(print)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;常用的键值对转换操作&lt;/h2&gt;
&lt;p&gt;常用的键值对转换操作包括reduceByKey()、groupByKey()、sortByKey()、join()、cogroup()等。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;reduceByKey(func)&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;reduceByKey(func)的功能是，使用func函数合并具有相同键的值。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt;pairRDD.reduceByKey(lambda a,b : a+b).foreach(print)
(Spark,2)
(Hive,1)
(Hadoop,1)
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;groupByKey()&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;groupByKey()的功能是，对具有相同键的值进行分组。&lt;/p&gt;
&lt;p&gt;比如，对四个键值对(&quot;spark&quot;,1)、(&quot;spark&quot;,2)、(&quot;hadoop&quot;,3)和(&quot;hadoop&quot;,5)，采用groupByKey()后得到的结果是：(&quot;spark&quot;,(1,2))和(&quot;hadoop&quot;,(3,5))。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt;pairRDD.groupByKey().foreach(print)
(&apos;spark&apos;, &amp;lt;pyspark.resultiterable.ResultIterable object at 0x7f1869f81f60&amp;gt;)

(&apos;hadoop&apos;, &amp;lt;pyspark.resultiterable.ResultIterable object at 0x7f1869f81f60&amp;gt;)

(&apos;hive&apos;, &amp;lt;pyspark.resultiterable.ResultIterable object at 0x7f1869f81f60&amp;gt;)

#查看迭代器中内容
&amp;gt;&amp;gt;&amp;gt;pairRDD.groupByKey().map(lambda x : (x[0],tuple(x[1]))).foreach(print)

#实现reduceByKey的效果
&amp;gt;&amp;gt;&amp;gt;pairRDD.groupByKey().map(lambda x : (x[0],sum(x[1]))).foreach(print)
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;keys()&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;keys()只会把键值对RDD中的key返回形成一个新的RDD。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt;pairRDD.keys().foreach(print)

Hadoop
Spark
Hive
Spark
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;values()&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;values()只会把键值对RDD中的value返回形成一个新的RDD。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt;pairRDD.values().foreach(print)
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;sortByKey()&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;sortByKey()的功能是返回一个根据Key，也就是键进行排序的RDD。默认升序。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt;d1 = sc.parallelize([(&quot;c&quot;,8),(&quot;b&quot;,25),(&quot;c&quot;,17),(&quot;a&quot;,42),(&quot;b&quot;,4),(&quot;d&quot;,9),(&quot;e&quot;,17), (&quot;c&quot;,2),(&quot;f&quot;,29),(&quot;g&quot;,21),(&quot;b&quot;,9)])

&amp;gt;&amp;gt;&amp;gt;d1.reduceByKey(lambda a,b:a+b).sortByKey().collect()

&amp;gt;&amp;gt;&amp;gt;d1.reduceByKey(lambda a,b:a+b).sortByKey(False).collect()
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;sortBy()&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;sortBy()则可以根据其他字段进行排序。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt;d1.reduceByKey(lambda a,b:a+b).sortBy(lambda x:x[1],False).collect()
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;mapValues(func)&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们经常会遇到一种情形，我们只想对键值对RDD的value部分进行处理，而不是同时对key和value进行处理。对于这种情形，Spark提供了mapValues(func)，它的功能是，对键值对RDD中的每个value都应用一个函数，但是，key不会发生变化。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt;pairRDD.mapValues( lambda x : x+1).foreach(print)

(Hadoop,2)
(Spark,2)
(Hive,2)
(Spark,2)
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;join&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;join(连接)操作是键值对常用的操作。“连接”(join)这个概念来自于关系数据库领域，因此，join的类型也和关系数据库中的join一样，包括内连接(join)、左外连接(leftOuterJoin)、右外连接(rightOuterJoin)等。最常用的情形是内连接，所以，join就表示内连接。&lt;/p&gt;
&lt;p&gt;对于内连接，对于给定的两个输入数据集(K,V1)和(K,V2)，只有在两个数据集中都存在的key才会被输出，最终得到一个**(K,(V1,V2))**类型的数据集。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt;pairRDD1 = sc.parallelize([(&apos;Spark&apos;,&apos;fast&apos;)])

&amp;gt;&amp;gt;&amp;gt;pairRDD1.join(pairRDD).foreach(print)

(&apos;Spark&apos;, (&apos;fast&apos;, 1))
(&apos;Spark&apos;, (&apos;fast&apos;, 1))
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;combineByKey&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;combineByKey可以根据Key进行数据聚合，combineByKey相比于之前的方法，提供了更精细的流程安排，同时更加适合复杂逻辑与大规模数据的处理场景。假设有一些销售数据，数据采用键值对的形式，即&amp;lt;公司,当月收入&amp;gt;，要求使用 combineByKey 操作求出每个公司的总收入和每月平均收入，并保存在本地文件中。​&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt;data = sc.parallelize([(&quot;company-1&quot;,88),(&quot;company-1&quot;,96),(&quot;company-1&quot;,85),(&quot;company-2&quot;,94),(&quot;company-2&quot;,86),(&quot;company-2&quot;,74),(&quot;company-3&quot;,86),(&quot;company-3&quot;,88),(&quot;company-3&quot;,92)],3)

&amp;gt;&amp;gt;&amp;gt;combineValues = data.combineByKey(lambda income:(income,1),\
lambda acc,income:(acc[0]+income, acc[1]+1),\
lambda acc1,acc2:(acc1[0]+acc2[0],acc1[1]+acc2[1]))

&amp;gt;&amp;gt;&amp;gt;combineValues.foreach(print)
&amp;gt;&amp;gt;&amp;gt;res = combineValues.map(lambda x:(x[0],x[1][0],x[1][0]/float(x[1][1])))
&amp;gt;&amp;gt;&amp;gt;res.foreach(print)
&amp;gt;&amp;gt;&amp;gt;res.repartition(1).saveAsTextFile(&quot;file:///root/combineresult&quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;表1 combineByKey中的三个重要参数详解&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;参数名称&lt;/th&gt;
&lt;th&gt;参数值&lt;/th&gt;
&lt;th&gt;参数含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;createCombiner&lt;/td&gt;
&lt;td&gt;lambda income:(income,1)&lt;/td&gt;
&lt;td&gt;在第一次遇到 key 时创建组合器函数，将 RDD 键值对中的values转换成 Combiner类型值。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;mergeValue&lt;/td&gt;
&lt;td&gt;lambda acc,income:(acc[0]+income, acc[1]+1)&lt;/td&gt;
&lt;td&gt;合并值函数，遇到相同的 key 时，将新的values添加到之前存储的Combiner类型值。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;mergeCombiners&lt;/td&gt;
&lt;td&gt;lambda x:(x[0],x[1][0],x[1][0]/float(x[1][1]))&lt;/td&gt;
&lt;td&gt;合并组合器函数，将保存的内容合并为一个值。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1&gt;SparkSQL基础&lt;/h1&gt;
&lt;p&gt;SparkSession 支持从不同的数据源加载数据，以及把数据转换成 DataFrame，并且支持把DataFrame 转换成 SQLContext 自身的表，然后使用 SQL 语句来操作数据。SparkSession 亦提供了HiveQL 以及其他依赖于 Hive 的功能的支持&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from pyspark.sql import SparkSession

# 创建一个Spark会话
spark = SparkSession.builder.appName(&quot;example&quot;).getOrCreate()
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;DataFrame 的读写&lt;/h2&gt;
&lt;p&gt;在创建 DataFrame 时，可以使用 &lt;strong&gt;spark.read&lt;/strong&gt; 操作，实现从不同类型的文件中加载数据创建DataFrame：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;读取文本文件 people.txt：spark.read.text(&quot;people.txt&quot;)&lt;/li&gt;
&lt;li&gt;读取JSON文件people.json：spark.read.json(&quot;people.json&quot;)&lt;/li&gt;
&lt;li&gt;读取csv文件people.csv：spark.read.csv (&quot;people.csv&quot;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以使用 &lt;strong&gt;spark.write&lt;/strong&gt; 操作，把一个 DataFrame 保存成不同格式的文件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;保存文本文件 people.txt：spark.write.text(&quot;people.txt&quot;)&lt;/li&gt;
&lt;li&gt;保存JSON文件people.json：spark.write.json(&quot;people.json&quot;)&lt;/li&gt;
&lt;li&gt;保存csv文件people.csv：spark.write.csv (&quot;people.csv&quot;)&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;# 读取
df=spark.read.csv(&quot;file:////opt/software/spark/examples/src/main/resources/people.csv&quot;, header=True, inferSchema=True, sep=&quot;;&quot;)
df.show()
+-----+---+---------+
| name|age|      job|
+-----+---+---------+
|Jorge| 30|Developer|
|  Bob| 32|Developer|
+-----+---+---------+

#写入
df.select(&apos;name&apos;,&apos;age&apos;).write.csv(&quot;file:////opt/software/jupyter_notebook/people&quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;DataFrame的常用操作&lt;/h2&gt;
&lt;h3&gt;printSchema()&lt;/h3&gt;
&lt;p&gt;可以使用 printSchema()操作打印出 DataFrame 的模式（Schema）信息。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;df.printSchema()
root
 |-- name: string (nullable = true)
 |-- age: integer (nullable = true)
 |-- job: string (nullable = true)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;&lt;strong&gt;select()&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;从 DataFrame 中选取部分列的数据。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;df.select(df[&apos;name&apos;],df[&apos;age&apos;]+1).show()
+-----+---------+
| name|(age + 1)|
+-----+---------+
|Jorge|       31|
|  Bob|       33|
+-----+---------+
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;&lt;strong&gt;filter()&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;找到满足条件要求的记录。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;df.filter(df[&apos;age&apos;]&amp;gt;30).show()
+----+---+---------+
|name|age|      job|
+----+---+---------+
| Bob| 32|Developer|
+----+---+---------+
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;&lt;strong&gt;groupBy()&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;对数据分组。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;df.groupBy(&apos;job&apos;).count().show()
+---------+-----+
|      job|count|
+---------+-----+
|Developer|    2|
+---------+-----+
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;sort()&lt;/h3&gt;
&lt;p&gt;进行排序。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;df.sort(df[&apos;age&apos;].asc(),df[&apos;name&apos;].desc()).show()
+-----+---+---------+
| name|age|      job|
+-----+---+---------+
|Jorge| 30|Developer|
|  Bob| 32|Developer|
+-----+---+---------+
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>Linux分布式集群模板机配置</title><link>https://minthana.github.io/blog/posts/linux%E5%88%86%E5%B8%83%E5%BC%8F%E9%9B%86%E7%BE%A4%E6%A8%A1%E6%9D%BF%E6%9C%BA%E9%85%8D%E7%BD%AE/</link><guid isPermaLink="true">https://minthana.github.io/blog/posts/linux%E5%88%86%E5%B8%83%E5%BC%8F%E9%9B%86%E7%BE%A4%E6%A8%A1%E6%9D%BF%E6%9C%BA%E9%85%8D%E7%BD%AE/</guid><pubDate>Tue, 25 Feb 2025 20:03:00 GMT</pubDate><content:encoded>&lt;h1&gt;CentOS的安装&lt;/h1&gt;
&lt;h2&gt;安装&lt;/h2&gt;
&lt;h3&gt;入口&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202502/images/1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;选择镜像文件&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202502/images/2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;设置账号&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202502/images/4.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;选择系统安装位置&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202502/images/4-1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;配置资源&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202502/images/5.png&quot; alt=&quot;&quot; /&gt; &lt;img src=&quot;./guide/202502/images/6.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;启动虚拟机，安装系统&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202502/images/7.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;验证&lt;/h2&gt;
&lt;h3&gt;启动，并输入用户名密码&lt;/h3&gt;
&lt;p&gt;超级用户：root 密码：000000&lt;/p&gt;
&lt;p&gt;安装时创建的用户：bigdata 密码：000000&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202502/images/image-20230215162444798.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;选择登录root 用户&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202502/images/image-20230215162538778.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;验证网络是否通&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#访问网络
[root@localhost ~]# ping www.baidu.com
ping: www.baidu.com: Name or service not known
#访问windows宿主机
[root@localhost ~]# ping 192.168.18.1
connect: Network is unreachable
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;网络配置&lt;/h1&gt;
&lt;h2&gt;网络规划&lt;/h2&gt;
&lt;h3&gt;网络配置说明&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202502/images/8.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;需要配置 VM、Centos的网络配置，包括IP地址，主机名，网络映射，Windows本地的网络配置&lt;/p&gt;
&lt;h3&gt;模板机的意义&lt;/h3&gt;
&lt;p&gt;把操作系统的基础配置，包括内存、硬盘等网络等配置好之后，后续如果需要增加虚拟机的话，直接克隆，可以节省大量时间。 毕竟安装一台虚拟机所需时间不短。&lt;/p&gt;
&lt;p&gt;在配置好网络后，还需要把一些通用的配置在模板机上配置好，比如jdk、python环境等&lt;/p&gt;
&lt;h3&gt;网络规划&lt;/h3&gt;
&lt;p&gt;ip网段划分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;前缀：192.168.18.X&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;192.168.18.1：windows本机IP&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;192.168.18.2：网关&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;template 192.168.18.8：模板机器，配置基础环境【网络、jdk,且去掉打印机、Usb,音频】&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;bigdatam10 192.168.18.10 用来做master服务器，部署HDFS的namenode 组件，同时作为YARN的DataManager从机&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;bigdatas20 192.168.18.20 用来做Slaver服务器，资源管理器，部署YARN的ResourcesManager组件，同时作为HDFS的DataNode从机&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;bigdatas30 192.168.18.30 用来做Slaver服务器，部署HDFS的SecondaryNameNode，同时作为HDFS的DataNode从机和作为YARN的DataManager从机&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;配置VM网络设置&lt;/h2&gt;
&lt;h3&gt;配置入口&lt;/h3&gt;
&lt;p&gt;VM工具栏--》编辑--》虚拟网络编辑器&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202502/images/9.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;VM分配给宿主机IP&lt;/h3&gt;
&lt;p&gt;位置3：没有特别要求，只要网段一致就好了，我们这里使用18，以前这里我们使用的是1 ，但是有时候我们家庭网络网段也是用1,容易产生网络冲突，所以这里只要避开1就行，换个不同的数字&lt;/p&gt;
&lt;h3&gt;网关设置&lt;/h3&gt;
&lt;p&gt;点击位置4，弹出网关设定窗口，网关一般设置为2&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202502/images/10.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;网段和IP分配方式&lt;/h3&gt;
&lt;p&gt;点击位置6，弹出窗口，在位置7更改启示IP地址和结束IP地址，这里选择3~254，避开网关&lt;/p&gt;
&lt;p&gt;将位置8的多选框取消掉，取消系统自动分配IP地址，原因是当我们重启服务器的时候，centos的IP地址会变，导致我们需要重新查询IP，在具体地业务系统中，我们需要使用自己的IP规则，同时，&lt;strong&gt;需要使用远程连接工具和FTP工具，不宜经常变动。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202502/images/11.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h1&gt;&lt;strong&gt;配置Windows的虚拟网络IP地址&lt;/strong&gt;&lt;/h1&gt;
&lt;h3&gt;&lt;strong&gt;入口&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;选中电脑网络图标，右键--&amp;gt;打开网络和共享中心&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202502/images/12.png&quot; alt=&quot;&quot; /&gt;&lt;img src=&quot;./guide/202502/images/13.png&quot; alt=&quot;&quot; /&gt;&lt;img src=&quot;./guide/202502/images/14.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;如果没有出现VMnet8,进入VM的虚拟网络编辑器中，还原默认设置即可。&lt;strong&gt;【如果有VMnet8,不需要操作下图】&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202502/images/15.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;设置网关和宿主机IP&lt;/h3&gt;
&lt;p&gt;子网IP：在IP的规则范围内，什么数字都可以，但一般家庭网段中的IP地址 可能是 1，因此倒数第二个数字，只要避开1就可以，这里使用的是18&lt;/p&gt;
&lt;p&gt;这个网关一般是2&lt;/p&gt;
&lt;p&gt;选中VMnet8,右键--&amp;gt;属性--&amp;gt;双击IPv4&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202502/images/16.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202502/images/17.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;参数说明：&lt;/p&gt;
&lt;p&gt;默认网关：和VM配置的网关保持一致&lt;/p&gt;
&lt;p&gt;首选DNS服务器：与网关保持一致&lt;/p&gt;
&lt;p&gt;备用DNS服务器：设置成公网的域名解析器&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1&gt;&lt;strong&gt;CentOS网络设置&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;说明：&lt;strong&gt;当做配置的时候，一般使用root账号登录&lt;/strong&gt;，这样可以避免过多的系统账号切换&lt;/p&gt;
&lt;p&gt;当真正搭建集群的时候，才使用bigdata等具体业务账号&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;配置虚拟机IP地址&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;使用root账号登录，密码000000，进入命令终端，使用如下命令查看IP地址配置&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; vim /etc/sysconfig/network-scripts/ifcfg-ens33 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202502/images/18.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202502/images/19.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;完整内容：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;TYPE=&quot;Ethernet&quot;
PROXY_METHOD=&quot;none&quot;
BROWSER_ONLY=&quot;no&quot;
BOOTPROTO=&quot;static&quot;
DEFROUTE=&quot;yes&quot;
IPV4_FAILURE_FATAL=&quot;no&quot;
IPV6INIT=&quot;yes&quot;
IPV6_AUTOCONF=&quot;yes&quot;
IPV6_DEFROUTE=&quot;yes&quot;
IPV6_FAILURE_FATAL=&quot;no&quot;
IPV6_ADDR_GEN_MODE=&quot;stable-privacy&quot;
NAME=&quot;ens33&quot;
UUID=&quot;03067470-f66c-44f1-bfcc-e1225df9a0d8&quot;
DEVICE=&quot;ens33&quot;
ONBOOT=&quot;yes&quot;
IPADDR=&quot;192.168.18.8&quot;
GATEWAY=&quot;192.168.18.2&quot;
DNS1=&quot;192.168.18.2&quot;
DNS2=&quot;8.8.8.8&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;更改完成之后，正常来说需要重启下网卡，那么我们在这里先修改一下主机名称&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;修改虚拟机主机名称&lt;/strong&gt;&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt; vim /etc/hostname
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;默认名称如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202502/images/20.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;更改为：template&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;配置主机名称映射&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;说明：当我们在后续的各种软件的配置文件中配置IP地址，当后续IP地址发生变化，要去更改配置文件非常麻烦，所以使用一个名称映射到IP地址，即便后续IP地址发生变化，也只需要更改centos的Ip地址即可，而软件的配置文件中使用的是映射的名称，因此可以不需要更改。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; vim /etc/hosts
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202502/images/clipboard.png&quot; alt=&quot;&quot; /&gt;在下面添加如下内容：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;192.168.18.8 template
192.168.18.10 bigdatas10
192.168.18.20 bigdatas20
192.168.18.30 bigdatas30
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;esc--&amp;gt;:wq! 保存后 ，reboot重启&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：名称不能有下划线，否则报如下错误：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Does not contain a valid host:port authority&lt;/p&gt;
&lt;p&gt;主机的&lt;strong&gt;hostname不合法&lt;/strong&gt;，应修改为不包含着‘.’ ‘/’ &apos;_&apos;等非法字符。&lt;/p&gt;
&lt;p&gt;大家在命名主机的时候切记，避开上述非法字符&lt;/p&gt;
&lt;h1&gt;&lt;strong&gt;Windows网络映射文件配置&lt;/strong&gt;&lt;/h1&gt;
&lt;h3&gt;位置&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;C:\Windows\System32\drivers\etc
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202502/images/21.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;将以下代码粘贴到文件末尾&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;192.168.18.8 template
192.168.18.10 bigdatam10
192.168.18.20 bigdatas20
192.168.18.30 bigdatas30
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;【这里和centos中的hosts一致即可】&lt;/p&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在修改hosts文件之前，退出电脑的杀毒软件，否则修改完毕之后，杀毒软件又给改回来了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;win10 电脑有自我保护机制，直接修改大概率不成功，先把hosts文件复制到桌面，更改完后，再拷贝到etc目录，覆盖原有的即可。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;&lt;strong&gt;修改网络配置后，重启网络&lt;/strong&gt;&lt;/h1&gt;
&lt;h3&gt;直接reboot重启centos&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt; reboot
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;重启网络服务&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;systemctl start network.service 或者 service network restart
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;验证网络&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;#访问外网
[root@template ~]# ping www.baidu.com
PING www.a.shifen.com (182.61.200.7) 56(84) bytes of data.
64 bytes from 182.61.200.7 (182.61.200.7): icmp_seq=1 ttl=128 time=65.5 ms
64 bytes from 182.61.200.7 (182.61.200.7): icmp_seq=2 ttl=128 time=63.7 ms
64 bytes from 182.61.200.7 (182.61.200.7): icmp_seq=3 ttl=128 time=61.4 ms

#访问windows宿主机
[root@template ~]# ping 192.168.18.1
PING 192.168.18.1 (192.168.18.1) 56(84) bytes of data.
64 bytes from 192.168.18.1: icmp_seq=1 ttl=64 time=1.05 ms
64 bytes from 192.168.18.1: icmp_seq=2 ttl=64 time=0.515 ms
64 bytes from 192.168.18.1: icmp_seq=3 ttl=64 time=0.594 ms

#访问网关
[root@template ~]# ping 192.168.18.2
PING 192.168.18.2 (192.168.18.2) 56(84) bytes of data.
64 bytes from 192.168.18.2: icmp_seq=1 ttl=128 time=0.562 ms
64 bytes from 192.168.18.2: icmp_seq=2 ttl=128 time=0.280 ms
64 bytes from 192.168.18.2: icmp_seq=3 ttl=128 time=0.381 ms
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;windows 访问centos&lt;img src=&quot;./guide/202502/images/22.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h1&gt;常用远程工具【windows】&lt;/h1&gt;
&lt;h2&gt;&lt;strong&gt;背景&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;现在我们把hadoop_tmp_08已经安装好了，在真正的生产环境下，我们会使用集群，有多台服务器，&lt;/p&gt;
&lt;p&gt;我们都知道，服务器是需要放在机房的，而我们办公则在办公室，我们需要通过远程连接的方式来操作每一台服务器，而远程连接，则需要安装一个远程连接工具&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202502/images/23.png&quot; alt=&quot;&quot; /&gt;通过远程工具，我们坐在办公室就可以操作机房的服务器，我们通常使用的远程工具Xshell,当然远程工具还有很多，&lt;strong&gt;安装自行安装&lt;/strong&gt;&lt;br /&gt;
&lt;img src=&quot;./guide/202502/images/24.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;使用XShell远程连接服务器&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;新建连接&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202502/images/25.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;根据自身使用习惯更改配色&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202502/images/26.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;接受秘钥&lt;/strong&gt;&lt;br /&gt;
&lt;img src=&quot;./guide/202502/images/27.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;FTP工具，Xftp7安装和配置&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;安装&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202502/images/28.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在Xshell7上，点击箭头的位置&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202502/images/29.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202502/images/30.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h1&gt;常用内部工具配置【centos内】&lt;/h1&gt;
&lt;h2&gt;&lt;strong&gt;epel-release&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;注：Extra Packages for Enterprise Linux是为“红帽系”的操作系统提供额外的软件包，适用于RHEL、CentOS和Scientific Linux。相当于是一个软件仓库，大多数rpm包在官方 repository 中是找不到的），这个相当于一个补丁&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; [root@template ~]# yum install -y epel-release
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;如果已经有进行在占用，则可以用kill命令关闭该进行,后面的3030是进程的ID号&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202502/images/31.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; kill -9 3030 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;再次执行&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202502/images/image-20230215175108658.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意事项：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果Linux安装的是最小系统版，还需要安装如下工具；如果安装的是Linux桌面标准版，不需要执行如下操作&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;net-tool：工具包集合，包含ifconfig等命令&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt; [root@template ~]# yum install -y net-tools
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;vim：编辑器&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt; [root@template ~]# yum install -y vim
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;关闭防火墙，关闭防火墙开机自启&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@template ~]# systemctl status firewalld 查看防火墙状态
[root@template ~]# systemctl stop firewalld 关闭当前的防火前 
[root@template ~]# systemctl disable firewalld.service 禁止防火墙开机启动
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意：在企业开发时，通常单个服务器的防火墙时关闭的。公司整体对外会设置非常安全的防火墙&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;重启虚拟机&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; [root@template ~]# reboot
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;用户权限配置&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;配置用户和权限&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;创建bigdata用户，并修改bigdata用户的密码&lt;/strong&gt;&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;[root@template ~]# useradd bigdata
[root@template ~]# passwd bigdata
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;如果在安装centos时配置了账号，则不需要添加用户的这一步&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;配置bigdata用户具有root权限&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;方便后期加sudo执行root权限的命令,&lt;strong&gt;而不是使用su切换到root不需要密码&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; [root@template ~]# vim /etc/sudoers
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;修改文件权限&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;chmod 777 /etc/sudoers
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;修改/etc/sudoers文件，在%wheel这行下面添加一行，如下所示：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;## Allow root to run any commands anywhere
root ALL=(ALL) ALL

## Allows people in group wheel to run all commands
%wheel ALL=(ALL) ALL
bigdata ALL=(ALL) NOPASSWD:ALL
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;修改文件权限&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; pkexec chmod 0440 /etc/sudoers
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;每次切换到最高账号时，不需要输入密码&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;注意：bigdata这一行不要直接放到root行下面，因为所有用户都属于wheel组，你先配置了bigdata具有免密功能，但是程序执行到%wheel行时，该功能又被覆盖回需要密码。所以bigdata要放到%wheel这行下面。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;在/opt目录下创建文件夹，并修改所属主和所属组&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;在/opt目录下创建module、software文件夹&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@template ~]# mkdir /opt/module 
[root@template ~]# mkdir /opt/software
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;修改module、software文件夹的所有者和所属组均为bigdata用户&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@template ~]# chown bigdata:bigdata /opt/module
[root@template ~]# chown bigdata:bigdata /opt/software
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查看module、software文件夹的所有者和所属组&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@template ~]# cd /opt/ 
[root@template opt]# ll
总用量 12
drwxr-xr-x. 2 bigdata bigdata 4096 5月 28 17:18 module
drwxr-xr-x. 2 root root 4096 9月 7 2017 rh
drwxr-xr-x. 2 bigdata bigdata 4096 5月 28 17:18 software
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>基于HIVE的疫情防控数据分析与可视化</title><link>https://minthana.github.io/blog/posts/%E5%9F%BA%E4%BA%8Ehive%E7%9A%84%E7%96%AB%E6%83%85%E9%98%B2%E6%8E%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E5%8F%AF%E8%A7%86%E5%8C%96/</link><guid isPermaLink="true">https://minthana.github.io/blog/posts/%E5%9F%BA%E4%BA%8Ehive%E7%9A%84%E7%96%AB%E6%83%85%E9%98%B2%E6%8E%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E5%8F%AF%E8%A7%86%E5%8C%96/</guid><pubDate>Tue, 18 Feb 2025 16:46:00 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;p&gt;使用的平台与技术：Hadoop-2.6.5、Jdk-1.8、Sqoop-1.4.7、Hive-1.2.1、MySql-5.6.24、&lt;/p&gt;
&lt;p&gt;Idea2020、Maven-3.6.3&lt;/p&gt;
&lt;p&gt;Pycharm2024、Django-3.0.3、Python-3.7.16、PyMysql-1.0.2&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;数据链接：&lt;a href=&quot;http://www.datazzh.top/wp-content/uploads/2025/02/covid_19_clean_complete.csv&quot;&gt;covid_19_clean_complete&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;项目仓库：&lt;a href=&quot;https://gitee.com/rongwu651/xg_hive&quot;&gt;https://gitee.com/rongwu651/xg_hive&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;博客梳理&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;技术选型&lt;/strong&gt;：使用 Hadoop、Jdk、Sqoop、Hive、MySql、Idea、Maven、Pycharm、Django、Python、PyMysql 等技术搭建项目。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数据处理流程&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;创建 Hive 数据表&lt;/strong&gt;：启动集群和 Hive 客户端后，创建存储疫情数据的表结构。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数据上传至集群&lt;/strong&gt;：通过&lt;code&gt;hdfs dfs -put&lt;/code&gt;命令将本地数据上传到 HDFS。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;构建 Maven 项目&lt;/strong&gt;：在 Idea 中创建 Maven 项目，添加 Hadoop 依赖，编写 Mapper、Reducer 和 Main 文件进行数据处理和计算。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;生成 Jar 包并执行任务&lt;/strong&gt;：打包 Maven 项目生成 Jar 包，在集群上执行任务，处理后的数据可查看并导入 Hive 表。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数据导入 MySql 表&lt;/strong&gt;：利用 Sqoop 将数据导入 MySql 表（通过Django模型创建的表）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Django 项目搭建与配置&lt;/strong&gt;：创建 Django 项目和应用，定义数据模型，生成并应用数据库迁移文件。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;前后端数据交互与可视化&lt;/strong&gt;：编写 view.py 和 urls.py 进行请求响应和映射，通过 html 文件和 jinja2 语法实现前后端数据交互，使用 echarts 进行数据可视化展示多种疫情数据图表。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1&gt;创建Hive数据表&lt;/h1&gt;
&lt;p&gt;1. 启动集群和Hive客户端&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@hadoop100] start-dfs.sh[root@hadoop100] start-yarn.sh[root@hadoop100] hive
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2. 创建表结构，行格式，分割字段以Tab为结尾&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;hive &amp;gt; create table xg(date_day string,siwanglv double,kangfulv double,huoyuebingli int,quezhen int,siwang int,huifu int,shenfeng string)row format delimited fields terminated by &apos;\t&apos;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202502/images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2025-02-18-141116.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h1&gt;数据上传至集群&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;[root@hadoop100] hdfs dfs -put /local_path /hdfs_path
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202502/images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2025-02-18-141212.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h1&gt;构建Maven项目&lt;/h1&gt;
&lt;p&gt;1.  打开Idea-创建项目-Maven项目-选择maven-archetype-quickstart&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202502/images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2025-02-18-140713.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;2. pom.xml文件中添加Hadoop对应版本的依赖并刷新加载&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;dependency&amp;gt;    &amp;lt;groupId&amp;gt;org.apache.hadoop&amp;lt;/groupId&amp;gt;    &amp;lt;artifactId&amp;gt;hadoop-common&amp;lt;/artifactId&amp;gt;    &amp;lt;version&amp;gt;2.6.5&amp;lt;/version&amp;gt;&amp;lt;/dependency&amp;gt;&amp;lt;dependency&amp;gt;    &amp;lt;groupId&amp;gt;org.apache.hadoop&amp;lt;/groupId&amp;gt;    &amp;lt;artifactId&amp;gt;hadoop-hdfs&amp;lt;/artifactId&amp;gt;    &amp;lt;version&amp;gt;2.6.5&amp;lt;/version&amp;gt;&amp;lt;/dependency&amp;gt;&amp;lt;dependency&amp;gt;    &amp;lt;groupId&amp;gt;org.apache.hadoop&amp;lt;/groupId&amp;gt;    &amp;lt;artifactId&amp;gt;hadoop-client&amp;lt;/artifactId&amp;gt;    &amp;lt;version&amp;gt;2.2.0&amp;lt;/version&amp;gt;&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3. 创建Mapper文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class XinguanMapper extends Mapper&amp;lt;LongWritable, Text,Text, NumberInfo&amp;gt;{ //读取写出类型
    protected void map(LongWritable key,Text value,Context context) throws IOException, InterruptedException {
        //按行读取数据，并进行分割存储
        String line = value.toString();
        Iterable split = Arrays.asList(line.split(&quot;,&quot;));
        ArrayList datas = new ArrayList&amp;lt;&amp;gt;(10);

        //存储
        for (String s : split){
            datas.add(s);
        }
        if(datas.size()&amp;gt;9){ //防止字符越界
            //过滤，选取所需要的数据
            if (&quot;China&quot;.equals(datas.get(1))||&quot;Taiwan*&quot;.equals(datas.get(1))){
                String Province = &quot;China&quot;.equals(datas.get(1))?datas.get(0) : &quot;Taiwan&quot;;

                String date = datas.get(4);//日期
                Long Confirmed =Long.parseLong(datas.get(5)) ; //已确诊，累计
                Long Deaths = Long.parseLong(datas.get(6)); //死亡，累计
                Long Health = Long.parseLong(datas.get(7)); //恢复，累计
                //写入
                context.write(new Text(date),new NumberInfo(Confirmed,Deaths,Health,Province));
            }
        }

    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.1 创建对象，便于存储Mapper阶段筛选后的多值，至上下文&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;实现Writable接口，使该类的对象能够在Hadoop MapReduce作业中作为键或值使用&lt;/p&gt;
&lt;p&gt;Writable是Hadoop中用于序列化和反序列化数据的标准接口。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;public class NumberInfo implements Writable {
    private Long Confirmed; //已确诊，累计
    private Long Deaths; //死亡，累计
    private Long Health; //恢复，累计
    private String Province; //省份

    public NumberInfo() {}

    public NumberInfo(Long confirmed, Long deaths, Long health, String province) {//有参构造
        Confirmed = confirmed;
        Deaths = deaths;
        Health = health;
        Province = province;
    }

    @Override
    public void write(DataOutput dataOutput) throws IOException { //数据写出
        dataOutput.writeLong(Confirmed);
        dataOutput.writeLong(Deaths);
        dataOutput.writeLong(Health);
        dataOutput.writeUTF(Province);
    }

    @Override
    public void readFields(DataInput dataInput) throws IOException {//数据读取
        Confirmed = dataInput.readLong();
        Deaths = dataInput.readLong();
        Health = dataInput.readLong();
        Province = dataInput.readUTF();
    }

    @Override
    public String toString() { 
        return Confirmed + &quot;\t&quot; + Deaths + &quot;\t&quot; + Health + &quot;\t&quot; + Province;
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4. 设置Reduce文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class XinguanReduce extends Reducer&amp;lt;Text, NumberInfo,Text, ResultXinguan&amp;gt; {
    protected void reduce(Text key,Iterable values,Context context) throws IOException, InterruptedException {
        if (values!=null){
            for (NumberInfo value :values){
                ResultXinguan res = new ResultXinguan(value);
                context.write(key,res);
            }
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4.1最终对象&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class ResultXinguan implements Writable {
    private NumberInfo numberInfo;
    private double Mortality; //死亡率（死亡/确诊）
    private double RecoveryRate;//康复率（康复/确诊）
    private Long ActiveCases; //活跃病例（确诊-死亡-康复）
    private Long Confirmed; //已确诊，累计
    private Long Deaths; //死亡，累计
    private Long Health; //恢复，累计
    private String Province; //省份

    public ResultXinguan() {
    }

    public ResultXinguan(NumberInfo numberInfo) { //数据处理
        this.numberInfo = numberInfo;
        Confirmed = this.numberInfo.getConfirmed();
        Deaths = this.numberInfo.getDeaths();
        Health = this.numberInfo.getHealth();
        Province = this.numberInfo.getProvince();
        ActiveCases = Confirmed-Deaths-Health;

        if (Confirmed != 0) {
            Mortality = (double)Deaths / Confirmed;
            RecoveryRate = (double)Health / Confirmed;
        } else {
            Mortality = 0.0;
            RecoveryRate = 0.0;
        }
    }

    @Override
    public void write(DataOutput dataOutput) throws IOException {
        dataOutput.writeDouble(Mortality);
        dataOutput.writeDouble(RecoveryRate);
        dataOutput.writeLong(ActiveCases);
        dataOutput.writeLong(Confirmed);
        dataOutput.writeLong(Deaths);
        dataOutput.writeLong(Health);
        dataOutput.writeUTF(Province);
    }

    @Override
    public void readFields(DataInput dataInput) throws IOException {
        Mortality = dataInput.readDouble();
        RecoveryRate = dataInput.readDouble();
        ActiveCases = dataInput.readLong();
        Confirmed = dataInput.readLong();
        Deaths = dataInput.readLong();
        Health = dataInput.readLong();
        Province = dataInput.readUTF();
    }

    @Override
    public String toString() {
        return Mortality + &quot;\t&quot; + RecoveryRate + &quot;\t&quot; + ActiveCases + &quot;\t&quot; + Confirmed + &quot;\t&quot; + Deaths + &quot;\t&quot; + Health + &quot;\t&quot; + Province;
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;5. 创建Main运行文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class XinguanMain extends Configured implements Tool {
    @Override
    public int run(String[] strings) throws Exception {
        //判断输入是否正确
        if (strings.length != 2){
            System.out.println(&quot;Usage: XinguanMain input output&quot;);
            return -1;
        }
        //获取用户读取数据、保存数据的路径
        String inputPath = strings[0];
        String outputPath = strings[1];

        //创建实例，设置任务名称和类
        Job job = Job.getInstance(super.getConf(),&quot;mapreduce_calculation&quot;);
        job.setJarByClass(XinguanMain.class);

        //设置输入输出类型和路径
        job.setInputFormatClass(TextInputFormat.class);
        TextInputFormat.addInputPath(job,new Path(&quot;hdfs://hadoop100:9000&quot;+inputPath));
        job.setOutputFormatClass(TextOutputFormat.class);
        TextOutputFormat.setOutputPath(job,new Path(&quot;hdfs://hadoop100:9000&quot;+outputPath));                // 采用默认方式（分区，排序，规约，分组）

        //设置Map阶段的类、输入输出
        job.setMapperClass(XinguanMapper.class);
        job.setMapOutputKeyClass(Text.class);
        job.setMapOutputValueClass(NumberInfo.class);

        //设置Reduce阶段的类、输入输出
        job.setReducerClass(XinguanReduce.class);
        job.setOutputKeyClass(Text.class);
        job.setOutputValueClass(ResultXinguan.class);

        boolean b = job.waitForCompletion(true);
        return b?0:1;
    }

    public static void main(String[] args) throws Exception {
        Configuration configured = new Configuration();
        ToolRunner.run(configured,new XinguanMain(),args);
    }
}
 
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;生成Jar包并执行任务&lt;/h1&gt;
&lt;p&gt;1.  打包之后生成的文件在该项目的target文件夹下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202502/images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2025-02-18-145620.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;2. 执行任务&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;Main文件中，读取的地址设置的是HDFS路径&lt;/li&gt;
&lt;li&gt;执行任务需要输入完整包名&lt;/li&gt;
&lt;li&gt;输出路径必须不存在&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;[root@hadoop100 /] mv Hadoop-1.0-SNAPSHOT.jar xg.jar [root@hadoop100 /] hadoop jar xg.jar org.example.xinguan.XinguanMain /hdfs_inputPath /hdfs_outputPath
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202502/images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2025-02-18-152507.png&quot; alt=&quot;&quot; /&gt;&lt;img src=&quot;./guide/202502/images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2025-02-18-152526.png&quot; alt=&quot;&quot; /&gt;3. 查看数据结果&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@hadoop100 /]hdfs dfs -get /hdfs_path/part-r-00000 txt[root@hadoop100 /]head txt2020-01-22 0.0 0.0 0 0 0 0 Gansu2020-01-22 0.0 0.0 26 26 0 0 Guangdong2020-01-22 0.0 0.0 2 2 0 0 Guangxi2020-01-22 0.0 0.0 1 1 0 0 Guizhou2020-01-22 0.0 0.0 4 4 0 0 Hainan2020-01-22 0.0 0.0 1 1 0 0 Hebei2020-01-22 0.0 0.0 0 0 0 0 Heilongjiang2020-01-22 0.0 0.0 5 5 0 0 Henan2020-01-22 0.0 0.0 0 0 0 0 Hong Kong2020-01-22 0.038288288288288286 0.06306306306306306 399 444 17 28 Hubei[root@hadoop100 /]wc -l txt6392 txt
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;数据导入Hive表中&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;hive &amp;gt;load data inpath &apos;/hdfs_path/part-r-00000&apos; into table xg;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;创建、配置Django项目和应用&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://www.datazzh.top/archives/1713/2025/02/10/&quot;&gt;Django搭建与配置&lt;/a&gt; 不会搭建配置(mysql、app)可参考该pdf文件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202502/images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2025-02-18-154057.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h1&gt;创建数据模型&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;python manage.py makemigrations 生成数据库迁移文件&lt;br /&gt;
python manage.py migrate 将生成的迁移文件应用到数据库，实际修改数据库结构。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1.  创建数据模型&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class xgdata(models.Model):    date_day = models.CharField(max_length=20)    siwanglv = models.FloatField()    kangfulv = models.FloatField()    huoyuebingli = models.IntegerField()    quezhen = models.IntegerField()    siwang = models.IntegerField()    huifu = models.IntegerField()    pro = models.CharField(max_length=100)    pro_cn =models.CharField(max_length=100)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2. 生成数据库迁移文件，修改数据库结构&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;manage.py@Hadoop &amp;gt; makemigrations appnamemanage.py@Hadoop &amp;gt; migrate appname
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;生成的迁移文件会保存在该app的migrations文件夹下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202502/images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2025-02-18-155320.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h1&gt;数据导入MySql表中&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;[root@hadoop100] sqoop export \--connect jdbc:mysql://hadoop100/xg_xgdata \--username root \--password 123456 \--table xg \--target-dir /hdfs-path \--fields-terminated-by &apos;\t&apos;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;编写请求响应view.py和urls.py映射&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;视图层&lt;br /&gt;
一个视图函数，简称视图，是一个简单的 Python 函数，它接受 Web 请求并且返回 Web 响应。响应可以是一个 HTML 页面、一个 404 错误页面、重定向页面、XML 文档、或者一张图片...&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;# view.pydef get_xgdata(request):    # 原始数据集,访问show页面返回数据集全部内容    xgdata_ODS = xgdata.objects.all()    context = {&apos;xgdata&apos;:xgdata_ODS}    return render(resquest,&apos;show.html&apos;,context)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;# urls.pyurlpatterns = [    path(&apos;&apos;,xg.views.index),    path(&apos;admin/&apos;, admin.site.urls),    path(&apos;show.html/&apos;,xg.views.get_xgdata) #映射]
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;前后端数据交互&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;编写html文件，我们可以使用jinja2语法，通过特征字段获取视图层编写的函数所传递的数据内容&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;body&amp;gt;  &amp;lt;div&amp;gt;    {% for i in xgdata %}      {{ i.date_day }}      {{ i.kangfulv }}      &amp;lt;br&amp;gt;    {% endfor %}  &amp;lt;/div&amp;gt;&amp;lt;/body&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202502/images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2025-02-18-162644.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h1&gt;echarts数据可视化&lt;/h1&gt;
&lt;p&gt;以折现图为例&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div id=&quot;line1&quot; style=&quot;width:400px;height:200px&quot;&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;script type=&quot;module&quot;&amp;gt;// 初始化 echarts 对象  var line1 = echarts.init(document.getElementById(&apos;line1&apos;));  var series_data = [];  var xAxis_data = [];  {% for i in xgdata_sum %}    xAxis_data.push(new Date(&quot;{{ i.date_day }}&quot;).getTime());    series_data.push({{i.siwanglv}}*100)  {% endfor %}// 构造 series.data 所需的数据格式  const data = xAxis_data.map((date, index) =&amp;gt; [date, series_data[index]]);// ECharts 配置  const option = {    title: {      text: &apos;全国累计死亡率时间变动图&apos;,      left: &apos;center&apos;    },    tooltip: { //悬浮显示      trigger: &apos;axis&apos;,      axisPointer: {      type: &apos;cross&apos; //十字架    },      formatter: function (params) {        var date = echarts.format.formatTime(&apos;yyyy-MM-dd&apos;, params[0].value[0]);        return `${date}&amp;lt;br/&amp;gt;死亡率: ${(params[0].value[1]).toFixed(2)}%`;      }    },    xAxis: {      type: &apos;time&apos;,      axisLabel: {        formatter: function (value) {          return echarts.format.formatTime(&apos;yyyy-MM-dd&apos;, value);        }     }   },  yAxis: {    type: &apos;value&apos;  },  series: [{    data: data,    type: &apos;line&apos;,    smooth:true,    symbol:&apos;none&apos;,  }],  markLine: { // 标记线，可用于显示平均值或其他参考线    data: [{      type: &apos;average&apos;,      name: &apos;平均值&apos;    }]  }};// 使用 ECharts 实例设置配置line1.setOption(option);&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202502/images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2025-02-18-163613.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202502/images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2025-02-18-163934.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</content:encoded></item><item><title>Django搭建与配置</title><link>https://minthana.github.io/blog/posts/django%E6%90%AD%E5%BB%BA%E4%B8%8E%E9%85%8D%E7%BD%AE/</link><guid isPermaLink="true">https://minthana.github.io/blog/posts/django%E6%90%AD%E5%BB%BA%E4%B8%8E%E9%85%8D%E7%BD%AE/</guid><pubDate>Mon, 10 Feb 2025 16:15:00 GMT</pubDate><content:encoded>&lt;p&gt;&lt;img src=&quot;guide/202502/images/Django_merged-images-0.jpg&quot; alt=&quot;Django 文档第 1 页&quot; /&gt; &lt;img src=&quot;guide/202502/images/Django_merged-images-1.jpg&quot; alt=&quot;Django 文档第 2 页&quot; /&gt; &lt;img src=&quot;guide/202502/images/Django_merged-images-2.jpg&quot; alt=&quot;Django 文档第 3 页&quot; /&gt; &lt;img src=&quot;guide/202502/images/Django_merged-images-3.jpg&quot; alt=&quot;Django 文档第 4 页&quot; /&gt; &lt;img src=&quot;guide/202502/images/Django_merged-images-4.jpg&quot; alt=&quot;Django 文档第 5 页&quot; /&gt; &lt;img src=&quot;guide/202502/images/Django_merged-images-5.jpg&quot; alt=&quot;Django 文档第 6 页&quot; /&gt; &lt;img src=&quot;guide/202502/images/Django_merged-images-6.jpg&quot; alt=&quot;Django 文档第 7 页&quot; /&gt; &lt;img src=&quot;guide/202502/images/Django_merged-images-7.jpg&quot; alt=&quot;Django 文档第 8 页&quot; /&gt; &lt;img src=&quot;guide/202502/images/Django_merged-images-8.jpg&quot; alt=&quot;Django 文档第 9 页&quot; /&gt; &lt;img src=&quot;guide/202502/images/Django_merged-images-9.jpg&quot; alt=&quot;Django 文档第 10 页&quot; /&gt; &lt;img src=&quot;guide/202502/images/Django_merged-images-10.jpg&quot; alt=&quot;Django 文档第 11 页&quot; /&gt; &lt;img src=&quot;guide/202502/images/Django_merged-images-11.jpg&quot; alt=&quot;Django 文档第 12 页&quot; /&gt; &lt;img src=&quot;guide/202502/images/Django_merged-images-12.jpg&quot; alt=&quot;Django 文档第 13 页&quot; /&gt; &lt;img src=&quot;guide/202502/images/Django_merged-images-13.jpg&quot; alt=&quot;Django 文档第 14 页&quot; /&gt; &lt;img src=&quot;guide/202502/images/Django_merged-images-14.jpg&quot; alt=&quot;Django 文档第 15 页&quot; /&gt; &lt;img src=&quot;guide/202502/images/Django_merged-images-15.jpg&quot; alt=&quot;Django 文档第 16 页&quot; /&gt; &lt;img src=&quot;guide/202502/images/Django_merged-images-16.jpg&quot; alt=&quot;Django 文档第 17 页&quot; /&gt; &lt;img src=&quot;guide/202502/images/Django_merged-images-17.jpg&quot; alt=&quot;Django 文档第 18 页&quot; /&gt; &lt;img src=&quot;guide/202502/images/Django_merged-images-18.jpg&quot; alt=&quot;Django 文档第 19 页&quot; /&gt; &lt;img src=&quot;guide/202502/images/Django_merged-images-19.jpg&quot; alt=&quot;Django 文档第 20 页&quot; /&gt; &lt;img src=&quot;guide/202502/images/Django_merged-images-20.jpg&quot; alt=&quot;Django 文档第 21 页&quot; /&gt; &lt;img src=&quot;guide/202502/images/Django_merged-images-21.jpg&quot; alt=&quot;Django 文档第 22 页&quot; /&gt; &lt;img src=&quot;guide/202502/images/Django_merged-images-22.jpg&quot; alt=&quot;Django 文档第 23 页&quot; /&gt; &lt;img src=&quot;guide/202502/images/Django_merged-images-23.jpg&quot; alt=&quot;Django 文档第 24 页&quot; /&gt; &lt;img src=&quot;guide/202502/images/Django_merged-images-24.jpg&quot; alt=&quot;Django 文档第 25 页&quot; /&gt; &lt;img src=&quot;guide/202502/images/Django_merged-images-25.jpg&quot; alt=&quot;Django 文档第 26 页&quot; /&gt; &lt;img src=&quot;guide/202502/images/Django_merged-images-26.jpg&quot; alt=&quot;Django 文档第 27 页&quot; /&gt; &lt;img src=&quot;guide/202502/images/Django_merged-images-27.jpg&quot; alt=&quot;Django 文档第 28 页&quot; /&gt; &lt;img src=&quot;guide/202502/images/Django_merged-images-28.jpg&quot; alt=&quot;Django 文档第 29 页&quot; /&gt; &lt;img src=&quot;guide/202502/images/Django_merged-images-29.jpg&quot; alt=&quot;Django 文档第 30 页&quot; /&gt; &lt;img src=&quot;guide/202502/images/Django_merged-images-30.jpg&quot; alt=&quot;Django 文档第 31 页&quot; /&gt; &lt;img src=&quot;guide/202502/images/Django_merged-images-31.jpg&quot; alt=&quot;Django 文档第 32 页&quot; /&gt; &lt;img src=&quot;guide/202502/images/Django_merged-images-32.jpg&quot; alt=&quot;Django 文档第 33 页&quot; /&gt; &lt;img src=&quot;guide/202502/images/Django_merged-images-33.jpg&quot; alt=&quot;Django 文档第 34 页&quot; /&gt; &lt;img src=&quot;guide/202502/images/Django_merged-images-34.jpg&quot; alt=&quot;Django 文档第 35 页&quot; /&gt; &lt;img src=&quot;guide/202502/images/Django_merged-images-35.jpg&quot; alt=&quot;Django 文档第 36 页&quot; /&gt; &lt;img src=&quot;guide/202502/images/Django_merged-images-36.jpg&quot; alt=&quot;Django 文档第 37 页&quot; /&gt; &lt;img src=&quot;guide/202502/images/Django_merged-images-37.jpg&quot; alt=&quot;Django 文档第 38 页&quot; /&gt; &lt;img src=&quot;guide/202502/images/Django_merged-images-38.jpg&quot; alt=&quot;Django 文档第 39 页&quot; /&gt; &lt;img src=&quot;guide/202502/images/Django_merged-images-39.jpg&quot; alt=&quot;Django 文档第 40 页&quot; /&gt; &lt;img src=&quot;guide/202502/images/Django_merged-images-40.jpg&quot; alt=&quot;Django 文档第 41 页&quot; /&gt; &lt;img src=&quot;guide/202502/images/Django_merged-images-41.jpg&quot; alt=&quot;Django 文档第 42 页&quot; /&gt; &lt;img src=&quot;guide/202502/images/Django_merged-images-42.jpg&quot; alt=&quot;Django 文档第 43 页&quot; /&gt; &lt;img src=&quot;guide/202502/images/Django_merged-images-43.jpg&quot; alt=&quot;Django 文档第 44 页&quot; /&gt; &lt;img src=&quot;guide/202502/images/Django_merged-images-44.jpg&quot; alt=&quot;Django 文档第 45 页&quot; /&gt; &lt;img src=&quot;guide/202502/images/Django_merged-images-45.jpg&quot; alt=&quot;Django 文档第 46 页&quot; /&gt; &lt;img src=&quot;guide/202502/images/Django_merged-images-46.jpg&quot; alt=&quot;Django 文档第 47 页&quot; /&gt; &lt;img src=&quot;guide/202502/images/Django_merged-images-47.jpg&quot; alt=&quot;Django 文档第 48 页&quot; /&gt; &lt;img src=&quot;guide/202502/images/Django_merged-images-48.jpg&quot; alt=&quot;Django 文档第 49 页&quot; /&gt; &lt;img src=&quot;guide/202502/images/Django_merged-images-49.jpg&quot; alt=&quot;Django 文档第 50 页&quot; /&gt; &lt;img src=&quot;guide/202502/images/Django_merged-images-50.jpg&quot; alt=&quot;Django 文档第 51 页&quot; /&gt; &lt;img src=&quot;guide/202502/images/Django_merged-images-51.jpg&quot; alt=&quot;Django 文档第 52 页&quot; /&gt; &lt;img src=&quot;guide/202502/images/Django_merged-images-52.jpg&quot; alt=&quot;Django 文档第 53 页&quot; /&gt; &lt;img src=&quot;guide/202502/images/Django_merged-images-53.jpg&quot; alt=&quot;Django 文档第 54 页&quot; /&gt;&lt;/p&gt;
</content:encoded></item><item><title>Sqoop</title><link>https://minthana.github.io/blog/posts/sqoop/</link><guid isPermaLink="true">https://minthana.github.io/blog/posts/sqoop/</guid><pubDate>Mon, 10 Feb 2025 13:37:00 GMT</pubDate><content:encoded>&lt;h1&gt;Sqoop&lt;/h1&gt;
&lt;p&gt;Sqoop 是 Apache 开源工具，专用于在 Hadoop 生态系统（HDFS/Hive/HBase） 和 关系型数据库（如 MySQL、Oracle、PostgreSQL） 之间高效传输数据。即sql-to-hadoop。&lt;/p&gt;
&lt;h2&gt;原理&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;JDBC 连接&lt;/strong&gt;：通过 JDBC 驱动与数据库交互。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;MapReduce 并行化&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Import&lt;/strong&gt;：将表数据拆分为多个分片（split），每个 Map 任务处理一个分片，结果写入 HDFS。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Export&lt;/strong&gt;：将 HDFS 文件拆分为多个 Map 任务，并行写入数据库。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;事务管理&lt;/strong&gt;：导出时默认使用多事务提交，非原子操作（可通过 &lt;code&gt;--staging-table&lt;/code&gt; 参数优化）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;功能&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;导入（Import）&lt;/strong&gt;：将关系型数据库数据迁移到 HDFS、Hive 或 HBase。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;导出（Export）&lt;/strong&gt;：将 HDFS 或 Hive 数据写回关系型数据库。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;批量操作&lt;/strong&gt;：基于 MapReduce 实现并行化，高效处理大数据量。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;基本操作&lt;/h2&gt;
&lt;p&gt;1.  连接数据库&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;-connect jdbc:mysql://192.168.137.128:3306/ --username root --password 123456&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;[root@hadoop100 sqoop-1.4.7]# bin/sqoop list-databases --connect jdbc:mysql://192.168.137.128:3306/ --username root --password 123456
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2. 查询数据库、数据表&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@hadoop100 sqoop-1.4.7]# bin/sqoop list-databases --connect jdbc:mysql://192.168.137.128:3306/ --username root --password 123456
[root@hadoop100 sqoop-1.4.7]# bin/sqoop list-tables --connect jdbc:mysql://192.168.137.128:3306/usr --username root --password 123456
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3. Mysql导入HDFS&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;需要表中有主键&lt;/p&gt;
&lt;p&gt;添加主键：alter table TABLE_NAME add id int not null primary key Auto_increment&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;sqoop import \
--connect jdbc:mysql://hadoop100:3306/usr \
--username root \
--password 123456 \
--table xg \
--target-dir /hdfs_path \
--fields-terminated-by &apos;\t&apos;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4. HDFS导入Mysql&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sqoop export \
--connect jdbc:mysql://hadoop100/usr \
--username root \
--password 123456 \
--table xg \
--export-dir /hdfs_path
--input-fields-terminated-by &quot;\t&quot;
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>Hadoop</title><link>https://minthana.github.io/blog/posts/hadoop/</link><guid isPermaLink="true">https://minthana.github.io/blog/posts/hadoop/</guid><pubDate>Sat, 25 Jan 2025 18:07:00 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;p&gt;开贴记录&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202501/images/214e62e4e2febb0b81266c40b3fc67b-e1737960249551.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h1&gt;数据分析分类&lt;/h1&gt;
&lt;p&gt;数据分析在企业日常经营分析中主要有三个方向&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;现状分析（分析&lt;strong&gt;当下&lt;/strong&gt;的数据）：现阶段的整体情况，各个部分的结构占比、发展变动‘&lt;/li&gt;
&lt;li&gt;原因分析（分析&lt;strong&gt;过去&lt;/strong&gt;的数据）：某一现状为什么发生，确定原因，做出调整优化；&lt;/li&gt;
&lt;li&gt;预测分析（结合数据预测&lt;strong&gt;未来&lt;/strong&gt;）：结合已有数据预测未来发展趋势；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;离线分析（原因分析）：面向过去/历史，分析已有的数据。在时间维度明显成批次性变化。一周一分析（T+7），一天一分析（T+1），所以也叫做&lt;strong&gt;批处理&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;实时分析（现状分析）：面向当下，分析实时产生的数据。所谓的实时是指从数据产生到数据分析到数据应用的时间间隔很短，可细分秒级、毫秒级。&lt;/p&gt;
&lt;p&gt;预测分析（机器学习）：基于历史数据和当下产生的实时数据预测未来发生的事情;侧重于数学算法的运用，如分类、聚类、关联、预测。&lt;/p&gt;
&lt;h1&gt;概念&lt;/h1&gt;
&lt;h2&gt;分布式与集群概念&lt;/h2&gt;
&lt;p&gt;分布式：多台机器；每台机器上部署&lt;strong&gt;不同&lt;/strong&gt;组件&lt;/p&gt;
&lt;p&gt;分布式由多个节点组成，节点之间互通，共同配合对外提供服务&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202501/images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2025-01-25-104504.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;集群：多台机器；每台机器上部署&lt;strong&gt;相同组件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;集群是指在几个服务器上部署相同的应用程序来分担客户端的请求&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202501/images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2025-01-25-122718.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;Hadoop组件&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Hadoop&lt;/strong&gt;是一个由Apache基金会开发的分布式系统基础架构，旨在处理大规模数据的存储和计算。它的核心组件包括&lt;strong&gt;HDFS&lt;/strong&gt;、&lt;strong&gt;MapReduce&lt;/strong&gt;和&lt;strong&gt;YARN&lt;/strong&gt;，这些组件共同支撑起Hadoop的高效性、可靠性和可扩展性&lt;/p&gt;
&lt;h3&gt;HDFS&lt;/h3&gt;
&lt;p&gt;HDFS（分布式文件存储系统）：是Hadoop生态系统中的数据存储管理基础。HDFS通过流式数据访问，提供高吞吐量的数据访问功能，适合处理大型数据集。数据以块的形式分布在集群的不同物理机器上，提供了一次写入多次读取的机制。&lt;/p&gt;
&lt;h3&gt;MapReduce&lt;/h3&gt;
&lt;p&gt;MapReduce（分布式计算框架）：是一种分布式计算模型，用于进行大数据量的计算。它将计算抽象成map和reduce两部分，其中Map对数据集上的独立元素进行操作，生成键-值对形式的中间结果。Reduce则对中间结果中相同“键”的所有“值”进行规约，以得到最终结果。MapReduce非常适合在大量计算机组成的分布式并行环境里进行数据处理。&lt;/p&gt;
&lt;h3&gt;YARN&lt;/h3&gt;
&lt;p&gt;YARN（集群资源管理和任务调度框架）：是Hadoop的资源管理和任务调度框架。它将资源管理和作业调度/监视的功能拆分为单独的守护进程，包括ResourceManager和NodeManager。ResourceManager负责整个集群的资源管理和任务调度，而NodeManager负责管理和监控每个节点上的计算资源。YARN通过资源的统一管理和调度，提高了集群的利用率和数据共享能力。&lt;/p&gt;
&lt;h3&gt;集群的启动&lt;/h3&gt;
&lt;p&gt;1.启动HDFS服务&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;start-dfs.sh
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.查询Jps、NameNode、DataNode与SecondaryNameNode共四个进程&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;jps 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.启动yarn服务、查询ResourceManager与NodeManager两个进程&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;start-yarn.sh jps 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4.集群web网页（hadoop-2.6.5）&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;主机IP地址：50070端口&lt;/p&gt;
&lt;p&gt;主机IP地址：8088端口&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202501/images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2025-01-25-180528.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202501/images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2025-01-25-180646.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;5.集群关闭&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;stop-all.sh
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Hadoop特性&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;扩容能力：Hadoop是在可用的计算机集群间分配数据并完成计算任务的，这些集群可方便&lt;strong&gt;灵活的方式扩展&lt;/strong&gt;到数以千计的节点。&lt;/li&gt;
&lt;li&gt;成本低：Hadoop集群允许通过部署普通廉价的机器组成集群来处理大数据，以至于成本很低&lt;strong&gt;看重的是集群整体能力。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;效率高：通过&lt;strong&gt;并发&lt;/strong&gt;数据，Hadoop可以在节点之间&lt;strong&gt;动态并行&lt;/strong&gt;的移动数据，使得速度非常快。&lt;/li&gt;
&lt;li&gt;可靠性：能自动维护数据的多份复制，并且在任务失败后能自动地重新部署(redeploy)计算任务。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;Hadoop集群概述&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Hadoop集群是由&lt;strong&gt;HDFS集群&lt;/strong&gt;和&lt;strong&gt;YARN集群&lt;/strong&gt;组成&lt;/li&gt;
&lt;li&gt;两个集群逻辑上分离，通常物理上在一起&lt;/li&gt;
&lt;li&gt;两个集群是标准的&lt;strong&gt;主从架构&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;MapReduce是计算架构、代码层面的组件，无集群一说&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;HDFS集群&lt;/strong&gt;内容：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;NameNode(名称节点)：主角色&lt;/li&gt;
&lt;li&gt;DataNode(数据节点)：从角色&lt;/li&gt;
&lt;li&gt;SecondaryNode(辅助节点)：主角色辅助角色&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;YARN集群&lt;/strong&gt;内容：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;ResourceManager(资源管理器)：主角色&lt;/li&gt;
&lt;li&gt;NodeManager(节点管理器)：从角色&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202501/images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2025-01-25-212459.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h1&gt;HDFS&lt;/h1&gt;
&lt;h2&gt;HDFS设计目标&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;故障检测和自动快速恢复：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;硬件故障(Hardware Failure)是常态， HDFS可能有成百上千的服务器组成,每一个组件都有可能出现故障。因此&lt;strong&gt;故障检测和自动快速恢复&lt;/strong&gt;是HDFS的核心架构目标。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;高吞吐量：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;HDFS上的应用主要是以流式读取数据(Streaming Data Access)。HDFS被设计成用于&lt;strong&gt;批处理&lt;/strong&gt;，而不是用户交互式的。相较于数据访问的反应时间，更&lt;strong&gt;注重数据访问的高吞吐量&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;支持大文件：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;典型的HDFS文件大小是GB到TB的级别。所以，HDFS被调整成&lt;strong&gt;支持大文件&lt;/strong&gt;(Large Data Sets)。它应该提供很高的聚合数据带宽，一个集群中支持数百个节点，一个集群中还应该支持千万级别的文件。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;无需修改：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;大部分HDFS应用对文件要求的是**一次写入，多次读取(write-one-read-many)**访问模型。一个文件一旦创建、写入、关闭之后就不需要修改了。这一假设简化了数据一致性问题，使高吞吐量的数据访问成为可能。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;移动计算代价：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;移动计算的代价比之移动数据的代价低&lt;/strong&gt;。一个应用请求的计算，离它操作的数据越近就越高效。将计算移动到数据附近，比之将数据移动到应用所在显然更好。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;平台移植：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;HDFS被设计为可从一个平台轻松移植到另一个平台。这有助于将HDFS广泛用作大量应用程序的首选平台。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202501/images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2025-01-27-153740.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;HDFS&lt;strong&gt;的分布式特性&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;数据跨节点存储：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;HDFS的数据被分割成多个块（Block，默认128MB或256MB），并分散存储在不同机器的磁盘上。&lt;/li&gt;
&lt;li&gt;单机文件系统只能操作单机上的文件，而HDFS需要协调多个节点（DataNode）的读写操作。&lt;/li&gt;
&lt;li&gt;单机读写无法感知数据分布，可能导致数据不一致或丢失。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;元数据集中管理：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;HDFS通过NameNode管理文件系统的元数据（如文件路径、块位置、副本信息等）。&lt;/li&gt;
&lt;li&gt;本地命令（如cp、mv）无法与NameNode交互，无法获取文件的分布式元数据。&lt;/li&gt;
&lt;li&gt;HDFS Shell命令会通过NameNode的RPC接口完成元数据操作（如hdfs dfs -ls）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202501/images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2025-01-27-152720.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;HDFS的存储位置&lt;/h2&gt;
&lt;p&gt;每一个集群节点的数据存储地点可以在安装Hadoop时配置的hadoop-2.6.5/etc/hadoop/&lt;strong&gt;hdfs-site.xml&lt;/strong&gt;中查询&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;property&amp;gt;
    &amp;lt;name&amp;gt;dfs.datanode.data.dir&amp;lt;/name&amp;gt;
    &amp;lt;value&amp;gt;file:/opt/software/hadoop-2.6.5/hdfs/data&amp;lt;/value&amp;gt;
&amp;lt;/property&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;HDFS的Shell操作&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;hadoop fs 和 hdfs dfs 可以替换使用&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;基础操作&lt;/h3&gt;
&lt;p&gt;1..查看文件目录&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;hdfs dfs -ls /hdfs dfs -ls -R / # 递归列出子目录
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.查看文件内容&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;hdfs dfs -cat &amp;lt;HDFS文件路径&amp;gt;
hdfs dfs -tail &amp;lt;文件&amp;gt; # 查看文件末尾内容
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.创建目录&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;hdfs dfs -mkdir &amp;lt;目录路径&amp;gt;
hdfs dfs -mkdir -p &amp;lt;多层目录路径&amp;gt;

hadoop fs -mkdir &amp;lt;目录路径&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4.上传文件到HDFS&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;hdfs dfs -put &amp;lt;本地文件&amp;gt; &amp;lt;HDFS目标路径&amp;gt; 
hdfs dfs -copyFromLocal &amp;lt;本地文件&amp;gt; &amp;lt;HDFS路径&amp;gt; # 功能同put,生产环境更习惯用put
hdfs dfs -moveFromLocal &amp;lt;本地文件&amp;gt; &amp;lt;HDFS路径&amp;gt; # 从本地剪切粘贴到HDFS
hdfs dfs -appendToFile &amp;lt;本地文件&amp;gt; &amp;lt;HDFS路径&amp;gt; # 追加到文件末尾

hadoop fs [-put][-copyFromLocal][-moveFromLocal][-appendToFile] &amp;lt;本地文件&amp;gt; &amp;lt;HDFS路径&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;5.下载文件到本地&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;hadoop fs -copyToLocal &amp;lt;HDFS目标路径&amp;gt; &amp;lt;本地文件&amp;gt;hadoop fs -get &amp;lt;HDFS目标路径&amp;gt; &amp;lt;本地文件&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;6.删除文件和文件夹&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;hadoop fs -rm -r &amp;lt;路径&amp;gt;hdfs dfs -rm &amp;lt;路径&amp;gt;hdfs dfs -rm -skipTrash &amp;lt;文件&amp;gt; # 直接删除（绕过回收站）
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;7.移动/重命名文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;hdfs dfs -mv &amp;lt;源路径&amp;gt; &amp;lt;目标路径&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;8.复制文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;hdfs dfs -cp &amp;lt;源路径&amp;gt; &amp;lt;目标路径&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;文件权限管理&lt;/h3&gt;
&lt;p&gt;1.修改文件/目录权限&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;hdfs dfs -chmod &amp;lt;权限模式&amp;gt; &amp;lt;路径&amp;gt; 
# 示例：-chmod 755 /datahdfs dfs -chmod -R &amp;lt;权限模式&amp;gt; &amp;lt;目录&amp;gt; # 递归修改
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.修改文件所有者&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;hdfs dfs -chown &amp;lt;用户:组&amp;gt; &amp;lt;路径&amp;gt; 
# 示例：-chown hadoop:users /datahdfs dfs -chown -R &amp;lt;用户:组&amp;gt; &amp;lt;目录&amp;gt; # 递归修改
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.修改文件所属组&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;hdfs dfs -chgrp &amp;lt;组名&amp;gt; &amp;lt;路径&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;系统管理与监控&lt;/h3&gt;
&lt;p&gt;1.查看HDFS磁盘使用情况&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; hdfs dfs -df -h 
 # 显示可读的磁盘空间统计
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.查看文件/目录大小&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;hdfs dfs -du -h &amp;lt;路径&amp;gt; 
# 显示文件大小（-h为易读格式）hdfs dfs -du -s -h &amp;lt;目录&amp;gt; # 汇总目录总大小
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;HDFS集群角色与职责&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202501/images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2025-01-27-160018.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;NameNode：主角色&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;NameNode是Hadoop分布式文件系统的核心，架构中的&lt;strong&gt;主角色&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;NameNode&lt;strong&gt;维护和管理文件系统元数据&lt;/strong&gt;，包括名称空间目录树结构、文件和块的位置信息、访问权限等信息。&lt;/li&gt;
&lt;li&gt;是访问HDFS的唯一入口&lt;/li&gt;
&lt;li&gt;NameNode内部通过&lt;strong&gt;内存&lt;/strong&gt;和&lt;strong&gt;磁盘文件&lt;/strong&gt;两种方式管理元数据。&lt;/li&gt;
&lt;li&gt;其中磁盘上的元数据文件包括Fsimage内存元数据镜像文件和editslog(Journal)编辑日志。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;职责&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;NameNode&lt;strong&gt;仅存储HDFS的元数据&lt;/strong&gt;:文件系统中所有文件的目录树，并跟踪整个集群中的文件，&lt;strong&gt;不存储实际数据&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;NameNode知道HDFS中任何给定文件的块列表及其位置。使用此信息NameNode知道如何从块中构建文件。&lt;/li&gt;
&lt;li&gt;NameNode不持久化存储每个文件中各个块所在的datanode的位置信息，这些信息会在系统启动时从DataNode重建&lt;/li&gt;
&lt;li&gt;NameNode是Hadoop集群中的&lt;strong&gt;单点故障&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;NameNode&lt;strong&gt;所在机器通常会配置有大量内存(RAM)&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;DataNode：从角色&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;DataNode是Hadoop HDFS中的从角色，负责&lt;strong&gt;具体的数据块存储&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;DataNode的数量决定了HDFS集群的整体数据存储能力。通过和NameNode配合维护着数据块。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;职责&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;DataNode负责&lt;strong&gt;最终数据块block的存储&lt;/strong&gt;。是集群的从角色，也称为Slave。&lt;/li&gt;
&lt;li&gt;DataNode启动时，会将自己注册到NameNode并汇报自己负责持有的块列表。&lt;/li&gt;
&lt;li&gt;当某个DataNode关闭时，不会影响数据的可用性。 NameNode将安排由其他DataNode管理的块进行副本复制。&lt;/li&gt;
&lt;li&gt;DataNode所在机器&lt;strong&gt;通常配置有大量的硬盘空间&lt;/strong&gt;，因为实际数据存储在DataNode中。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;SecondaryNode：主角色辅助角色&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;充当NameNode的辅助节点，但&lt;strong&gt;不能替代&lt;/strong&gt;NameNode。&lt;/li&gt;
&lt;li&gt;主要是帮助主角色&lt;strong&gt;进行元数据文件的合并动作&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;MapReduce&lt;/h1&gt;
&lt;h2&gt;核心思想&lt;/h2&gt;
&lt;p&gt;1.  分而治之（Divide and Conquer）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将大数据集拆分为多个小数据集（Input Splits），彼此之间几乎&lt;strong&gt;没有依赖关系&lt;/strong&gt;，分布式处理。&lt;/li&gt;
&lt;li&gt;Map阶段：并行处理每个分片，生成中间结果（键值对）。&lt;/li&gt;
&lt;li&gt;Reduce阶段：汇总中间结果，生成最终输出。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2. 移动计算而非数据&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将计算逻辑（Map/Reduce代码）分发到数据所在的节点，减少网络传输开销。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;3. 面向批处理&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;适合离线、大规模数据的高吞吐量处理，不适合低延迟场景。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;4. 键值对处理&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MapReduce处理的数据类型是**&amp;lt;key,value&amp;gt;键值对**。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;特点&lt;/h2&gt;
&lt;h3&gt;优点&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;高容错性&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Hiadoop集群是分布式搭建和部署得，任何单一机器&lt;strong&gt;节点宕机&lt;/strong&gt;了，它可以把上面的&lt;strong&gt;计算任务转移&lt;/strong&gt;到另一个节点上运行，不影响整个作业任务得完成，过程完全是由Hadoop内部完成的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;适合海量数据的离线处理&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可以处理GB、TB和PB级别得数据量&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;局限性&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;实时计算性能差&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MapReduce主要应用于离线作业，无法作到秒级或者是亚秒级得数据响应&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;不能进行流式计算&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;流式计算特点是数据是源源不断得计算，并且数据是动态的；而MapReduce作为一个离线计算框架，主要是针对静态数据集得，数据是不能动态变化得。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;架构&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;ResourceManager (RM)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;全局资源管理，负责集群资源分配。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;NodeManager (NM)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单个节点上的资源管理和任务执行。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;ApplicationMaster (AM)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每个作业的协调者，负责与RM协商资源，监控任务执行。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Container&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;资源抽象单位（CPU、内存等）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;strong&gt;作业提交流程&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Client(客户)提交作业到RM → RM分配Container启动AM → AM向RM申请资源 → NM启动Task(任务)。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;strong&gt;阶段组成&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;一个MapReduce编程模型中，只能包含一个Map阶段和一个Reduce阶段，或者只有Map阶段&lt;/li&gt;
&lt;li&gt;不能出现多个Map阶段或Reduce阶段&lt;/li&gt;
&lt;li&gt;当业务逻辑复杂，就只能多个MapReduce程序串行运行&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202501/images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2025-02-01-145825.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;调用实现&lt;/h2&gt;
&lt;p&gt;MapReduce提供的计算服务jar包保存在 Hadoop安装路径下的 &lt;strong&gt;/share/hadoop/mapreduce&lt;/strong&gt; 下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202501/images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2025-02-02-111959.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;实现词频统计&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;shuffle阶段核心：经过MR程序内部自带默认的&lt;strong&gt;排序分组等功能&lt;/strong&gt;，把key&lt;strong&gt;相同的单词&lt;/strong&gt;会作为一组数据&lt;strong&gt;构成新的&amp;lt;key,value&amp;gt;对&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;reduce阶段核心：处理shuffle完的一组数据，进行算数运算或其他操作（此处为累加求和）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202501/images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2025-02-02-102845.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#创建文件夹
hdfs dfs -mkdir /wordcount
hdfs dfs -mkdir /wordcount/input
hdfs dfs -mkdir /wordcount/output
#上传文件
hdfs dfs -put /demo/hello.txt /wordcount/input
#提交计算任务
cd /share/hadoop/mapreduce
hadoop jar hadoop-mapreduce-examples-2.6.5.jar wordcount /wordcount/input /wordcount/output
#查询计算结果
hdfs dfs -cat /wordcount/output/part-r-00000
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;输出目录必须不存在&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202501/images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2025-02-02-102425.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;map执行过程&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202501/images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2025-02-02-110307.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;第一阶段&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;把输入目录下的文件，按照一定标准，逐个进行&lt;strong&gt;逻辑切片&lt;/strong&gt;，形成切片规划。&lt;/li&gt;
&lt;li&gt;默认Split size = Block size(块大小 &lt;strong&gt;128M&lt;/strong&gt;)，每一个切片由MapTask处理&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;第二阶段&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对切片中的数据，按照一定的规则，&lt;strong&gt;读取解析返回键值对&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;默认为&lt;strong&gt;按行读取数据。&lt;strong&gt;Key为每一行的&lt;/strong&gt;起始位置偏移量&lt;/strong&gt;，Value为文本内容&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;第三阶段&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;调用Mapper类中的map方法处理数据&lt;/li&gt;
&lt;li&gt;每读取解析出来一个键值对，调用一次map方法&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;第四阶段&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;按照一定规则，对Map的输出键值对进行分区partition。&lt;/li&gt;
&lt;li&gt;默认不分区，因为只有一个reducetask。分区数量就是reducetask的数量&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;第五阶段&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Map输出数据写入内存缓存区，达到比例&lt;strong&gt;溢出到磁盘上&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;溢出spill的时候根据key，进行排序sort。&lt;/li&gt;
&lt;li&gt;默认根据key字典序排序&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;第六阶段&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对所有的溢出文件进行最终的&lt;strong&gt;merge合并&lt;/strong&gt;，成为一个文件。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Reduce执行过程&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202501/images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2025-02-02-112631.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;第一阶段&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ReduceTask主动从MapTask，复制拉取属于需要自己处理的数据&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;第二阶段&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;把拉取的数据，全部进行合并merge，即把分散的数据合并成为一个大的数据。再对合并后的数据排序&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;第三阶段&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对排序后的键值对，调用Reduce方法。键相等的键值对调用一次reduce方法。最后把这些输出的键值对写入到HDFS文件中。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;shuffle机制&lt;/h3&gt;
&lt;p&gt;MR程序的核心与精髓。&lt;/p&gt;
&lt;p&gt;概念&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Shuffle的本意是洗牌、混洗的意思，把一组有规则的数据尽量打乱成无规则的数据。&lt;/li&gt;
&lt;li&gt;而在MapReduce中，Shuffle更像是洗牌的逆过程，指的是将map端的无规则输出按指定的规则“打乱”成&lt;strong&gt;具有一定规则的数据，以便reduce端接收处理&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;一般把从Map产生&lt;strong&gt;输出开始&lt;/strong&gt;到Reduce取得数据&lt;strong&gt;作为输入之前&lt;/strong&gt;的过程称作shuffle。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;机制弊端&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;相较于Spark，Flink计算引擎慢&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;频繁涉及到数据在内存、磁盘之间的多次往返&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;YARN&lt;/h1&gt;
&lt;h2&gt;概述&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Apache Hadoop YARN(Yet Another Resource Negotiator,另一种资源协调者)是一种新的Hadoop资源管理器&lt;/li&gt;
&lt;li&gt;YARN是一个&lt;strong&gt;通用资源管理系统和调度平台&lt;/strong&gt;，可为上层应用提供统一的资源管理和调度。&lt;/li&gt;
&lt;li&gt;它的引入为集群在利用率、资源统一管理和数据共享等方面带来了巨大好处。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202501/images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2025-02-02-141624.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;资源管理系统：集群的&lt;strong&gt;硬件资源&lt;/strong&gt;，和程序运行相关，比如&lt;strong&gt;内存、CPU&lt;/strong&gt;等&lt;/li&gt;
&lt;li&gt;调度平台:多个程序同时申请计算&lt;strong&gt;资源如何分配&lt;/strong&gt;，调度的规则(算法)。&lt;/li&gt;
&lt;li&gt;通用：不仅仅支持MapReduce程序，理论上支持&lt;strong&gt;各种计算程序&lt;/strong&gt;。YARN不关心你干什么，只关心你要资源，在有的情况下给你，用完之后还我。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;架构&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;ResourceManager&lt;/li&gt;
&lt;li&gt;NodeManager&lt;/li&gt;
&lt;li&gt;ApplicationMaster&lt;/li&gt;
&lt;li&gt;Client客户端&lt;/li&gt;
&lt;li&gt;Container容器（资源的抽象、隔离）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;三大组件&lt;/h3&gt;
&lt;h4&gt;ResourceManager（RM)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;YARN集群中的&lt;strong&gt;主角色&lt;/strong&gt;，&lt;strong&gt;决定&lt;/strong&gt;系统中所有应用程序之间&lt;strong&gt;资源分配&lt;/strong&gt;的最终权限，即最终仲裁者。&lt;/li&gt;
&lt;li&gt;接收用户的作业提交，并通过MM&lt;strong&gt;分配、管理&lt;/strong&gt;各个机器上的&lt;strong&gt;计算资源&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;NodeManager (NM)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;YARN中的&lt;strong&gt;从角色&lt;/strong&gt;，一台机器上一个，负责&lt;strong&gt;管理本机器上&lt;/strong&gt;的计算资源。&lt;/li&gt;
&lt;li&gt;根据RM命令，启动Container容器、&lt;strong&gt;监视容器的资源使用情况&lt;/strong&gt;。并且向RM主角色汇报资源使用情况。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;ApplicationMaster(AM)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;用户提交的每个应用程序均包含一个AM。&lt;/li&gt;
&lt;li&gt;应用程序内的“老大”，负责程序内部各阶段的资源申请，监督程序的执行情况。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;核心交互流程&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;MR作业提交:Client--&amp;gt;RM&lt;/li&gt;
&lt;li&gt;资源的申请:MRAppMaster--&amp;gt;RM&lt;/li&gt;
&lt;li&gt;MR作业状态汇报:Container(MapReduce Task)--&amp;gt;Container( MRAppMaster )&lt;/li&gt;
&lt;li&gt;节点的状态汇报:NM--&amp;gt;RM&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;整体概述&lt;/h3&gt;
&lt;p&gt;当用户向 YARN 中提交一个应用程序后，YARN将分两个阶段运行该应用程序&lt;/p&gt;
&lt;p&gt;第一个阶段是客户端申请资源启动运行本次程序的ApplicationMaster ;&lt;/p&gt;
&lt;p&gt;第二个阶段是由ApplicationMaster&lt;strong&gt;根据本次程序内部具体情况&lt;/strong&gt;，为它申请资源，并监控它的整个运行过程，直到运行完成。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202501/images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2025-02-02-150711.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用户通过客户端向YARN中ResourceManager提交应用程序(比如hadoop jar提交MR程序)；&lt;/li&gt;
&lt;li&gt;ResourceManager为该应用程序分配第一个Container(容器)，并与对应的NodeManager通信，要求它在这个Container中启动这个应用程序的ApplicationMaster；&lt;/li&gt;
&lt;li&gt;ApplicationMaster启动成功之后，首先向ResourceMlanager注册并保持通信，这样用户可以直接通过ResourceManage查看应用程序的运行状态(处理了百分之几)；&lt;/li&gt;
&lt;li&gt;AM为本次程序内部的各个Task任务向RM申请资源，并监控它的运行状态；&lt;/li&gt;
&lt;li&gt;一旦 ApplicationMaster 申请到资源后，便与对应的 NodeManager 通信，要求它启动任务；&lt;/li&gt;
&lt;li&gt;NodeManager 为任务设置好运行环境后，将任务启动命令写到一个脚本中，并通过运行该脚本启动任务&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;资源调度器Scheduler&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;在理想情况下，应用程序提出的请求将立即得到YARN批准。&lt;/li&gt;
&lt;li&gt;但是实际中，资源是有限的，并且在繁忙的集群上，应用程序通常将需要等待其某些请求得到满足。&lt;/li&gt;
&lt;li&gt;YARN调度程序的工作是根据一些定义的策略为应用程序分配资源&lt;/li&gt;
&lt;li&gt;在YARN中，负责给应用分配资源的就是Scheduler，它是Resourcellanager的核心组件之一。Scheduler完全专用于调度作业，它无法跟踪应用程序的状态。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;调度器策略&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Apache版本YARN默认使用&lt;strong&gt;容量调度器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用其他调度器，可以在yarn-site.xml中的yarn.resourcemanager.scheduler.class进行配置&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;先进先出调度器(FIFO Scheduler)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;FIFO Scheduler是一个&lt;strong&gt;先进先出&lt;/strong&gt;的思想，即&lt;strong&gt;先提交的应用先运行&lt;/strong&gt;。调度工作&lt;strong&gt;不考虑优先级和范围&lt;/strong&gt;，适用于负载较低的小规模集群。当使用大型共享集群时，它的效率较低且会导致一些问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;容量调度器(Capacity Scheduler)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Capacity Scheduler容量调度是Apache lladoop3.x默认调度策略。该策略允许&lt;strong&gt;多个组织共享整个集群资源&lt;/strong&gt;，每个组织可以获得集群的&lt;strong&gt;一部分计算能力&lt;/strong&gt;。通过为每个组织&lt;strong&gt;分配&lt;/strong&gt;专门的&lt;strong&gt;队列&lt;/strong&gt;，然后再为每个队列&lt;strong&gt;分配&lt;/strong&gt;一定的集群&lt;strong&gt;资源&lt;/strong&gt;，这样整个集群就可以&lt;strong&gt;通过设置多个队列的方式&lt;/strong&gt;给多个组织提供服务了。&lt;/li&gt;
&lt;li&gt;capacity可以理解成一个个的资源队列，这个资源队列是用户自己去分配的。队列内部又可以垂直划分，这样一个组织内部的多个成员就可以共享这个队列资源了，在一个队列内部，资源的调度是采用的是先进先出(FIFO)策略。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;公平调度器(Fair Scheduler)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Fair Scheduler叫做公平调度，提供了YARN应用程序公平地共享大型集群中资源的另一种方式。&lt;/li&gt;
&lt;li&gt;使所有应用在平均情况下随着时间的流逝可以获得相等的资源份额。&lt;/li&gt;
&lt;li&gt;Fair Scheduler设计目标是为所有的应用分配公平的资源(对公平的定义通过参数来设置)。&lt;/li&gt;
&lt;li&gt;公平调度可以在多个队列间工作，允许资源共享和抢占。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;当只有A有任务时，占用集群全部资源&lt;/p&gt;
&lt;p&gt;A、B各有一个任务时，各自占用集群一半资源&lt;/p&gt;
&lt;p&gt;A有1个任务，B有两个任务时，A、B占用集群一半资源，B的2个任务平分1/4的集群资源&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1&gt;Hive&lt;/h1&gt;
&lt;h2&gt;概述&lt;/h2&gt;
&lt;h3&gt;内容&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Apache Hive是一款建立在Hadoop之上的&lt;strong&gt;开源数据仓库系统&lt;/strong&gt;，可以将存储在Hadoop文件中的结构化、半结构化数据文件&lt;strong&gt;映射&lt;/strong&gt;为一张数据库表，基于表提供了一种类似SQL的查询模型，称为&lt;strong&gt;Hive查询语言(HQL)&lt;/strong&gt;，&lt;strong&gt;用于访问和分析&lt;/strong&gt;存储在Hadoop文件中的大型数据集。&lt;/li&gt;
&lt;li&gt;Hive核心是将&lt;strong&gt;HQL转换为MapReduce程序&lt;/strong&gt;，然后将程序提交到Hadoop群集执行&lt;/li&gt;
&lt;li&gt;Hive由Facebook实现并开源。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;问题&lt;/h3&gt;
&lt;p&gt;使用Hadoop MapReduce直接处理数据所面临的问题&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;人员学习成本太高 需要掌握java&lt;/li&gt;
&lt;li&gt;MapReduce实现复杂查询逻辑开发难度太大&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;好处&lt;/h3&gt;
&lt;p&gt;使用Hive处理数据的好处&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;操作接口采用类SQL语法，提供快速开发的能力(简单、容易上手)&lt;/li&gt;
&lt;li&gt;避免直接写MapReduce，减少开发人员的学习成本&lt;/li&gt;
&lt;li&gt;支持自定义函数，功能扩展很方便&lt;/li&gt;
&lt;li&gt;背靠Hadoop，擅长存储分析海量数据集&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;关系&lt;/h3&gt;
&lt;p&gt;作为数据仓库软件，Hive具备存储数据和查询分析数据的功能&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Hive利用HDFS存储数据&lt;/li&gt;
&lt;li&gt;利用MapReduce查询分析数据&lt;/li&gt;
&lt;li&gt;Hive只需要用于专注于编写HQL，帮助用户转换为MapReduce程序完成对数据的分析&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202501/images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2025-02-03-110054.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;组件与执行过程&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202501/images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2025-02-03-110848-e1738634036714.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;用户接口（User Interfaces）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;CLI（命令行界面）：用户直接输入HQL命令进行交互。&lt;/li&gt;
&lt;li&gt;HiveServer2（Thrift服务）：支持JDBC/ODBC连接，便于远程客户端（如Python、Java）访问。&lt;/li&gt;
&lt;li&gt;Web UI：通过工具（如Hue）提供可视化界面，用于查询提交和监控。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;元数据存储（Metastore）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;功能：存储表结构（Schema）、分区信息、数据位置等元数据。&lt;/li&gt;
&lt;li&gt;存储后端：通常使用关系型数据库（如MySQL、PostgreSQL），独立于HDFS。&lt;/li&gt;
&lt;li&gt;Metastore服务：可配置为远程模式，允许多个Hive实例共享元数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;驱动（Driver）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;编译器（Compiler）：解析HiveQL，生成逻辑计划和物理执行计划。&lt;/li&gt;
&lt;li&gt;优化器（Optimizer）：对逻辑计划进行优化（如谓词下推、分区裁剪、Join优化）。&lt;/li&gt;
&lt;li&gt;执行引擎（Execution Engine）：将优化后的计划提交到MapReduce、Tez或Spark执行。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;执行引擎（Execution Engines）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;MapReduce：默认引擎，适合批处理，但延迟较高。&lt;/li&gt;
&lt;li&gt;Tez：基于DAG的任务调度，减少中间数据落盘，提升性能。&lt;/li&gt;
&lt;li&gt;Spark：利用内存计算加速处理，适合迭代式任务。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;底层依赖（Hadoop Ecosystem）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;HDFS：存储实际数据文件。&lt;/li&gt;
&lt;li&gt;YARN：管理集群资源调度。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;使用客户端&lt;/h2&gt;
&lt;h3&gt;概述&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Hive发展至今，总共历经了两代客户端工具。&lt;/li&gt;
&lt;li&gt;第一代客户端(deprecated不推荐使用):$HIVE HOME/bin/hive，是一个 shellUti1。主要功能:一是可用于以交互或批处理模式运行Hive查询;二是用于Hive相关服务的启动，比如metastore服务。&lt;/li&gt;
&lt;li&gt;第二代客户端(recommended 推荐使用):$HIVE_HOME/bin/beeline,是一个JDBC客户端,是官方强烈推荐使用的Hive命令行工具，和第一代客户端相比，性能加强安全性提高。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;HiveServer2服务介绍&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;远程模式下beeline通过 Thrift 连接到单独的liveServer2服务上，这也是官方推荐在生产环境中使用的模式。&lt;/li&gt;
&lt;li&gt;HiveServer2支持多客户端的并发和身份认证，旨在为开放API客户端如JDBC、0DBC提供更好的支持。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202501/images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2025-02-03-185607-e1738633945222.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;方法一：使用第一代客户端&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@hadoop100 hive]# bin/hive
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;方法二： 使用第二代客户端&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@hadoop100 hive]# nohup /opt/software/hive/bin/hive --service metastore &amp;amp;
[root@hadoop100 hive]# nohup /opt/software/hive/bin/hive --service hiveserver2 &amp;amp;
[root@hadoop100 hive]# bin/beeline
beeline&amp;gt; ! connect jdbc:hive2://192.168.137.128:10000 
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;基本操作&lt;/h2&gt;
&lt;p&gt;1. 创建表，并声明文件分隔符’\t’&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;hive&amp;gt; create table stu(id int,name string) row format delimited fields terminated by &apos;\t&apos;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2. 创建默认表（&lt;strong&gt;默认分隔符为‘\001’，vim中为^A，ctrl V+ctrl A&lt;/strong&gt;）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;hive&amp;gt; create table stu(id int,name string)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3. 加载本地文件到数据表中&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;hive&amp;gt; load data local inpath &apos;opt/software/datas/stu.txt&apos; into table stu;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4. 加载HDFS文件到数据表&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;hive&amp;gt; load data inpath &apos;/stu.txt&apos; into table stu;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;5. 增添数据&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;hive&amp;gt; insert into table stu values(1,&apos;zhangsan&apos;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;6. 查询结构信息&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;hive&amp;gt; desc formatted stu;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;ZooKeeper&lt;/h1&gt;
&lt;h2&gt;概念&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;ZooKeeper是Apache Hadoop 项目下的一个子项目，是一个&lt;strong&gt;树形目录服务&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Zookeeper 翻译过来就是动物园管理员，他是用来管Hadoop(大象)、Hive(蜜蜂)、Pig(小猪)的管理员。简称zk&lt;/li&gt;
&lt;li&gt;Zookeeper 是一个分布式的，开源的分布式应用程序的协调服务&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;主要功能&lt;/h2&gt;
&lt;h3&gt;配置管理&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;问题背景&lt;/strong&gt;：分布式系统中，多个节点需共享统一配置（如数据库地址、服务开关）。手动维护易出错且低效。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;实现机制&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;集中存储&lt;/strong&gt;：配置信息存储在持久型ZNode（如&lt;code&gt;/config&lt;/code&gt;），各节点读取该节点数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;动态更新&lt;/strong&gt;：通过Watch机制监听节点变化。当配置变更时，Zookeeper通知所有监听客户端，触发其拉取新配置。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;示例场景&lt;/strong&gt;：微服务架构中，所有服务实例从&lt;code&gt;/config/db_url&lt;/code&gt;获取数据库地址，管理员更新该节点后，服务自动生效。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;分布式锁&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;问题背景&lt;/strong&gt;：多节点竞争共享资源时（如修改同一数据），需互斥访问以避免冲突。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;实现机制&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;临时顺序节点&lt;/strong&gt;：客户端在锁节点（如&lt;code&gt;/locks/resource1&lt;/code&gt;）下创建临时顺序子节点（如&lt;code&gt;resource1_00000001&lt;/code&gt;）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;最小序号获锁&lt;/strong&gt;：序号最小的节点持有锁。后续节点监听前一个序号节点，形成等待队列。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;释放与容错&lt;/strong&gt;：客户端主动删除节点释放锁，或会话终止时临时节点自动删除，防止死锁。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;示例场景&lt;/strong&gt;：电商系统中，多个订单服务通过竞争锁确保同一时刻仅一个服务处理库存扣减。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;集群管理&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;问题背景&lt;/strong&gt;：监控集群节点状态（在线/离线），动态选举主节点以协调任务。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;实现机制&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;临时节点注册&lt;/strong&gt;：节点启动时在&lt;code&gt;/members&lt;/code&gt;下创建临时节点（如&lt;code&gt;/members/node1&lt;/code&gt;），会话保持则节点存活。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;状态感知&lt;/strong&gt;：其他节点监听&lt;code&gt;/members&lt;/code&gt;子节点变化，实时感知节点加入或退出。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Leader选举&lt;/strong&gt;：通过创建临时顺序节点，序号最小者成为领导（如&lt;code&gt;/election/leader_00000001&lt;/code&gt;）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;示例场景&lt;/strong&gt;：Hadoop集群中，主NameNode通过Zookeeper选举产生，DataNode通过临时节点注册状态，主节点实时监控工作节点存活&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;启动zookeeper和客户端&lt;/h2&gt;
&lt;p&gt;1. 启动、(停止、重启)服务&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@hadoop100 zookeeper-3.4.10]$ bin/zkServer.sh start [stop/restart]
[root@hadoop101 zookeeper-3.4.10]$ bin/zkServer.sh start
[root@hadoop102 zookeeper-3.4.10]$ bin/zkServer.sh start
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2. 查看服务状态&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@hadoop100 zookeeper-3.4.10]$ bin/zkServer.sh status
ZooKeeper JMX enabled by default
Using config: /opt/software/zookeeper-3.4.10/bin/../conf/zoo.cfg
Mode: follower
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3. 启动本机客户端&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root @hadoop100 zookeeper-3.4.10]$ bin/zkCli.sh
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4. 启动其他机器的客户端&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root @hadoop100 zookeeper-3.4.10]$ bin/zkCli.sh -server ip地址:端口
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;基本操作&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;命令基本语法&lt;/th&gt;
&lt;th&gt;功能描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;help&lt;/td&gt;
&lt;td&gt;显示所有操作命令&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ls path [watch]&lt;/td&gt;
&lt;td&gt;使用 ls 命令来查看当前znode中所包含的内容&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ls2 path [watch]&lt;/td&gt;
&lt;td&gt;查看当前节点数据并能看到更新次数等数据&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;create&lt;/td&gt;
&lt;td&gt;普通创建   -s  含有序列   -e  临时（重启或者超时消失）   -es 临时顺序&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;get path [watch]&lt;/td&gt;
&lt;td&gt;获得节点的值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;set&lt;/td&gt;
&lt;td&gt;设置节点的具体值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;stat&lt;/td&gt;
&lt;td&gt;查看节点状态&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;delete&lt;/td&gt;
&lt;td&gt;删除节点&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;rmr&lt;/td&gt;
&lt;td&gt;递归删除节点&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;1.  查询当前znode中所包含的内容&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[zk: localhost:2181(CONNECTED) 0] ls /
[zookeeper]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2. 查看当前节点详细数据&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[zk: localhost:2181(CONNECTED) 1] ls2 /
[zookeeper]
cZxid = 0x0
ctime = Thu Jan 01 08:00:00 CST 1970
mZxid = 0x0
mtime = Thu Jan 01 08:00:00 CST 1970
pZxid = 0x0
cversion = -1
dataVersion = 0
aclVersion = 0
ephemeralOwner = 0x0
dataLength = 0
numChildren = 1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3. 创建普通节点&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[zk: localhost:2181(CONNECTED) 3] create /slave &quot;slave online&quot;
Created /slave
[zk: localhost:2181(CONNECTED) 4] create /slave/slave01 &quot;slave01 online&quot;
Created /slave/slave01
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4. 获得节点的值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[zk: localhost:2181(CONNECTED) 6] get /slave/slave01
slave01 online
cZxid = 0x100000004
ctime = Wed Aug 29 00:04:35 CST 2018
mZxid = 0x100000004
mtime = Wed Aug 29 00:04:35 CST 2018
pZxid = 0x100000004
cversion = 0
dataVersion = 0
aclVersion = 0
ephemeralOwner = 0x0
dataLength = 6
numChildren = 0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;5. 创建临时节点（退出客户端或重启后消失）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[zk: localhost:2181(CONNECTED) 7] create -e /slave/slave02 &quot;slave02 online&quot;
Created /slave/slave02
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;6. 创建带序号的节点&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[zk: localhost:2181(CONNECTED) 1] create -s /slave/slave01 &quot;online 01&quot;
Created /slave/slave010000000001
[zk: localhost:2181(CONNECTED) 2] create -s /slave/slave01 &quot;online 01&quot;
Created /slave/slave010000000002
[zk: localhost:2181(CONNECTED) 3] create -s /slave/slave01 &quot;online 01&quot;
Created /slave/slave010000000003
[zk: localhost:2181(CONNECTED) 4] create -s /slave/slave01 &quot;online 01&quot;
Created /slave/slave010000000004
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;如果原来没有序号节点，序号从0开始依次递增。如果原节点下已有2个节点，则再排序时从2开始，以此类推。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;7. 修改节点数据值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[zk: localhost:2181(CONNECTED) 1] set /slave/slave03 &quot;offline&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;8. 监听节点值变化&lt;/p&gt;
&lt;p&gt;(1) Hadoop101注册监听&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[zk: localhost:2181(CONNECTED) 0] get /slave watch
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;(2)Hadoop102修改节点内容&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[zk: localhost:2181(CONNECTED) 0] set /slave &quot;test set&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;(3) 返回Hadoop101查看界面变化提示&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[zk: localhost:2181(CONNECTED) 1]
WATCHER::
WatchedEvent 
state:SyncConnected 
type:NodeDataChanged 
path:/slave/slave01
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;9. 查看节点状态&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[zk: localhost:2181(CONNECTED) 9] stat /slave/slave01
cZxid = 0xa0000002b
ctime = Fri Feb 07 16:48:22 CST 2025
mZxid = 0xa0000002e
mtime = Fri Feb 07 16:50:09 CST 2025
pZxid = 0xa0000002b
cversion = 0
dataVersion = 2
aclVersion = 0
ephemeralOwner = 0x0
dataLength = 13
numChildren = 0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;10. 删除或递归删除节点&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[zk: localhost:2181(CONNECTED) 4] delete /slave/slave01
[zk: localhost:2181(CONNECTED) 4] rmr /slave
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>利用云服务器下载百度网盘资源</title><link>https://minthana.github.io/blog/posts/%E5%88%A9%E7%94%A8%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8B%E8%BD%BD%E7%99%BE%E5%BA%A6%E7%BD%91%E7%9B%98%E8%B5%84%E6%BA%90/</link><guid isPermaLink="true">https://minthana.github.io/blog/posts/%E5%88%A9%E7%94%A8%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8B%E8%BD%BD%E7%99%BE%E5%BA%A6%E7%BD%91%E7%9B%98%E8%B5%84%E6%BA%90/</guid><pubDate>Sat, 18 Jan 2025 13:46:00 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;p&gt;通常下载百度网盘资源大型文件的时候，需要等待长时间。&lt;/p&gt;
&lt;p&gt;利用云服务器挂起进程帮助下载，再转载至本地，可以帮助我们节约部分时间、安排其他活动。&lt;/p&gt;
&lt;p&gt;本篇文章基于阿里云服务器(Linux)，宝塔面板，python，bypy、aria2等工具解决问题&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1&gt;工具简介&lt;/h1&gt;
&lt;p&gt;bypy：是一个Python库和命令行工具，用于与百度云存储服务进行交互。它可以帮助用户在本地电脑和百度网盘之间无缝地传输文件。&lt;/p&gt;
&lt;p&gt;aria2：是一款用于Linux的命令行多协议下载工具，它是一款免费、开源、轻量级的多协议和多源代码命令行下载应用程序。&lt;/p&gt;
&lt;p&gt;Screen：是一个功能强大且灵活的终端窗口管理工具。它允许用户在其内部运行多个独立的会话，这些会话各自拥有编号、输入、输出和窗口缓存。只要Screen本身没有终止，用户就可以随时恢复这些会话。&lt;/p&gt;
&lt;h1&gt;安装python环境&lt;/h1&gt;
&lt;p&gt;参考文章&lt;a href=&quot;https://www.datazzh.top/archives/576/2024/02/02/&quot;&gt;《云服务器搭建jupyter notebook》&lt;/a&gt;步骤2.1，2.2&lt;/p&gt;
&lt;h1&gt;搭建环境&lt;/h1&gt;
&lt;p&gt;1.  搭建、进入虚拟环境&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;conda create -n baidu python=3.8conda activate baidu
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2. 配置环境&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;yum install -y screen   用于进程守护yum install -y aria2    用于下载加速pip install bypy        用于连接百度网盘
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;登录百度网盘&lt;/h1&gt;
&lt;p&gt;1.  输入&lt;strong&gt;bypy info&lt;/strong&gt; 获取API链接授权&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202501/images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2025-01-18-103251.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;2. 点击跳转获取授权码，复制到终端&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202501/images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2025-01-18-103231.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;当显示 &lt;strong&gt;Successfully authorized&lt;/strong&gt; 和网盘存储情况，即为成功&lt;/p&gt;
&lt;h1&gt;配置aria2&lt;/h1&gt;
&lt;p&gt;1.  配置aria2，可以使bypy下载最大化。bypy默认配置的aria2是使用4个连接数下载，修改成最大的16&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;echo &apos;export DOWNLOADER_ARGUMENTS=&quot;-c -k10M -x16 -s16 --file-allocation=none&quot;&apos;&amp;gt;/etc/profile.d/bypy.shsource /etc/profile.d/bypy.sh 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2. 检查是否配置成功&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; echo $DOWNLOADER_ARGUMENTS
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;bypy常用命令&lt;/h1&gt;
&lt;p&gt;bypy默认文件夹为 &lt;strong&gt;/我的应用数据/bypy&lt;/strong&gt; 下，因此只能在此处进行上传与下载。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#不使用aria2下载bypy list # 查看文件夹内容 bypy upload [本地文件地址] [目的地址] # 上传文件bypy downfile [百度网盘文件路径] [目的路径] # 下载文件bypy downdir [百度网盘目录] [目的路径] # 下载文件夹bypy -h # 帮助
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;#使用aria2下载bypy --downloader aria2 download [百度网盘文件路径/百度网盘目录] [目的路径] 
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;Screen挂机下载&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;不使用Screen的话，关闭终端将会导致下载中断，也就达不到挂机下载。&lt;/p&gt;
&lt;p&gt;因此只需要在上述下载步骤之前，加几个步骤即可。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1.  创建&lt;strong&gt;screen&lt;/strong&gt;实例&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; screen -S test # 名字随意
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2. 执行代码和下载任务等操作，例如&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; bypy list&amp;gt; cd dowloadpath/ISO&amp;gt; bypy --downloader aria2 download macOS.iso
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3. 断开连接或关闭终端界面&lt;/p&gt;
&lt;p&gt;4. 打开新连接或新终端界面，查看所有screen&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; screen -lsThere is a screen on:12345.test (Detached)1 Socket in /***/***/***.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;5. 返回进入保存的screen&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;screen -r 12345 或者 screen -r test
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在&lt;strong&gt;screen&lt;/strong&gt;中直接输入exit，可以直接退出当前&lt;strong&gt;screen&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;6. 删除某个screen&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;screen -X -S 12345 quit
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>Jupyter Notebook 切换虚拟环境</title><link>https://minthana.github.io/blog/posts/jupyter-notebook-%E5%88%87%E6%8D%A2%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/</link><guid isPermaLink="true">https://minthana.github.io/blog/posts/jupyter-notebook-%E5%88%87%E6%8D%A2%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/</guid><pubDate>Mon, 11 Nov 2024 16:33:00 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;p&gt;在搭建做不同项目实验过程中，通常建议搭建虚拟环境以此避免不同项目之间依赖包之间的冲突&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1&gt;创建激活虚拟环境&lt;/h1&gt;
&lt;p&gt;打开Anaconda Prompt控制台&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;conda create name python=x.x # name:项目名称 x.x:python版本
conda activate name #激活虚拟环境
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;安装ipykernel&lt;/h1&gt;
&lt;p&gt;复制安装即可&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; conda install ipykernel
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;环境注入Jupyter&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt; python -m ipykernel install --user --name 项目名称 --display-name &quot;在jupyter上显示的环境名称&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;./guide/202411/images//%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2024-11-11-163152.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</content:encoded></item><item><title>Win11+CPU跑Yolov7Demo</title><link>https://minthana.github.io/blog/posts/win11cpu%E8%B7%91yolov7demo/</link><guid isPermaLink="true">https://minthana.github.io/blog/posts/win11cpu%E8%B7%91yolov7demo/</guid><pubDate>Sun, 27 Oct 2024 18:33:00 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;p&gt;最近抽出时间（これはうそだ）去搭建yolov7环境，把踩的坑记录下&lt;/p&gt;
&lt;p&gt;由于电脑配置低，GPU是AMD，不支持CUDA、Rocm所以就只能用CPU跑Yolov7Demo&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1&gt;前言&lt;/h1&gt;
&lt;h2&gt;什么是Yolov7?&lt;/h2&gt;
&lt;p&gt;YOLOv7是YOLO（You Only Look Once）系列目标检测算法的最新版本之一，它是一种实时目标检测算法，能够在极短的时间内准确识别出图像中的各类物体。&lt;/p&gt;
&lt;h2&gt;Yolov7原理&lt;/h2&gt;
&lt;p&gt;YOLOv7沿用了YOLO系列一贯的“分而治之”策略，将图像划分为多个网格，每个网格负责预测其内部的物体。通过一次性扫描整个图像，YOLOv7能够同时预测出物体的位置、类别和置信度，从而实现了快速准确的目标检测。&lt;/p&gt;
&lt;h2&gt;论文&lt;/h2&gt;
&lt;p&gt;论文地址：&lt;strong&gt;&lt;a href=&quot;https://arxiv.org/abs/2207.02696&quot;&gt;https://arxiv.org/abs/2207.02696&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Github代码下载地址：&lt;a href=&quot;https://github.com/WongKinYiu/yolov7&quot;&gt;https://github.com/WongKinYiu/yolov7&lt;/a&gt;&lt;/p&gt;
&lt;h1&gt;搭建Yolov7环境&lt;/h1&gt;
&lt;h2&gt;下载源代码&lt;/h2&gt;
&lt;p&gt;通过Github下载zip格式文件即可&lt;/p&gt;
&lt;h2&gt;环境配置&lt;/h2&gt;
&lt;p&gt;①打开Anaconda Prompt 创建虚拟环境、cd到解压好的yolov7-main（注意：不要将文件解压到中文路径下！！！）文件目录下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;conda create -n yolov7  python=3.8  #创建虚拟环境
conda activate yolov7 #激活进入虚拟环境
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2024-10-27-175907.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2024-10-27-180245.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;②安装所需要的依赖文件（使用pip list可以查看已安装依赖的列表）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; pip install -r requirements.txt -i https://pypi.tuna.tsinghua.edu.cn/simple 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2024-10-27-181353.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;PyCharm选择解释器&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;PyCharm版本选择的是2024，因为之前使用的2020版本存在一些问题&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.quanxiaoha.com/pycharm-pojie/pycharm-pojie-202424.html&quot;&gt;链接：Pycharm 2024.2.4 最新破解版安装教程（附激活码，至2099年~）&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;通过PyCharm打开yolov7-main项目后，修改项目Python解释器&lt;/p&gt;
&lt;p&gt;File - Setting - Project:yolov7-main - Python Interpreter - Add Interpreter 选择Anaconda虚拟环境yolov7的Python解释器&lt;/p&gt;
&lt;p&gt;（在对应anaconda安装目录下的envs/yolov7/python.exe，根据自身情况查看）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2024-10-27-182018.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h1&gt;测试Demo&lt;/h1&gt;
&lt;h2&gt;下载权重&lt;/h2&gt;
&lt;p&gt;测试模型链接下载：&lt;a href=&quot;https://github.com/WongKinYiu/yolov7/releases/download/v0.1/yolov7.pt&quot;&gt;&lt;code&gt;yolov7.pt&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://github.com/WongKinYiu/yolov7/releases/download/v0.1/yolov7x.pt&quot;&gt;&lt;code&gt;yolov7x.pt&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://github.com/WongKinYiu/yolov7/releases/download/v0.1/yolov7-w6.pt&quot;&gt;&lt;code&gt;yolov7-w6.pt&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://github.com/WongKinYiu/yolov7/releases/download/v0.1/yolov7-e6.pt&quot;&gt;&lt;code&gt;yolov7-e6.pt&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://github.com/WongKinYiu/yolov7/releases/download/v0.1/yolov7-d6.pt&quot;&gt;&lt;code&gt;yolov7-d6.pt&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://github.com/WongKinYiu/yolov7/releases/download/v0.1/yolov7-e6e.pt&quot;&gt;&lt;code&gt;yolov7-e6e.pt&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下载以上的权重之一（Github原文中也有）并保存在项目文件的根目录中&lt;/p&gt;
&lt;p&gt;打开detect.py文件，根据刚刚下载的文件名称修改如下（以yolov7x.pt为例)&lt;/p&gt;
&lt;p&gt;测试文件为images文件下的图片；跑出结果将在runs/detect/exp文件下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2024-10-27-182543.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;一切准备就绪就可以run了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/bus.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/horses.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</content:encoded></item><item><title>英语零基础语法知识</title><link>https://minthana.github.io/blog/posts/%E8%8B%B1%E8%AF%AD%E9%9B%B6%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E7%9F%A5%E8%AF%86/</link><guid isPermaLink="true">https://minthana.github.io/blog/posts/%E8%8B%B1%E8%AF%AD%E9%9B%B6%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E7%9F%A5%E8%AF%86/</guid><pubDate>Tue, 27 Aug 2024 16:02:00 GMT</pubDate><content:encoded>&lt;h1&gt;语序和五种基本句式&lt;/h1&gt;
&lt;h2&gt;基本概念&lt;/h2&gt;
&lt;p&gt;主语Subject：主体&lt;/p&gt;
&lt;p&gt;谓语Verb：主体执行的动作&lt;/p&gt;
&lt;p&gt;表语：描述主语的性质特点、位置的词&lt;/p&gt;
&lt;p&gt;系动词：联系作用的动词，连接前面的主语和后面的表语&lt;/p&gt;
&lt;p&gt;宾语Object：动作支配的对象&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;直接宾语&lt;/strong&gt;紧跟在及物动词后面，表示动作的直接承受者或者结果。通常指物&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;间接宾语&lt;/strong&gt;用来表示动作的接收者或受益者，通常出现在直接宾语之前。通常指人&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;宾语补足语：补充说明；当宾语不能完全说明谓语执行对象&lt;/p&gt;
&lt;h2&gt;基本句式&lt;/h2&gt;
&lt;p&gt;1.  主语S + 谓语V&lt;/p&gt;
&lt;p&gt;The universe remains  宇宙长存&lt;/p&gt;
&lt;p&gt;2. 主语 + 系动词L.V + 表语P&lt;/p&gt;
&lt;p&gt;The food is delicious  这个食物很好吃&lt;/p&gt;
&lt;p&gt;3. 主语 + 谓语 + 宾语&lt;/p&gt;
&lt;p&gt;He took his bag and left  他拿着书包离开了&lt;/p&gt;
&lt;p&gt;4. 主语 + 谓语 + I.O间接宾语 + D.O&lt;/p&gt;
&lt;p&gt;Her father bought her a dictionary  他爸爸给她买了一本词典&lt;/p&gt;
&lt;p&gt;5. 主语 + 谓语 + 宾语 + 宾补&lt;/p&gt;
&lt;p&gt;We made him our monitor  我们选他当班长&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;除此之外还有：倒装句、副词、提前句、复杂长句等学习&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1&gt;be动词形式用法&lt;/h1&gt;
&lt;h2&gt;八种be动词&lt;/h2&gt;
&lt;p&gt;be、being、been、is、am、are、was、were&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一般现在时时态：is、am、are&lt;/li&gt;
&lt;li&gt;过去时时态：was、were&lt;/li&gt;
&lt;li&gt;be的现在与过去分词：being、been&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;eg.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The man is back&lt;/li&gt;
&lt;li&gt;The are back&lt;/li&gt;
&lt;li&gt;He was back&lt;/li&gt;
&lt;li&gt;They were back&lt;/li&gt;
&lt;li&gt;THey have been back  他们已经回来了（现在完成时时态）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;用法&lt;/h2&gt;
&lt;p&gt;后面接名词、形容词、地点副词或短语作为补足词&lt;/p&gt;
&lt;p&gt;eg.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The man is a teacher&lt;/li&gt;
&lt;li&gt;Mary&apos;s new dresses are colorful&lt;/li&gt;
&lt;li&gt;My mother was in the kitchen&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;be动词的否定/提问/回答&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;一般形式&lt;/th&gt;
&lt;th&gt;缩略形&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;am not&lt;/td&gt;
&lt;td&gt;am not&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;is not&lt;/td&gt;
&lt;td&gt;isn&apos;t&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;are not&lt;/td&gt;
&lt;td&gt;aren&apos;t&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;was not&lt;/td&gt;
&lt;td&gt;wasn&apos;t&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;were not&lt;/td&gt;
&lt;td&gt;weren&apos;t&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;①eg.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The man isn&apos;t back&lt;/li&gt;
&lt;li&gt;I am not back&lt;/li&gt;
&lt;li&gt;They aren&apos;t back&lt;/li&gt;
&lt;li&gt;He wasn&apos;t back&lt;/li&gt;
&lt;li&gt;They weren&apos;t back&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;②eg.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Is he a teacher? - Yes,he is / No,he isn&apos;t&lt;/li&gt;
&lt;li&gt;Are you a teacher? - Yes,I am / No,I am not&lt;/li&gt;
&lt;li&gt;Were they tachers? - Yes,they were / No,they weren&apos;t&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;代词&lt;/h1&gt;
&lt;p&gt;代词就是代替人或事物的名词，通常有主格、宾格区分&lt;/p&gt;
&lt;p&gt;主格：人称代词，在句子中充当主语的成分，放在动词前；&lt;/p&gt;
&lt;p&gt;宾格：人称代词，在句子中充当宾语的成分，放在动词后。&lt;/p&gt;
&lt;h2&gt;主格代词&lt;/h2&gt;
&lt;p&gt;I、he、she、it、you、we、they&lt;/p&gt;
&lt;p&gt;eg.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;I am a teacher&lt;/li&gt;
&lt;li&gt;He is a teacher&lt;/li&gt;
&lt;li&gt;You are teachers&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;宾格代词&lt;/h2&gt;
&lt;p&gt;me、him、her、it、you、us、them&lt;/p&gt;
&lt;p&gt;eg.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;He likes me&lt;/li&gt;
&lt;li&gt;We like her&lt;/li&gt;
&lt;li&gt;I like them&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;物主代词&lt;/h2&gt;
&lt;p&gt;物主代词：物的主人所用的代替名词&lt;/p&gt;
&lt;h3&gt;形容性&lt;/h3&gt;
&lt;p&gt;形容性物主代词：修饰名词成分&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单数形式：my、your、his/her/its、one&apos;s&lt;/li&gt;
&lt;li&gt;复数形式：our、your、their&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;eg.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;This is my book&lt;/li&gt;
&lt;li&gt;We love our motherland&lt;/li&gt;
&lt;li&gt;Those are your socks&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;名词性&lt;/h3&gt;
&lt;p&gt;名词性物主代词：独立作为名词成分&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单数形式：mine、yours、his/hers/its、one&apos;s&lt;/li&gt;
&lt;li&gt;复数形式：ours、yours、theirs&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;eg.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The book is ours&lt;/li&gt;
&lt;li&gt;The apple is hers&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;主格&lt;/th&gt;
&lt;th&gt;宾格&lt;/th&gt;
&lt;th&gt;形容词性物主代词&lt;/th&gt;
&lt;th&gt;名词性物主代词&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;I&lt;/td&gt;
&lt;td&gt;me&lt;/td&gt;
&lt;td&gt;my&lt;/td&gt;
&lt;td&gt;mine&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;He&lt;/td&gt;
&lt;td&gt;him&lt;/td&gt;
&lt;td&gt;his&lt;/td&gt;
&lt;td&gt;his&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;She&lt;/td&gt;
&lt;td&gt;her&lt;/td&gt;
&lt;td&gt;her&lt;/td&gt;
&lt;td&gt;hers&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;It&lt;/td&gt;
&lt;td&gt;it&lt;/td&gt;
&lt;td&gt;its&lt;/td&gt;
&lt;td&gt;its&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;You&lt;/td&gt;
&lt;td&gt;you&lt;/td&gt;
&lt;td&gt;your&lt;/td&gt;
&lt;td&gt;yours&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;We&lt;/td&gt;
&lt;td&gt;us&lt;/td&gt;
&lt;td&gt;our&lt;/td&gt;
&lt;td&gt;ours&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;They&lt;/td&gt;
&lt;td&gt;them&lt;/td&gt;
&lt;td&gt;their&lt;/td&gt;
&lt;td&gt;theirs&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;反身代词&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;myself、yourself、herself、himself、itself&lt;/li&gt;
&lt;li&gt;yourselves、ourselves、themselves&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;eg.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Please help yourself to some fish&lt;/li&gt;
&lt;li&gt;We enjoyed ourselves last night&lt;/li&gt;
&lt;li&gt;They thing inself is not important&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;指示代词&lt;/h2&gt;
&lt;p&gt;指示代词：标识人或事物的代词，用来代替前面已经提到过的名词&lt;/p&gt;
&lt;p&gt;this(these)这个/这些、that(those) 那个/那些&lt;/p&gt;
&lt;p&gt;eg.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;This is his book&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;不定代词&lt;/h2&gt;
&lt;p&gt;不定代词：指代不确定的人或事物&lt;/p&gt;
&lt;p&gt;one、the other、some、any、something、nothing&lt;/p&gt;
&lt;p&gt;eg.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;No one knows where he is.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;实意动词&lt;/h1&gt;
&lt;h2&gt;特征&lt;/h2&gt;
&lt;p&gt;come、read、go、watch、play、fly&lt;/p&gt;
&lt;p&gt;eg.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;He comes from Shenyang&lt;/li&gt;
&lt;li&gt;She is reading story books&lt;/li&gt;
&lt;li&gt;They went to America yesterday&lt;/li&gt;
&lt;li&gt;We have watched the game for three times&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;实意动词的否定/提问/回答&lt;/h2&gt;
&lt;p&gt;&amp;lt;figure&amp;gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;一般形式&lt;/th&gt;
&lt;th&gt;缩略形式&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;do not&lt;/td&gt;
&lt;td&gt;don&apos;t&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;does not&lt;/td&gt;
&lt;td&gt;doesn&apos;t&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;did not&lt;/td&gt;
&lt;td&gt;didn&apos;t&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&amp;lt;figcaption&amp;gt;&lt;/p&gt;
&lt;p&gt;使用助动词进行否定&lt;/p&gt;
&lt;p&gt;&amp;lt;/figcaption&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;/figure&amp;gt;&lt;/p&gt;
&lt;p&gt;①eg.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;I don&apos;t go to school by bus&lt;/li&gt;
&lt;li&gt;She doesn&apos;t watch TV everyday&lt;/li&gt;
&lt;li&gt;They didn&apos;t swim last night&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;②eg.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Does he often play golf? - Yes,he does / NO,he doesn&apos;t&lt;/li&gt;
&lt;li&gt;Do they go to school by bus? - Yes,they do / No,they don&apos;t&lt;/li&gt;
&lt;li&gt;Did Sam have breakfast yesterday? - Yes,he did / No,he didn&apos;t&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;使用疑问词进行提问回答&lt;/h1&gt;
&lt;p&gt;1.  When、Where、Who、What、How&lt;/p&gt;
&lt;p&gt;eg. He bought three books yesterday.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Who bought three books yesterday?&lt;/li&gt;
&lt;li&gt;What did he buy yesterday?&lt;/li&gt;
&lt;li&gt;When did he buy three books?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2. How long、How far、How often、Why&lt;/p&gt;
&lt;p&gt;eg. They have been in China for three years.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;How long have they been in China?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;eg. It is about 4 kilometers from Beijing to Xi&apos;an&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;How far it is from Beijing to XI&apos;an?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;eg. They come to visit me once a week.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;How often do they come to visit you?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;eg. She came late, because she missed the bus.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Why did she come late?&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;名词&lt;/h1&gt;
&lt;p&gt;可数名词countable noun：数的过来的概念；有单复数之分&lt;/p&gt;
&lt;p&gt;不可数名词uncountable noun：无法计数的抽象概念；无复数形式&lt;/p&gt;
&lt;h2&gt;名词变复数规则&lt;/h2&gt;
&lt;p&gt;&amp;lt;figure&amp;gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;一般末尾加上s&lt;/th&gt;
&lt;th&gt;friend -&amp;gt;friends&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;s、z、x、ch、sh结尾，末尾加es&lt;/td&gt;
&lt;td&gt;bus -&amp;gt; buses&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;辅音字母+y结尾，y变i+es&lt;/td&gt;
&lt;td&gt;candy -&amp;gt; candies&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;o结尾，如果不是外来词或缩写就加es&lt;/td&gt;
&lt;td&gt;tomato -&amp;gt; tomatoes&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&amp;lt;figcaption&amp;gt;&lt;/p&gt;
&lt;p&gt;名词变复数规则&lt;/p&gt;
&lt;p&gt;&amp;lt;/figcaption&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;/figure&amp;gt;&lt;/p&gt;
&lt;h2&gt;量词&lt;/h2&gt;
&lt;p&gt;①可数名词前&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;元音（a、i、u、e、o）开头 + an   &lt;em&gt;[an apple]&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;辅音（除去元音的其他字母）开头 + a&lt;/li&gt;
&lt;li&gt;加其他量词  _[_&lt;em&gt;a box of apples]&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;②不可数名词不加 a/an，可加量词  &lt;em&gt;[a cap of coffee]&lt;/em&gt;&lt;/p&gt;
&lt;h1&gt;形容词&lt;/h1&gt;
&lt;p&gt;1. 形容词通常形容人或事物的状态、性质、大小等&lt;/p&gt;
&lt;p&gt;通常用在名词前，be动词之后&lt;/p&gt;
&lt;p&gt;eg.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The beautiful girl.&lt;/li&gt;
&lt;li&gt;The girl is beautiful.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2. The + 形容词 = 复数名词，表示一类，后面的动词使用复数&lt;/p&gt;
&lt;p&gt;eg.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The old need more care than The young.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;副词&lt;/h1&gt;
&lt;p&gt;副词可以修饰动词、形容词、其他副词以及其他结构&lt;/p&gt;
&lt;p&gt;eg.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;He runs fast.&lt;/li&gt;
&lt;li&gt;She is very beautiful.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;副词位置&lt;/p&gt;
&lt;p&gt;1. 助动词之后，实意动词之前或之后&lt;/p&gt;
&lt;p&gt;2.形容词之前，其他副词之前或之后&lt;/p&gt;
&lt;p&gt;3.多个助动词时，副词一般放在第一个助动词之后&lt;/p&gt;
&lt;p&gt;eg.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;He speaks very fast.&lt;/li&gt;
&lt;li&gt;They have already left.&lt;/li&gt;
&lt;li&gt;They have already been repaired.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;不定量表达法&lt;/h1&gt;
&lt;p&gt;不定量表达法就是不确定数量的表达法&lt;/p&gt;
&lt;h2&gt;some、any、most、every、all&lt;/h2&gt;
&lt;p&gt;1. some、any都表示“一些”，&lt;strong&gt;some主要用于肯定句&lt;/strong&gt;，希望得到肯定回答，也可以用在疑问句中，&lt;strong&gt;any主要用于否定和疑问句中&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;I&apos;d been expecting &lt;strong&gt;some&lt;/strong&gt; letters the whole moring,but there weren&apos;t &lt;strong&gt;any&lt;/strong&gt; for me.&lt;/li&gt;
&lt;li&gt;我整个上午都在等一些信，但没有任何给我的&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2. most作形容词时表示大部分的，后面接复数名词&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Most&lt;/strong&gt; people here are from China.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;3. every表示“每一个，所有”后面接单数名词&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Every one likes the film.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;4.  all表示&quot;所有&quot;，后面接可数名词复数，不可数名词单数。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;All the cars are parked in the parking lot.&lt;/li&gt;
&lt;li&gt;All the coffee is served on time.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;both、either、neither&lt;/h2&gt;
&lt;p&gt;both表示两者都，可作形容词，代词和副词， either是两者之一， neither是两者都不。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Both&lt;/strong&gt; his eyes were severely burned&lt;/li&gt;
&lt;li&gt;There are trees on &lt;strong&gt;either&lt;/strong&gt; side of the street.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Neither&lt;/strong&gt; answer is correct&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;many、mach、a lot of、plenty of&lt;/h2&gt;
&lt;p&gt;many 修饰可数名词，表示&quot;许多&quot;,much修饰不可数名词，表示&quot;许多&quot;。&lt;/p&gt;
&lt;p&gt;a lot of[lots of], plenty of均可修饰可数和不可数名词&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;many books、much water&lt;/li&gt;
&lt;li&gt;a lot of/lots of books/water&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;a few、few&lt;/h2&gt;
&lt;p&gt;a few：为肯定含义&quot;几个&quot;&lt;/p&gt;
&lt;p&gt;few：为否定含义&quot;没几个&quot;，以上两个词均和可数名词连用。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;A few&lt;/strong&gt; books are put into the box&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Few&lt;/strong&gt; books are put into the box&lt;/li&gt;
&lt;/ul&gt;
</content:encoded></item><item><title>R语言数据分析与可视化</title><link>https://minthana.github.io/blog/posts/r%E8%AF%AD%E8%A8%80%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E5%8F%AF%E8%A7%86%E5%8C%96/</link><guid isPermaLink="true">https://minthana.github.io/blog/posts/r%E8%AF%AD%E8%A8%80%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E5%8F%AF%E8%A7%86%E5%8C%96/</guid><pubDate>Sat, 10 Aug 2024 17:26:00 GMT</pubDate><content:encoded>&lt;h1&gt;R语言概述&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;R是属于GNU系统的一个自由、免费、源代码开放的软件，它是用于数据分析和可视化的软件功能的集成套件，是一个用于统计计算和统计制图的优秀工具。它可以在各种UNIX平台、Windows和MacOS上编译并运行。 R是统计领域广泛使用的诞生于1980年左右的S语言的一个分支，R是一个类似于S语言的GNU项目，可以将R视为S的不同实现，该项目是由约翰·钱伯斯及其同事在AT＆T贝尔实验室开发的。R与S一样，都是围绕一种真正的计算机语言设计的，它允许用户通过定义新功能来添加其他功能。系统的大部分本身是用S的R语言编写的，这使用户可以轻松地遵循所选择的算法。对于计算量大的任务，可以在运行时链接和调用C，C ++和Fortran代码。高级用户可以编写C代码来直接操纵R对象。R和S存在一些区别，但是用S编写的许多代码在R的环境下都不会改变。S语言通常是统计方法论研究的首选工具，R语言提供了一种开放源代码的途径来参与该活动。&lt;/li&gt;
&lt;li&gt;R可以轻松制作出精心设计的具有出版质量的图表，其中包括需要的数学符号和公式。R提供了各种各样的统计信息（线性和非线性建模，经典统计检验，时间序列分析，分类，聚类等等）和图形技术，并且具有高度的可扩展性。许多用户将R视为统计软件，其实可以将R视为实现统计技术的环境。R可以通过包轻松扩展。R发行版提供了大约八种软件包，并且CRAN系列Internet网站还提供了更多软件包，涵盖了非常广泛的现代统计数据。R有自己的类似LaTeX的文档格式，可用于提供全面的文档，既可以在线使用多种格式，也可以使用硬拷贝。&lt;/li&gt;
&lt;li&gt;R是一个自由的、免费的、开源的软件。&lt;/li&gt;
&lt;li&gt;R可以轻松地从各种类型的数据源导入数据库，包括文本文件、数据库管理系统、统计软件，乃至专门的数据仓库。它同样可以将数据输出并写入这些系统中。&lt;/li&gt;
&lt;li&gt;R可以在Windows、UNIX、Mac OS X和Linux等多种平台上运行。&lt;/li&gt;
&lt;li&gt;R拥有强大的制图功能，提供了丰富的2D和3D图形库，能够生成从简单到复杂的各种图形。&lt;/li&gt;
&lt;li&gt;R更新迅速，囊括了许多先进的统计计算和前沿的统计方法。事实上，新方法的更新速度是以周来计算的，这是大多数统计软件达不到的。&lt;/li&gt;
&lt;li&gt;R可以连接到其他的高性能编程语言，如C++、Python、SAS和SPSS等。这样你可以在熟悉的语言编程环境中加入R的功能。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1&gt;R的基本使用&lt;/h1&gt;
&lt;h2&gt;赋值操作&lt;/h2&gt;
&lt;p&gt;在R语言中，标准赋值运算符是“&amp;lt;-”，并非传统的“=”。R语言也允许使用“=”为对象赋值，不过并不建议使用它。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; x&amp;lt;-0:10 #创建一个等差数列向量 
&amp;gt; x 
[1] 0 1 2 3 4 5 6 7 8 9 10
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;区分大小写&lt;/h3&gt;
&lt;p&gt;R语言对大小写很敏感，即X和x的含义是不同的，同一字母的大小写代表不同的变量对象。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; x&amp;lt;-1:10 
&amp;gt; X 错误: 找不到对象&apos;X&apos; 
&amp;gt; x 
[1] 1 2 3 4 5 6 7 8 9 10
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;‘+’提示符&lt;/h2&gt;
&lt;p&gt;当输入命令没有完整前，R会以“+”作为提示符，提醒用户该命令还未结束。这时，将命令输入完整，则提示符会变成“&amp;gt;”。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; x&amp;lt;-10- 
+ 
+ 2 
&amp;gt; x 
[1] 8
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;示例&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;images/Capture_20240810_151849.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;x&amp;lt;-c(3.4,1.8,4.6,2.3,3.1,5.5,0.7,3.0,2.6,4.3,2.1,1.1,6.1,4.8,3.8)
&amp;gt;y&amp;lt;-c(26.2,17.8,31.3,23.1,27.5,36.0,14.1,22.3,
+19.6,31.3,24.0,17.3, 43.2,36.4,26.1)
&amp;gt;mean(y)  #mean()函数求取均值
[1] 26.41333
&amp;gt;sd(y)   #sd()函数求取方差
[1]8.068976
&amp;gt;cor(x, y)  #cor()函数计算相关系数
[1] 0.9609777
&amp;gt;plot (x,y)  #plot()绘制散点图
&amp;gt;q()  #函数q()结束会话并允许退出R语言
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;images/Capture_20240810_151905.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;从代码中可以看到，火灾损失的平均费用为26.413元，标准差为8.069元，火灾发生地&lt;br /&gt;
离消防站距离与火灾损失之间存在较强的线性关系（相关度为0.96)。这种关系也可以通过散点图看出来，即火灾地离消防站越远，所造成的火灾损失费用就会越高&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;输入与输出&lt;/h2&gt;
&lt;p&gt;启动R软件后将默认开始一个交互式的会话，从键盘接受输入并从屏幕进行输出。也可以处理写在一个脚本文件（一个包含了R语句的文件）中的命令集并直接将结果输出到多类目标中。&lt;/p&gt;
&lt;p&gt;1.输入&lt;/p&gt;
&lt;p&gt;函数source(&quot;filename&quot;）可在当前会话中执行一个脚本。如果文件名中不包含路径，R 语言将假设此脚本在当前工作目录中。举例来说，source(&quot;myscript.R&quot;）将执行包含在文件myscript.R中的R语句集合&lt;/p&gt;
&lt;p&gt;2.文本输出&lt;/p&gt;
&lt;p&gt;函数sink(&quot;filename&quot;）将输出重定向到文件filename中。默认情况下，如果文件已经存在，则它的内容将被覆盖。使用参数append=TRUE 可以将文本追加到文件后，而不是覆盖它。参数split=TRUE 可将输出同时发送到屏幕和输出文件中。不加参数调用命令sink(）将仅向屏幕返回输出结果。&lt;/p&gt;
&lt;p&gt;3.图形输出&lt;/p&gt;
&lt;p&gt;虽然sink(）可以重定向文本输出，但它对图形输出没有影响。要重定向图形输出，使用表1-4中列出的函数即可，最后使用dev.off(）将输出返回到终端&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/Capture_20240810_152610.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h1&gt;分支语句&lt;/h1&gt;
&lt;h2&gt;if语句&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;if、if...else...、else if&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; #if语句
&amp;gt; print(&quot;请输入您的心率值（单位：次/分）：&quot;)
[1] &quot;请输入您的心率值（单位：次/分）：&quot;
&amp;gt; value&amp;lt;-scan()
1: 100
2: 
Read 1 item
&amp;gt; if(value&amp;gt;=60&amp;amp;value&amp;lt;=100){print(&quot;正常值&quot;)}else{print(&quot;异常值，请监测心率&quot;)}
[1] &quot;正常值&quot;
&amp;gt; print(&quot;请输入您的血压测量值（单位：mmHg），收缩压（SBP）和舒张压（DBP）为：&quot;)
[1] &quot;请输入您的血压测量值（单位：mmHg），收缩压（SBP）和舒张压（DBP）为：&quot;
&amp;gt; value&amp;lt;-scan()
1: 100 150
3: 
Read 2 items
&amp;gt; if(value[1]&amp;lt;120&amp;amp;value[2]&amp;lt;80){print(&quot;正常值&quot;)}else
+ if(value[1]&amp;lt;140&amp;amp;value[2]&amp;lt;90){print(&quot;正常高值&quot;)}else
+ {print(&quot;高血压&quot;)}
[1] &quot;高血压&quot;
&amp;gt; #向量化的逻辑表达式
&amp;gt; y&amp;lt;-c(3,8)
&amp;gt; fruit&amp;lt;-10*y
&amp;gt; fruit&amp;lt;-fruit*ifelse(y&amp;gt;5,0.9,1)
&amp;gt; fruit
[1] 30 72
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;switch语句&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; #switch语句
&amp;gt; switch(2,mean(1:10),sum(1:10),max(1:10),min(1:10)) #执行数字对应表达式
[1] 55
&amp;gt; switch(2*2,mean(1:10),sum(1:10),max(1:10),min(1:10))
[1] 1&amp;gt; pra&amp;lt;-switch(&quot;gamma&quot;,alpha=1,beta=sqrt(4),gamma={a&amp;lt;-sin(pi/2);4*a^2})
&amp;gt; pra
[1] 4&amp;gt; you.like&amp;lt;-&apos;eat&apos;
&amp;gt; out&amp;lt;-switch(you.like,drink=&apos;water&apos;,meat=&apos;beef&apos;,fruit=&apos;apple&apos;,vegetable=&apos;cabbage&apos;)
&amp;gt; out
NULL
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;循环语句&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; #循环语句
&amp;gt; repeat{
+     message(&quot;请投骰子！&quot;)
+     action&amp;lt;-sample(1:6,1)
+     message(&quot;action=&quot;,action)
+     if(action==&quot;6&quot;) break
+ }
请投骰子！
action=4
请投骰子！
action=6
&amp;gt; repeat{
+     message(&quot;BMI index!&quot;)
+     bmi&amp;lt;-sample(c(18.5,24,28,32),1)
+     if(bmi==18.5){
+         message(&quot;Quietly skipping to the next iteration&quot;)
+         next
+     }
+     message(&quot;BMI=&quot;,bmi)
+     if(bmi==32) break
+ }
BMI index!
BMI=32&amp;gt; i&amp;lt;-1
&amp;gt; sum&amp;lt;-0
&amp;gt; repeat{
+     sum = sum+i
+     i = i+1
+     if(i&amp;gt;100){
+         print(sum)
+         break
+     }
+ }
[1] 5050
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;While语句&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; #while语句
&amp;gt; action&amp;lt;-sample(1:6,1)
&amp;gt; message(&quot;action=&quot;,action)
action=3
&amp;gt; while(action!=&quot;6&quot;){
+ message(&quot;please continue...&quot;)
+ action&amp;lt;-sample(1:6,1)
+ message(&quot;action=&quot;,action)
+ }
please continue...
action=3
please continue...
action=5
please continue...
action=4
please continue...
action=6
&amp;gt; message(&quot;Game over!&quot;)
Game over!
&amp;gt; i&amp;lt;-1
&amp;gt; sum&amp;lt;-0
&amp;gt; while(i&amp;lt;=100){sum=sum+i;i=i+1}
&amp;gt; print(sum)
[1] 5050
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;for循环&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; #for循环语句
&amp;gt; n&amp;lt;-c(2,5,10)
&amp;gt; for(i in n){
+ x&amp;lt;-i^2
+ cat(&apos;power(&apos;,i,&apos;):&apos;,x,&apos;\n&apos;)
+ }
power( 2 ): 4 
power( 5 ): 25 
power( 10 ): 100 
&amp;gt; n&amp;lt;-5
&amp;gt; x&amp;lt;-array(0,dim=c(n,n))
&amp;gt; for(i in 1:n){
+ for(j in 1:n){
+ x[i,j]&amp;lt;-1/(i+j-1)
+ }
+ }
&amp;gt; 
&amp;gt; print(x)
[,1] [,2] [,3] [,4] [,5]
[1,] 1.0000000 0.5000000 0.3333333 0.2500000 0.2000000
[2,] 0.5000000 0.3333333 0.2500000 0.2000000 0.1666667
[3,] 0.3333333 0.2500000 0.2000000 0.1666667 0.1428571
[4,] 0.2500000 0.2000000 0.1666667 0.1428571 0.1250000
[5,] 0.2000000 0.1666667 0.1428571 0.1250000 0.1111111

#replication高级循环

&amp;gt; bmi_fun&amp;lt;-function(){
+     bmi&amp;lt;-sample(
+         c(&apos;fat&apos;,&apos;weight&apos;, &apos;normal&apos;,&apos;light&apos;),
+         size=1,
+         prob=c(0.1,0.3,0.4,0.2)
+     )
+     
+     time&amp;lt;-switch (
+         bmi,
+         fat=rnorm(1,32,5),##rnorm正态分布（个数，均值，标准差)
+         weight=rnorm(1,28,3),
+         normal=rnorm(1,24,3),
+         light=rnorm(1,18.5,2)
+     )
+     
+     names(time)
+     time
+ }
&amp;gt; replicate(3,bmi_fun())
[1] 21.19540 24.39278 15.58931
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;自定义函数&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; plot.f&amp;lt;-function(f,a,b){val&amp;lt;-seq(a,b,length=100);plot(val,f(val))}
&amp;gt; plot.f(sin,0,2*pi)
&amp;gt; plot.f(cos,0,2*pi)

&amp;gt; vms&amp;lt;-function(x){
+ xx=rev(sort(x))
+ xx=xx[1:5]
+ mean(xx)
+ return(list(xba=mean(xx),top5=xx))
+ }
&amp;gt; x&amp;lt;-c(3,9,1,4,7,5,3)
&amp;gt; vms(x)
$xba
[1] 5.6
$top5
[1] 9 7 5 4 3
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;数据集&lt;/h1&gt;
&lt;p&gt;数据集通常是由数据构成的一个矩形数组，行表示观测，列表示变量。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/Capture_20240810_152811.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;数据类型&lt;/h2&gt;
&lt;p&gt;R语言中，可以处理的数据类型有&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数值型 numeric&lt;/li&gt;
&lt;li&gt;字符型 character&lt;/li&gt;
&lt;li&gt;逻辑型 logical&lt;/li&gt;
&lt;li&gt;复数型 （虚数）&lt;/li&gt;
&lt;li&gt;原生型 （字节）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如上图表2-1中，patientID、admDate和age为数值型变量，而diabetes和status则为字符型变量。如果再细分一下：patientID是实例标识符，admDate含有日期数据，diabetes和status分别是名义型和有序型变量。&lt;strong&gt;R语言将实例标识符称为rownames （行名），将类别型（包括名义型和有序型）变量称为因子（factors)。&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;数据结构&lt;/h2&gt;
&lt;p&gt;R语言中提供了多种存储数据的对象类型，包括&lt;strong&gt;标量&lt;/strong&gt;（R语言中的标量是由向量的形式表达，即只含一个元素的向量，多用于存储常量，可以说R语言中没有标量）、&lt;strong&gt;向量、矩阵、数组、数据框、列表&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;向量&lt;/h3&gt;
&lt;h4&gt;声明&lt;/h4&gt;
&lt;p&gt;定义：向量是用于存储数值型、字符型或逻辑型数据的&lt;strong&gt;一维数组&lt;/strong&gt;。单个向量中的数据必须&lt;strong&gt;保持相同的类型或模式&lt;/strong&gt;（数值型、字符型或逻辑型）&lt;/p&gt;
&lt;p&gt;创建方法：&lt;strong&gt;常见创建函数为c()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;其他函数方法：查看数据类型用mode()、查看向量长度length()&lt;/p&gt;
&lt;h4&gt;创建向量&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;a&amp;lt;-c(1,3,5,6,2,4,9)
&amp;gt;a
[1]1 3 5 6 2 4 9
&amp;gt;b&amp;lt;-c(&quot;A&quot;,&quot;B&quot;, &quot;C&quot;) #使用c函数创建向量
&amp;gt;c&amp;lt;-c(TRUE, TRUE, FALSE,TRUE)
&amp;gt;mode(a)
[1] &quot;numeric&quot;
&amp;gt;mode(b)
[1]&quot;character&quot;
&amp;gt;mode(c)
[1]&quot;logical&quot;

&amp;gt;x&amp;lt;-12:60  #使用冒号创建向量
&amp;gt;x
[1] 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35
[25] 36 3738 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59
[49] 60
&amp;gt;length(x)
[1] 49
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;seq()函数&lt;/h5&gt;
&lt;p&gt;可以生成等差序列、实数序列，并且可以指定步长&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#格式一：seq(from=value1,to=value2,by=value3)
&amp;gt; seq(1,5,0.5)
[1] 1.0 1.5 2.0 2.5 3.0 3.5 4.0 4.5 5.0

#格式二：seq(length=value1,from=value2,by=value3)
&amp;gt; seq(length=9,from=1,by=0.5) [1] 1.0 1.5 2.0 2.5 3.0 3.5 4.0 4.5 5.0
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;rep()函数&lt;/h5&gt;
&lt;p&gt;创建重复元素的向量&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; rep(1,10)
 [1] 1 1 1 1 1 1 1 1 1 1
&amp;gt; rep(1:5,2)
 [1] 1 2 3 4 5 1 2 3 4 5
&amp;gt; rep(c(&quot;male&quot;,&quot;female&quot;),5)
 [1] &quot;male&quot;   &quot;female&quot; &quot;male&quot;   &quot;female&quot; &quot;male&quot;   &quot;female&quot; &quot;male&quot;  
 [8] &quot;female&quot; &quot;male&quot;   &quot;female&quot;
&amp;gt; rep(c(&quot;male&quot;,&quot;female&quot;),each=5)
 [1] &quot;male&quot;   &quot;male&quot;   &quot;male&quot;   &quot;male&quot;   &quot;male&quot;   &quot;female&quot;
 [7] &quot;female&quot; &quot;female&quot; &quot;female&quot; &quot;female&quot;
&amp;gt; rep(c(&quot;S&quot;,&quot;M&quot;,&quot;L&quot;),c(2,3,4))
[1] &quot;S&quot; &quot;S&quot; &quot;M&quot; &quot;M&quot; &quot;M&quot; &quot;L&quot; &quot;L&quot; &quot;L&quot; &quot;L&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;sequence()函数&lt;/h5&gt;
&lt;p&gt;创建一个连续的整数序列，每一个序列都以给定参数结尾&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; sequence(4:5)
[1] 1 2 3 4 1 2 3 4 5
&amp;gt; sequence(c(10,5))
 [1]  1  2  3  4  5  6  7  8  9 10  1  2  3  4  5
&amp;gt; sequence(c(1,10))
 [1]  1  1  2  3  4  5  6  7  8  9 10
&amp;gt; sequence(4:5)
[1] 1 2 3 4 1 2 3 4 5
&amp;gt; sequence(c(10,5))
 [1]  1  2  3  4  5  6  7  8  9 10  1  2  3  4  5
&amp;gt; sequence(c(1:10))
 [1]  1  1  2  1  2  3  1  2  3  4  1  2  3  4  5  1  2  3  4  5
[21]  6  1  2  3  4  5  6  7  1  2  3  4  5  6  7  8  1  2  3  4
[41]  5  6  7  8  9  1  2  3  4  5  6  7  8  9 10
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;类型转换&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; as.numeric(FALSE)
[1] 0
&amp;gt; as.numeric(TRUE)
[1] 1
&amp;gt; as.numeric(&quot;1&quot;)
[1] 1
&amp;gt; as.numeric(&quot;0&quot;)
[1] 0
&amp;gt; as.numeric(&quot;A&quot;)
[1] NA&amp;gt; as.logical(0)
[1] FALSE
&amp;gt; as.logical(1)
[1] TRUE
&amp;gt; as.logical(2)
[1] TRUE
&amp;gt; as.logical(&quot;FALSE&quot;)
[1] FALSE
&amp;gt; as.logical(&quot;F&quot;)
[1] FALSE
&amp;gt; as.logical(&quot;T&quot;) 
[1] TRUE
&amp;gt; as.character(1)
[1] &quot;1&quot;
&amp;gt; as.character(FALSE)
[1] &quot;FALSE&quot;
&amp;gt; as.character(TRUE)
[1] &quot;TRUE&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;向量元素选取&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;x&amp;lt;-1:10
&amp;gt;x
[1] 1 2 3 4 5 6 7 8 9 10
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;1.通过下标取对应值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;x[5]
[1] 5
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.通过c()函数和下标取多值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;x[c(1,5,8,10)]
[1] 1 5 8 10
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.通过切片获取或删除&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;x[2:5]
[1] 2 3 4 5
&amp;gt;x[-2:-5]
[1] 1 6 7 8 9 10
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;矩阵&lt;/h3&gt;
&lt;h4&gt;声明&lt;/h4&gt;
&lt;p&gt;定义：&lt;strong&gt;矩阵是一个二维数组&lt;/strong&gt;，与向量类似，矩阵中也&lt;strong&gt;仅能包含一种数据类型&lt;/strong&gt;（数值型、字符型或逻辑型）。&lt;/p&gt;
&lt;p&gt;创建方法：使用函数matrix(）来创建矩阵，一般语法格式为&lt;/p&gt;
&lt;p&gt;matrix(data=NA, nrow=1, ncol=1, byrow=FALSE, dimnames=NULL)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;data包含了矩阵的元素，默认为NA;&lt;/p&gt;
&lt;p&gt;nrow和ncol分别为行数和列数，默认值均为1;&lt;/p&gt;
&lt;p&gt;byrow表示矩阵应当按行填充（byrow=TRUE）还是按列填充（byrow=FALSE)，默认情况下按列填充；&lt;/p&gt;
&lt;p&gt;dimnames为以字符型向量表示的行名和列名，默认为NULL&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;创建矩阵&lt;/h4&gt;
&lt;p&gt;1.按列填充&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;x&amp;lt;-matrix(1:15,nrow=5,ncol=3)  # 5*3矩阵 按列填充
&amp;gt;x

     [,1] [,2] [,3]
[1,]  1     6   11
[2,]  2     7   12
[3,]  3     8   13
[4,]  4     9   14
[5,]  5     10  15
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.按行填充&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;a&amp;lt;-1:6
&amp;gt;rnames&amp;lt;-c(&quot;r1&quot;,&quot;r2&quot;)
&amp;gt;cnames&amp;lt;-c(&quot;c1&quot;,&quot;c2&quot;,&quot;c3&quot;)
&amp;gt;x&amp;lt;-matrix(a,nrow=2,ncol=3,byrow=TRUE,  # 2*3矩阵 按行填充
           dimnames=list(rnames,cnames)) 
&amp;gt;x

     [c1] [c2] [c3]
[r1]   1    2   3
[r2]   4    5   6
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;矩阵合并&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; m1&amp;lt;-matrix(1,nr=2,nc=2)
&amp;gt; m2&amp;lt;-matrix(2,nr=2,nc=2)
&amp;gt; rbind(m1,m2) #按行合并
[,1] [,2]
[1,] 1 1
[2,] 1 1
[3,] 2 2
[4,] 2 2
&amp;gt; cbind(m1,m2) #按列合并
[,1] [,2] [,3] [,4]
[1,] 1 1 2 2
[2,] 1 1 2 2
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;矩阵下标使用&lt;/h4&gt;
&lt;p&gt;通过使用下标和方括号，可以访问矩阵中的行、列或元素。&lt;/p&gt;
&lt;p&gt;X[i,］表示矩阵x中的第i 行，X[,j］表示矩阵X中的第j列，X[i,j］表示矩阵x中的第i行、第j列元素，选择多行或多列时，下标i和j可为数值型向量&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;x&amp;lt;-matrix(1:15,nrow=5,ncol=3) # 5*3矩阵 按列填充
&amp;gt;x

     [,1] [,2] [,3]
[1,]   1    6   11
[2,]   2    7   12
[3,]   3    8   13
[4,]   4    9   14
[5,]   5    10  15

&amp;gt;x[2,]
[1] 2 7 12
&amp;gt;x[,3]
[1] 11 12 13 14 15
&amp;gt;x[5,3]
[1] 15
&amp;gt;x[c(1,5),c(1,2,3)]

     [,1] [,2] [,3]
[1,]   1    6   11
[5,]   5    10  15
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;数组&lt;/h3&gt;
&lt;h4&gt;声明&lt;/h4&gt;
&lt;p&gt;定义：数组（array）与矩阵类似，但是&lt;strong&gt;维数可以大于2&lt;/strong&gt;。像矩阵一样，数组中的数据也&lt;strong&gt;只能拥有一种模式&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;创建方法：使用array(）函数创建数组，语法格式如下：&lt;/p&gt;
&lt;p&gt;array(data=NA, dim=length(data), dimnames=NULL)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;data包含了数组的数据；&lt;/p&gt;
&lt;p&gt;dim是各维长度组成的数值型向量；&lt;/p&gt;
&lt;p&gt;dimnames是可选的、各维度名称标签的列表。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;创建数组&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;dim1&amp;lt;-c(&quot;R1&quot;, &quot;R2&quot;, &quot;R3&quot;)
&amp;gt;dim2&amp;lt;-c(&quot;c1&quot;, &quot;C2&quot;, &quot;C3&quot;)
&amp;gt;dim3&amp;lt;-c(&quot;M1&quot;, &quot;M2&quot;, &quot;M3&quot;)
&amp;gt;z&amp;lt;-array(1:27, dim=c(3,3,3), dimnames=list(diml,dim2, dim3))
&amp;gt;z

,, M1
   C1 C2 C3
R1 1  4  7
R2 2  5  8
R3 3  6  9

,, M2
   C1 C2 C3
R1 10 13 16
R2 11 14 17
R3 12 15 18

,, M3
   C1 C2 C3
R1 19 22 25
R2 20 23 26
R3 21 24 27
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;首先创建了3个向量，分别表示数组中各维度的名称标签。然后创建了一个数据为1~27的3x3x3的数组，数组中的元素按列填充。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;选取数组元素&lt;/h4&gt;
&lt;p&gt;1.获取目标单一值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#延用上代码块内容
&amp;gt;z[1,2,3] #M3中第一行第二列
[1] 22
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.通过切片截取向量&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;z[1:2,1:2,2:3] #M2和M3的第一行至第二行，第一列至第二列

,, M2
    c1 c2
r1  10 13
r2  11 14
,, M3
    c1 c2
r1  19 22
r2  20 23 

&amp;gt;z[,,2] #M2全体元素
#略
&amp;gt;z[,2,2] #M2第二行全体元素
#略
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;数据框&lt;/h3&gt;
&lt;h4&gt;声明&lt;/h4&gt;
&lt;p&gt;定义：数据框是R语言中&lt;strong&gt;最常处理的数据结构&lt;/strong&gt;，它可以&lt;strong&gt;将不同的数据类型结构组合在一起&lt;/strong&gt;。数据框的维数是二维&lt;/p&gt;
&lt;p&gt;创建方法：数据框可以使用函数data.frame()创建：&lt;/p&gt;
&lt;p&gt;data.frame(col1,col2,co13,......)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;列向量col1、col2、col3等可为任何类型（如数值型、字符型或逻辑型等）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;创建数据框&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;patientID&amp;lt;-c(1,2,3,4,5)
&amp;gt;age&amp;lt;-c(35,48,50,29,24)
&amp;gt;diabetes&amp;lt;-c(&quot;Type1&quot;, &quot;Type2&quot;, &quot;Type1&quot;, &quot;Type1&quot;, &quot;Type2&quot;)
&amp;gt;status&amp;lt;-c(&quot;Poor&quot;, &quot;Improved&quot;, &quot;Poor&quot;, &quot;Excellent&quot;, &quot;Poor&quot;)
&amp;gt;patientdata&amp;lt;-data.frame(patientID, age, diabetes, status)
&amp;gt;patientdata

   patientID  age  diabetes  status 
1      1      35    Typel    Poor
2      2      48    Type2    Improved
3      3      50    Type1    Poor
4      4      29    Type1    Excellent
5      5      24    Type2    Poor
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;同一列的数据类型必须唯一，如 patientID和age是数值型向量，diabetes和status是字符型向量。首先给各个变量赋值，然后使用函数data.frame(）将多个类型不同的列放到一起组成数据框。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;选取数据框元素&lt;/h4&gt;
&lt;p&gt;数据框元素的选取与矩阵类似，&lt;strong&gt;可以使用下标或下标向量，也可以直接使用列名或列名向量&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;patientdata[1:2,1:4]  #第一行至二行的第一至四列数据

  patientID  age  diabetes  status
1     1      35     Typel    Poor
2     2      48     Type2    Improved

&amp;gt;patientdata[1:2,c(2:3)] #第一行至二行的第二至三列数据
&amp;gt;patientdata[1:2,c(&quot;age&quot;,&quot;diabetes&quot;)] #第一行至二行的第二至三列数据
#略

&amp;gt;patientdata$age #获取age全部内容
[1] 35 48 50 29 24
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;第四个语句patientdata $ age 表示 patientdata 数据框中的变量age，记号＄是用来选取一个给定数据框中的某个特定变量&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;列表&lt;/h3&gt;
&lt;h4&gt;声明&lt;/h4&gt;
&lt;p&gt;定义：列表（list）是R语言的数据结构中最为复杂的一种。一般来说，列表是数据对象的有序集合，可以包含向量、矩阵、数组、数据框，甚至是另外一个列表&lt;/p&gt;
&lt;p&gt;创建列表：可以使用函数list()创建列表&lt;/p&gt;
&lt;p&gt;list (object1, object2, ...…)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;对象（object）可以是目前为止讲到的任何结构。还可以为列表中的对象命名：&lt;br /&gt;
list (namel=object1, name2=object2,…...)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;创建列表&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;a&amp;lt;-&quot;My List&quot;                      ＃创建一个包含字符串、向量、矩阵、数组、数据框的列表
&amp;gt;b&amp;lt;-c(&quot;Simon&quot;, &quot;Lucy&quot;, &quot;Andy&quot;, &quot;James&quot;)
&amp;gt;c&amp;lt;-c(185,168,160,180)
&amp;gt;d&amp;lt;-matrix(1:12,nrow=3)
&amp;gt;z&amp;lt;-array(1:12, dim=c(2,3,2))
&amp;gt;mydata&amp;lt;-data.frame(name=b,height=c)
&amp;gt;mylist&amp;lt;-list(title=a, name=b, height=c, d, z, mydata)

&amp;gt;mylist
$title
[1] &quot;My List&quot;

$name
[1] &quot;Simon&quot; &quot;Lucy&quot; &quot;Andy&quot; &quot;James&quot;

$height
[1] 185 168 160 180

[[4]]
      [,1] [,2] [,3] [,4]
[1,]    1    4    7   10
[2,]    2    5    8   11
[3,]    3    6    9   12

[[5]]
,, 1
      [,1] [,2] [,3]
[1,]    1    3   5 
[2,]    2    4   6 
,,2   [,1] [,2] [,3]
[1,]    7    9   11
[2,]    8    10  12

[[6]]
   name  height
1  Simon  185 
2  Lucy   168 
3  Andy   160
4  James  180
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;本例创建了一个列表，包含6个成分：一个字符串、一个字符型向量、一个数值型向量、一个矩阵、一个数组以及一个由字符型向量和数值型向量组成的数据框。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;访问列表&lt;/h4&gt;
&lt;p&gt;访问列表的元素，可以使用方括号和双重方括号访问，两种方法所代表的含义不同，还&lt;br /&gt;
可以直接使用成分的名称访问&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;mylist[2]
$name
[1] &quot;Simon&quot; &quot;Lucy&quot; &quot;Andy&quot; &quot;James&quot;
&amp;gt;mylist[&quot;name&quot;]
$name
[1] &quot;Simon&quot; &quot;Lucy&quot; &quot;Andy&quot; &quot;James&quot;
&amp;gt;mylist[[&quot;name&quot;]]
&amp;gt;mylist[[2]]
&amp;gt;mylist$name
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;数据的输入&lt;/h2&gt;
&lt;h3&gt;键盘输入数据&lt;/h3&gt;
&lt;p&gt;最简单的输入数据的方式就是键盘输入，有两种常见的方式：用R语言内置的文本编辑器和直接在代码中嵌入数据（前面介绍数据结构的创建就是在代码中嵌入数据）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第1步：创建一个空数据框（或矩阵），其中变量名和变量的模式需与理想中的最终数据集一致。&lt;/li&gt;
&lt;li&gt;第2步：针对这个数据对象调用文本编辑器，输入数据，并将结果保存回此数据对象中。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;mydata&amp;lt;-data.frame(age=numeric(0),gender=character(0), weight=numeric(0))&lt;br /&gt;
                          mydata&amp;lt;-edit(mydata)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第3步：在如图2-1所示的编辑器上添加数据。单击列的标题，可以修改变量名和变量类型（数值型、字符型）。还可以通过单击未使用列的标题来添加新的变量。编辑器关闭后，结果会保存到之前赋值的对象中（mydata)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;images/Capture_20240810_171648.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;带分隔符的文本文件数据&lt;/h3&gt;
&lt;p&gt;从带分隔符的文本文件导入数据&lt;/p&gt;
&lt;p&gt;其语法如下：&lt;br /&gt;
mydataframe &amp;lt;-read.table(file, options)&lt;br /&gt;
其中，file是一个带分隔符的ASCII文本文件，options是控制如何处理数据的选项。&lt;/p&gt;
&lt;h3&gt;Excel数据&lt;/h3&gt;
&lt;p&gt;读取一个Excel文件的最好方式，就是在Excel中将其导出为一个逗号分隔文件（csv),并使用232节描述的方式将其导入R软件中。&lt;br /&gt;
    用函数 read.xlsx(）导入一个工作表到一个数据框中。最简单的格式是read.xlsx(file,n),其中file是Excel工作簿的所在路径，n则为要导入的工作表序号。在Windows系统中导人一个工作表的代码如下。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;library(x1sx)
workbook&amp;lt;-&quot;c:/myworkbook.xlsx&quot;
mydataframe &amp;lt;-read.xlsx(workbook, 1)
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;以上代码表示从位于C盘根目录的工作簿 myworkbook.xlsx中导入了第一个工作表，并将其保存为一个数据框 mydataframe。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;其他方法&lt;/h3&gt;
&lt;p&gt;SPSS数据、SAS数据、Stata数据&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;R语言数据分析与可视化P18页&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1&gt;基本绘图&lt;/h1&gt;
&lt;h2&gt;图形简介&lt;/h2&gt;
&lt;h3&gt;入门绘画&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;attach(mtcars) #mtcars是R语言内置数据集 
plot(wt,mpg,xlab=&quot;wt / t&quot;,ylab=&quot;mpg / Miles per gallon&quot;) 
abline(lm(mpg~wt)) #绘制最优拟合线
detach(mtcars) # 解除捆绑
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;首句绑定数据框mtcars。第二句调用函数plot()绘制了一幅散点图，横轴表示车身重量，纵轴表示每加仑行驶的英里数。第三句向图形添加了一条最优拟合线。最后一句解除对数据框的绑定。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;images/2024081101.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;打开或关闭多个图形窗口&lt;/h3&gt;
&lt;p&gt;创建一幅新图形时，通常现有的图形窗口都会被新的图形覆盖&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;dev.new() #打开新窗口
dev.off() #关闭窗口
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;图形保存&lt;/h3&gt;
&lt;p&gt;a.使用代码保存图形，将绘图语句夹在&lt;strong&gt;开启目标图形设备的语句和关闭目标设备的语句之间&lt;/strong&gt;即可&lt;/p&gt;
&lt;p&gt;支持的格式有：pdf()、png()、bmp()、jpeg()、postscript()、tiff()和win.metafile()&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;pdf(&quot;graph1.pdf&quot;) #起始 
attach(mtcars)
plot(wt, mpg)
abline(lm(mpg~wt))
detach(mtcars)
dev.off() #终止 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;b.通过图形用户界面来保存图形，&lt;strong&gt;鼠标右击图片保存&lt;/strong&gt;或在&lt;strong&gt;图形窗口上方导航栏中选择“文件”、“另存为”&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;图形参数&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;我们可以通过修改图形参数来自定义一幅图形的多个特征，如符号、颜色、字体、坐标轴以及图例等，使其达到我们想要的效果。&lt;/li&gt;
&lt;li&gt;常用的方式是使用**函数par()**来修改这些选项，其调用格式为par(optionname=value,optionname=name,…)。&lt;/li&gt;
&lt;li&gt;当par()不加参数时，将返回当前图形参数设置的列表；&lt;/li&gt;
&lt;li&gt;添加参数&lt;strong&gt;par(no.readonly=TRUE)&lt;strong&gt;将生成一个可以修改的当前图形参数列表。注意以这种方式设定的图形参数除非被再次修改，否则将会&lt;/strong&gt;一直执行此参数设置，直到会话结束&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;设置图形参数列表&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;attach(mtcars)
opar&amp;lt;-par(no.readonly=TRUE) #图形设置保存在opar中（此处为默认的图形设置）
par(pch=15,lty=2) #符号换成实心的方块，实线换成虚线
plot(wt,mpg,xlab=&quot;wt / t&quot;,ylab=&quot;mpg / Miles per gallon&quot;)
abline(lm(mpg~wt))
par(opar) #一直执行此参数设置，直到会话结束（单窗口）
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;绘画函数内直接添加图形参数&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;plot(wt,mpg,pch=15) 
abline(lm(mpg~wt),lty=2) 
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;符号与线条&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;参数&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;pch&lt;/td&gt;
&lt;td&gt;绘制点符号的样式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;cex&lt;/td&gt;
&lt;td&gt;符号的大小，默认大小为1，1.5表示放大为默认值的1.5倍，0.5表示缩小为默认值的50%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;bg&lt;/td&gt;
&lt;td&gt;符号的内部填充色，仅限符号21~25&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;lty&lt;/td&gt;
&lt;td&gt;线条类型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;lwd&lt;/td&gt;
&lt;td&gt;线条宽度，默认宽度为1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;col&lt;/td&gt;
&lt;td&gt;指定符号边框和线条的颜色&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&amp;lt;center style=&quot;color:#808080; font-size:15px;&quot;&amp;gt;点符号和线条类型的参数&amp;lt;/center&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;figure&amp;gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/2024081102.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;center style=&quot;color:#808080; font-size:15px;&quot;&amp;gt;点与线条的样式&amp;lt;/center&amp;gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;dev.new() 
plot(wt,mpg,pch=22,col=2,bg=8,cex=0.8, xlab=&quot;wt/t&quot;,ylab=&quot;mpg/Miles per gallon&quot;)
abline(lm(mpg~wt),lty=2,lwd=2,col=3) 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;images/2024081103.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;颜色&lt;/h2&gt;
&lt;p&gt;参数col除了上述的可以设置点、线的颜色，还可以设置图像、坐标轴、文字等的颜色&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;参数&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;col&lt;/td&gt;
&lt;td&gt;默认的绘图颜色&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;col.axis&lt;/td&gt;
&lt;td&gt;坐标轴刻度文字的颜色&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;col.lab&lt;/td&gt;
&lt;td&gt;坐标轴标签的颜色&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;col.main&lt;/td&gt;
&lt;td&gt;标题的颜色&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;col.sub&lt;/td&gt;
&lt;td&gt;副标题的颜色&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;fg&lt;/td&gt;
&lt;td&gt;图形的前景色&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;bg&lt;/td&gt;
&lt;td&gt;图形的背景色&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&amp;lt;center style=&quot;color:#808080; font-size:15px;&quot;&amp;gt;用于指定颜色的参数&amp;lt;/center&amp;gt;&lt;/p&gt;
&lt;p&gt;在R中，可以通过颜色下标、颜色名称、十六进制的颜色值、RGB值或HSV值来确定颜色。例如： col=1、col=“white”、col=“#FFFFFF”、col=rgb(1,1,1)、col=hsv(0,1,1)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;函数rgb()是基于红-绿-蓝生成的颜色，hsv() 是基于色相-饱和度-亮度值生成的颜色&lt;/p&gt;
&lt;p&gt;函数colors()可以生成657中颜色名称，然后可以通过这些名称，使用参数col=颜色名称，来设定我们想要的颜色。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;par(col=&quot;red&quot;,col.axis=&quot;blue&quot;,col.lab=&quot;black&quot;) 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;images/2024081104.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;文本属性&lt;/h2&gt;
&lt;p&gt;文本属性包括指定字号、字体和字样&lt;/p&gt;
&lt;h3&gt;字体大小&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;描述&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;cex&lt;/td&gt;
&lt;td&gt;字体大小，默认大小为1。1.5表示放大为默认值的1.5倍，0.5表示缩小为默认值的50%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;cex.axis&lt;/td&gt;
&lt;td&gt;坐标轴刻度文字的缩放倍数。类似于cex&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;cex.lab&lt;/td&gt;
&lt;td&gt;坐标轴标签（名称）的缩放倍数。类似于cex&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;cex.main&lt;/td&gt;
&lt;td&gt;标题的缩放倍数。类似于cex&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;cex.sub&lt;/td&gt;
&lt;td&gt;副标题的缩放倍数。类似于cex&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&amp;lt;center style=&quot;color:#808080; font-size:15px;&quot;&amp;gt;指定字体大小的参数&amp;lt;/center&amp;gt;&lt;/p&gt;
&lt;h3&gt;字体字样&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;描述&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;font&lt;/td&gt;
&lt;td&gt;整数。用于指定绘图使用的字体样式。1=常规，2=粗体，3=斜体，4=粗斜体，5=符号字体（以Adobe符号编码表示）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;font.axis&lt;/td&gt;
&lt;td&gt;坐标轴刻度文字的字体样式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;font.lab&lt;/td&gt;
&lt;td&gt;坐标轴标签（名称）的字体样式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;font.main&lt;/td&gt;
&lt;td&gt;标题的字体样式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;font.sub&lt;/td&gt;
&lt;td&gt;副标题的字体样式&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&amp;lt;center style=&quot;color:#808080; font-size:15px;&quot;&amp;gt;指定字样的参数&amp;lt;/center&amp;gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;par(font.lab=3,cex.lab=1.5,cex.axis=0.8,font.axis=2) 
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;表示之后创建的所有图形的坐标轴标签（名称）字体样式为斜体、大小扩大为默认文本大小的1.5倍，坐标轴刻度文字字体样式为粗体、大小缩小为默认文本大小的80%&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;images/2024081105.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;图形尺寸和边界尺寸&lt;/h2&gt;
&lt;p&gt;R语言中，还可以使用参数来控制图形尺寸和边界大小&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;描述&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;pin&lt;/td&gt;
&lt;td&gt;以英寸表示的图形尺寸（宽和高）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;mai&lt;/td&gt;
&lt;td&gt;以数值向量表示的边界大小，顺序为“下、左、上、右”(顺时针)，单位为英寸&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;mar&lt;/td&gt;
&lt;td&gt;以数值向量表示的边界大小，顺序为“下、左、上、右”，单位为英分*。默认值为c(5, 4, 4, 2) + 0.1&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&amp;lt;center style=&quot;color:#808080; font-size:15px;&quot;&amp;gt;控制图形尺寸和边界大小的参数&amp;lt;/center&amp;gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;par(pin=c(3,4),mai=c(1,1,1,.5)) 
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;生成一幅3英寸宽、4英寸高、上下边界为为1英寸、左边界为1英寸、右边界为0.5英寸的图形&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;attach(mtcars)
opar&amp;lt;-par(no.readonly=TRUE)
par(pin=c(2,3)) #设置宽高
par(lwd=2,cex=0.8) #设置线条宽度和符号大小
par(font.axis=3,cex.axis=0.8) #设置坐标刻度字体样式和字体大小
par(font.lab=2,cex.lab=1.2)   #设置坐标轴标签的字体样式和大小
plot(wt,mpg,pch=20,col=&quot;red&quot;,xlab=&quot;wt / t&quot;,ylab=&quot;mpg / Miles per gallon&quot;) #设置符号样式
abline(lm(mpg~wt),lty=2)  #设置线条类型
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;images/2024081106-e1723349648176.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;添加文本、自定义坐标轴和图例&lt;/h2&gt;
&lt;p&gt;许多高级绘图函数（例如plot、hist、boxplot）还允可以自行设定坐标轴和文本标注选项。例如，添加标题（main）、副标题（sub）、坐标轴标签（xlab、ylab）并指定了坐标轴范围（xlim、ylim）等&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;plot(wt,mpg,pch=2,col=&quot;red&quot;, 
main=&quot;Scatterplot of wt vs. mpg&quot;, # 主标题
sub=&quot;one&quot;,                        # 副标题
xlab=&quot;车重 / t&quot;,                  # X标签
ylab=&quot;每加仑行驶英里数 / Miles per gallon&quot;, # Y标签 
xlim=c(0,10),                             # X刻度范围
ylim=c(0,50))                             # Y刻度范围
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;images/2024081201.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;标题&lt;/h3&gt;
&lt;p&gt;**函数title()**可以为图形添加标题、副标题以及坐标轴标签&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;title(main=&quot;main title&quot;, sub=&quot;subtitle&quot;, xlab=&quot;x-axis label&quot;, ylab=&quot;y-axis label&quot;) 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;函数title()还可以指定各选项的字体、大小和颜色&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;font.main、cex.main、col.main、font.sub、cex.sub、col.sub、font.lab、cex.lab、col.lab&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;title(main=&quot;My Title&quot;,col.main=&quot;red&quot;,font.main=2, # 生成红色且字体为粗体的标题
sub=&quot;My Subtitle&quot;, col.sub=&quot;black&quot;,               # 黑色的副标题
xlab=&quot;x&quot;, ylab=&quot;y&quot;,                               
col.lab=&quot;green&quot;, cex.lab=0.8)                     # 大小缩小为默认大小80%的绿色x轴、y轴标签
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;坐标轴&lt;/h3&gt;
&lt;p&gt;axis()函数可以自定义坐标轴&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;axis(side, at=, labels=, pos=, lty=, col=, las=, tck=, ...)
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;创建自定义坐标轴时，应当禁用高级绘图函数自动生成的坐标轴。使用参数axes=FALSE将禁用全部坐标轴（包括坐标轴框架线，除非你添加了参数frame.plot=TRUE）。参数xaxt=&quot;n&quot;和yaxt=&quot;n&quot;将分别禁用X轴或Y轴（会留下框架线，只是去除了刻度）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;选项&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;side&lt;/td&gt;
&lt;td&gt;一个整数，表示在图形的哪一侧绘制坐标轴（1=下，2=左，3=上，4=右）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;at&lt;/td&gt;
&lt;td&gt;一个数值型向量，表示需要绘制刻度线的位置&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;labels&lt;/td&gt;
&lt;td&gt;一个字符型向量，表示置于刻度线旁边的文字标签（如果为 NULL，则将直接使用 at 中的值）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;pos&lt;/td&gt;
&lt;td&gt;坐标轴线绘制位置的坐标（即与另一条坐标轴相交位置的值）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;lty&lt;/td&gt;
&lt;td&gt;线条类型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;col&lt;/td&gt;
&lt;td&gt;轴线和刻度线颜色&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;las&lt;/td&gt;
&lt;td&gt;标签是否平行于（=0）或垂直于（=2）坐标轴&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;tck&lt;/td&gt;
&lt;td&gt;刻度线的长度，以相对于绘图区域大小的分数表示（负值表示在图形外侧，正值表示在图形内侧，0表示禁用刻度，1 表示绘制网格线）；默认值为–0.01&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;…&lt;/td&gt;
&lt;td&gt;其他图形参数&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;pre&gt;&lt;code&gt;height&amp;lt;-c(155,157,160,163,166,169,172,175,179,182) 
weight&amp;lt;-c(58,59,60,61,62,63,64,65,66,67) 
plot(height,weight,type=&quot;b&quot;,pch=16,col=&quot;red&quot;, lty=2, 
xaxt=&quot;n&quot;,yaxt=&quot;n&quot;,ann=FALSE) # 禁止自动生成的坐标轴
axis(1,at=height,labels=height) #横坐标
axis(2,at=weight,labels=weight,las=2) #纵坐标
title(xlab=&quot;height / cm&quot;,ylab=&quot;weight / kg&quot;) 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;images/2024081202.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;参考线&lt;/h3&gt;
&lt;p&gt;**函数abline()**可以为图形添加参考线，也可以指定其他图形参数（如线条类型、颜色和宽度）&lt;/p&gt;
&lt;p&gt;abline(a = NULL, b = NULL, h = NULL, v = NULL, ...)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;a：常数项，b：斜率，h：水平线，v：垂直线&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;abline(h=c(1,3,5)，v=4，col=&quot;green&quot;) 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;images/2024081203-e1723436490138.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;图例&lt;/h3&gt;
&lt;p&gt;**函数legend()**用来添加图例&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;选项&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;描述&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;x,y&lt;/td&gt;
&lt;td&gt;指定图例的位置。也可以执行 locator(1)，然后通过鼠标单击给出图例的位置，还可以使用关键字 bottom、bottomleft、left、topleft、top、topright、right、bottomright 或 center 放置图例&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;inset&lt;/td&gt;
&lt;td&gt;当图例用关键词设置位置后，使用参数 inset=指定图例向图形内侧移动的大小（以绘图区域大小的分数表示）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;legend&lt;/td&gt;
&lt;td&gt;图例标签组成的字符型向量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;title&lt;/td&gt;
&lt;td&gt;图例标题的字符串&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;title.adj&lt;/td&gt;
&lt;td&gt;图例标题的相对位置，0.5为默认，在中间。0最左，1为最右。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;col&lt;/td&gt;
&lt;td&gt;图例中出现的点或线的颜色&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;lty,lwd&lt;/td&gt;
&lt;td&gt;图例中线的类型与宽度&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;pch&lt;/td&gt;
&lt;td&gt;图例中点的类型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;cex&lt;/td&gt;
&lt;td&gt;图例字符大小&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;bty&lt;/td&gt;
&lt;td&gt;图例框是否画出，o为画出，默认为n不画出&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;bg&lt;/td&gt;
&lt;td&gt;bty != “n”时，图例的背景色&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;text.col&lt;/td&gt;
&lt;td&gt;图例字体的颜色&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;text.font&lt;/td&gt;
&lt;td&gt;图例字体的样式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ncol&lt;/td&gt;
&lt;td&gt;图例中分类的列数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;horiz&lt;/td&gt;
&lt;td&gt;逻辑值，默认(horiz=FALSE)为垂直放置图例，horiz=TRUE将会水平放置图例&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;…&lt;/td&gt;
&lt;td&gt;其他选项。请参考help(legend)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&amp;lt;center style=&quot;color:#808080; font-size:15px;&quot;&amp;gt;图例选项&amp;lt;/center&amp;gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;选项&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;描述&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;location&lt;/td&gt;
&lt;td&gt;文本的位置参数。可为一对 x、y 坐标，也可通过执行locator(1)，使用鼠标交互式地确定摆放位置&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;pos&lt;/td&gt;
&lt;td&gt;文本相对于位置参数的方位。1=下，2=左，3=上，4=右。如果指定了pos，就可以同时指定参数offset=作为偏移量，以相对于单个字符宽度的比例表示&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;side&lt;/td&gt;
&lt;td&gt;指定用来放置文本的边。1=下，2=左，3=上，4=右。你可以指定参数 line=来内移或外移文本，随着值的增加，文本将外移。也可使用 adj=0 将文本向左下对齐，或使用 adj=1 右上对齐&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;pre&gt;&lt;code&gt;age&amp;lt;-c(118,484,664,1004,1231,1372,1582) 
circumference_tree1&amp;lt;-c(30,58,87,115,120,142,145) 
circumference_tree2&amp;lt;-c(33,69,111,156,172,203,203) 
circumference_tree3&amp;lt;-c(30,51,75,108,115,139,140) 

opar &amp;lt;- par(no.readonly=TRUE) 
par(font.lab=2,font.axis=3,cex.axis=0.8) 

plot(age,circumference_tree1,type=&quot;b&quot;,pch=15,lty=1,col=&quot;red&quot;, 
 ylim=c(0,250),
 xlab=&quot;Tree age / year&quot;, ylab=&quot;circumference &quot;,xaxt=&quot;n&quot;) 
axis(1,at=seq(0,1600,200)) #刻度

lines(age,circumference_tree2,type=&quot;b&quot;,pch=16,lty=2,col=&quot;blue&quot;) 
lines(age,circumference_tree3,type=&quot;b&quot;,pch=17,lty=3,col=&quot;green&quot;) 

legend(&quot;topleft&quot;,inset=.05,title=&quot;Tree Type&quot;,
 c(&quot;tree1&quot;,&quot;tree2&quot;,&quot;tree3&quot;),
 lty=c(1, 2,3,4,5), pch=c(15,16,17),
 col=c(&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;)) 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;images/2024081204.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;文本注释&lt;/h3&gt;
&lt;p&gt;使用函数text()和mtext()向图形中添加文本。&lt;/p&gt;
&lt;p&gt;text()可向绘图区域内部添加文本，而mtext()则向图形的四个边界之一添加文本。&lt;/p&gt;
&lt;p&gt;text(location,&quot;text to place&quot;, pos, ...)&lt;/p&gt;
&lt;p&gt;mtext(&quot;text to place&quot;, side, line=n, ...)&lt;/p&gt;
&lt;h2&gt;散点图&lt;/h2&gt;
&lt;h3&gt;基础函数plot()&lt;/h3&gt;
&lt;p&gt;散点图通常用来描述两个连续型变量间的关系，绘制基本散点图使用&lt;strong&gt;plot()函数&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;attach(mtcars) 
plot(wt,mpg,xlab=&quot;wt / t&quot;,ylab=&quot;mpg / Miles per gallon&quot;, pch=20,col=&quot;red&quot;) 
abline(lm(mpg~wt)) 
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;散点图矩阵&lt;/h3&gt;
&lt;p&gt;使用**函数pairs()**可以创建基础的散点图矩阵&lt;/p&gt;
&lt;p&gt;pairs(formula, data，…)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;formula：成对使用的一系列变量，data：表示将从中采集变量的数据集&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;pairs(~mpg+disp+wt, data=mtcars)  # ①

pairs(~mpg+disp+wt, data=mtcars, upper.panel = NULL) # ②
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;①所有指定变量间的二元相关关系&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/2024081501.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;②添加选项upper.panel = NULL将只生成下三角的图形&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/2024081502.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;三维散点图&lt;/h3&gt;
&lt;p&gt;用scatterplot3d包中的&lt;strong&gt;scatterplot3d()函数&lt;/strong&gt;来绘制三维散点图&lt;/p&gt;
&lt;p&gt;scatterplot3d(x, y, z)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;install.packages(&quot;scatterplot3d&quot;)
library(scatterplot3d) 
attach(mtcars) 
scatterplot3d(wt, disp, mpg,xlab=&quot;wt / t&quot;,
 ylab=&quot;mpg / Miles per gallon&quot;,
 zlab=&quot;disp / Cubic inch&quot;) 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;images/2024081503.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;旋转三维散点图&lt;/h3&gt;
&lt;p&gt;使用rgl包中的&lt;strong&gt;plot3d()函数&lt;/strong&gt;可创建旋转的三维散点图，通过鼠标对图形进行旋转&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;install.packages(&quot;rgl&quot;) 
library(rgl) 
attach(mtcars) 
plot3d(wt, disp, mpg,col=&quot;red&quot;, 
 xlab=&quot;wt / t&quot;,ylab=&quot;mpg / Miles per gallon&quot;, zlab=&quot;disp / Cubic inch&quot;) 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;images/2024081504.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;气泡图&lt;/h3&gt;
&lt;p&gt;展示三个变量间的关系，除了使用三维散点图，还可以使用气泡图来展示。气泡图是先创建一个二维散点图，然后第三个变量的值用点的大小来表示，值越大，气泡越大，反之，越小。&lt;/p&gt;
&lt;p&gt;气泡图可以使用使用**函数symbols()**来创建&lt;/p&gt;
&lt;p&gt;该函数可以在指定的(x, y)坐标上绘制圆圈图、方形图、星形图、温度计图和箱线图。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;symbols(x, y = NULL,&lt;/p&gt;
&lt;p&gt;circles, squares, rectangles, stars, thermometers, boxplots,  # 圆形，正方形，矩形，星形，温度计、箱形&lt;/p&gt;
&lt;p&gt;inches = TRUE, add = FALSE, fg = par(&quot;col&quot;), bg = NA, xlab = NULL, ylab = NULL, main = NULL, xlim = NULL, ylim = NULL, ...)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;attach(mtcars) 
symbols(wt,mpg,circles=disp,inches=0.25,bg=&quot;lightblue&quot;, xlab=&quot;wt / t&quot;,ylab=&quot;mpg / Miles per gallon&quot;) 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;images/2024081505.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;折线图&lt;/h2&gt;
&lt;p&gt;折线图就是将散点图上的点从左到右的连接起来。折线图一般可以&lt;strong&gt;用函数plot()和lines()来创建&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;plot(x, y, type=) lines(x, y, type=)&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;类型&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;描述&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;p&lt;/td&gt;
&lt;td&gt;只有点&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;l&lt;/td&gt;
&lt;td&gt;只有线&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;b&lt;/td&gt;
&lt;td&gt;线连接点&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;c&lt;/td&gt;
&lt;td&gt;线连接点，但不绘制点&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;o&lt;/td&gt;
&lt;td&gt;实心点和线（即线覆盖在点上）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;h&lt;/td&gt;
&lt;td&gt;直方图式的垂直线&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;S、s&lt;/td&gt;
&lt;td&gt;阶梯线&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;n&lt;/td&gt;
&lt;td&gt;不生成任何点和线,通常用来为后面的命令创建坐标轴&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&amp;lt;center style=&quot;color:#808080; font-size:15px;&quot;&amp;gt;折线图type类型&amp;lt;/center&amp;gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/2024081506.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;center style=&quot;color:#808080; font-size:15px;&quot;&amp;gt;函数plot()和lines()中的type参数值&amp;lt;/center&amp;gt;&lt;/p&gt;
&lt;h2&gt;图形组合&lt;/h2&gt;
&lt;p&gt;在R中，可以使用**函数par()或layout()**将多幅图形组合为一幅图形&lt;/p&gt;
&lt;h3&gt;par&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;在par()函数中使用图形参数mfrow=c(nrows, ncols)来创建按行填充的、行数为nrows、列数为ncols的图形矩阵。另外，可以使用mfcol=c(nrows, ncols)按列填充矩阵(几行几列)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;attach(mtcars) 
opar&amp;lt;-par(no.readonly=TRUE) 
par(mfrow=c(1,2)) 
plot(wt,mpg, xlab=&quot;wt / t&quot;,ylab=&quot;mpg / Miles per gallon&quot;) 
plot(wt,disp, xlab=&quot;wt / t&quot;,ylab=&quot;disp / Cubic inch&quot;) 
par(opar) 
detach(mtcars) 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;images/2024081507.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;center style=&quot;color:#808080; font-size:15px;&quot;&amp;gt;一行两列&amp;lt;/center&amp;gt;&lt;/p&gt;
&lt;h3&gt;layout&lt;/h3&gt;
&lt;p&gt;layout(mat,widths=,heights=，byrow=)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;其中的mat是一个矩阵，它指定了所要组合的多个图形的所在位置, 非0数字代表绘制图形的顺序，相同数字代表占位符，0代表空缺，不绘制图形。widths = 各列宽度值组成的一个向量，heights = 各行高度值组成的一个向量。byrow=表示图形按行(TRUE)还是按列(FALSE)排列，默认按列排放。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;attach(mtcars)
layout(matrix(c(1,1,1,1,0,2,0,0,0,0,3,0,0,0,0,4), 4, 4))
hist(wt)
hist(mpg)
hist(carb)
hist(disp)
detach(mtcars)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;images/2024081508-1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;curve&lt;/h3&gt;
&lt;p&gt;绘制包括直线、幂函数、三角函数和余切函数在内的各种数学图像&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;curve(expr,from=NULL,to=NULL,n=101,add=FALSE,type=&quot;l&quot;,xname=&quot;x&quot;,xlabe=xname,tlable=NULL,log=NULL,xlim=NULL......)&lt;/p&gt;
&lt;p&gt;expr:表达式&lt;/p&gt;
&lt;p&gt;from,to:绘图起止范围&lt;/p&gt;
&lt;p&gt;n:表示x取值的数量&lt;/p&gt;
&lt;p&gt;add:T or F表示将绘图添加到已存在的绘图中&lt;/p&gt;
&lt;p&gt;type:样式类型&lt;/p&gt;
&lt;p&gt;xname:x轴变量名称；xlabe,ylabl:标签名称&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;rect&lt;/h3&gt;
&lt;p&gt;绘制矩阵&lt;/p&gt;
&lt;h3&gt;polygon&lt;/h3&gt;
&lt;p&gt;绘制多边形&lt;/p&gt;
</content:encoded></item><item><title>HarmonyOS-ArkUI</title><link>https://minthana.github.io/blog/posts/harmonyos-arkui/</link><guid isPermaLink="true">https://minthana.github.io/blog/posts/harmonyos-arkui/</guid><pubDate>Wed, 17 Jul 2024 14:25:00 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;p&gt;学习过程内容记录在gitee中&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://gitee.com/rongwu651/arkui/tree/master/pages&quot;&gt;https://gitee.com/rongwu651/arkui/tree/master/pages&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/sea-1024x683.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;ArkUI（方舟开发框架）是一套构建鸿蒙应用界面的框架&lt;/p&gt;
</content:encoded></item><item><title>HarmonyOS-ArkTS</title><link>https://minthana.github.io/blog/posts/harmonyos-arkts/</link><guid isPermaLink="true">https://minthana.github.io/blog/posts/harmonyos-arkts/</guid><pubDate>Tue, 16 Jul 2024 12:07:00 GMT</pubDate><content:encoded>&lt;h1&gt;ArkTS&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.huawei.com/consumer/cn/training/course/slightMooc/C101717496870909384&quot;&gt;&amp;lt;HarmonyOS第一课&amp;gt;ArkTS语法介绍-华为开发者学堂 (huawei.com)&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;数据类型&lt;/h2&gt;
&lt;p&gt;number、string、boolean&lt;/p&gt;
&lt;h2&gt;变量、常量&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;//let 变量名：类型 = 值
//const 常量名：类型 = 值
let age: number = 100
console.log(&apos;年龄为：&apos;,age) //100
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;命名规则&lt;/h2&gt;
&lt;p&gt;1.只能包含数字、字母、下划线、$,不能以数字开头 2.不能使用内置关键字或保留字 (比如 let、const) 3.严格区分大小写&lt;/p&gt;
&lt;h2&gt;运算符&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;算数&lt;/th&gt;
&lt;th&gt;+ 、-、*、/、%&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;赋值&lt;/td&gt;
&lt;td&gt;+=、-=、*=、/=、%=&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;一元&lt;/td&gt;
&lt;td&gt;前置/后置++、--&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;三元&lt;/td&gt;
&lt;td&gt;条件 ？返回值1 ：返回值2&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;比较&lt;/td&gt;
&lt;td&gt;&amp;gt;、&amp;gt;=、&amp;lt;、&amp;lt;=、==、!=、===&lt;/td&gt;
&lt;td&gt;返回布尔值，三等严格数值和类型相等&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;逻辑&lt;/td&gt;
&lt;td&gt;&amp;amp;&amp;amp;、||、！&lt;/td&gt;
&lt;td&gt;返回布尔值&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;运算符优先级&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2024-07-21-204351.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;数组及其操作&lt;/h2&gt;
&lt;p&gt;声明格式&lt;/p&gt;
&lt;p&gt;let 数组名：类型[ ] = [数据1,数据2.........]&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let names: string[] = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;]
console.log(names.toString()) //abc
console.log(names[0]) //a
console.log(&apos;&apos;,names.length) //3
names.push(&apos;d&apos;) //a b c d
names.unshift(&apos;A&apos;) // A a b c d
names.pop() //A a b c
names.shift() //a b c
names.splice(1,2) // a
names.splice(0,1,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;) // b c d
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2024-07-22-155844.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;语句&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2024-07-22-162600.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;if-else、switch、while、for、for-of、continue,break&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;//1.if分支语句
if(逻辑条件1){
  //条件1成立的执行代码
} 
else if (逻辑条件2){
  //条件2成立的执行代码
}
else{
  //条件不成立的执行代码
}

//2.switch分支语句
switch(表达式){
  case 值1:
    //执行代码
    break
 case 值2:
    //执行代码
    break
  default:
    //以上都为成功匹配执行的代码
}

//3.while循环语句
while(条件){
  //条件成功执行代码
}

//4.for循环语句
for(let i:number = 1;i&amp;lt;10;i++){
  //执行代码
}

//5.for-of 遍历数组  类似for in （python）
for(let 存储变量 of 数组){
  console.log(&apos;&apos;,存储变量)
}
//6.退出语句
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;函数&lt;/h2&gt;
&lt;p&gt;1.函数声明和使用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function 函数名(){ //定义无参函数
  //函数体
} 
函数名() //调用函数
function fn(形参1:类型,a:number){ //定义有参函数
  //函数体......
  let result:number = a+1
  return result
} 
let x: number = fn(实参1,100)
console.log(x) //101
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.箭头函数&lt;/p&gt;
&lt;p&gt;lambda表达式  简化函数声明，通常用于需要一个简单函数的地方&lt;/p&gt;
&lt;p&gt;（参数列表）：返回类型 =&amp;gt;{函数体}&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let happy = () =&amp;gt;{
  console.log(&apos;i am happy&apos;)  
}
happy() //i am happy

let buy = (price:number,weight:number) =&amp;gt;{
  let result:number = price*weight
  return result
}
let apple:number = buy(2,3)
console.log(&apos;价格:&apos;,apple) //6
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.闭包函数&lt;/p&gt;
&lt;p&gt;一个函数可以将另一个函数当做返回值，保留对内部作用域访问&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function outerFunc():()=&amp;gt;{
  let count = 0
  return ():string=&amp;gt;{
    count++;
    return count.toString()
  }
} 
let invoker = outerFunc()
comsole.log(invoker())//1
comsole.log(invoker())//2
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;对象&lt;/h2&gt;
&lt;p&gt;作用：用于描述一个物体的特征和行为&lt;/p&gt;
&lt;p&gt;对象：是一个可以存储多个不同类型数据的容器&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;interface Person{ //通过接口约定对象结构
  name:string
  age:number
  ismarry:boolean
} 
let p1: Person = {
  name:&apos;小明&apos;,
  age: 6,
  ismarry: false
}
console.log(p1.name) //小明
console.log(p1.age) //6
console.log(p1.ismarry) //false
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;对象方法&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;interface Person{ //通过接口约定对象结构
  name:string
  age:number
  ismarry:boolean
  //定义方法的类型
  sleep:()=&amp;gt; void
  work:(what:string)=&amp;gt; void
} 
let p1: Person = {
  name:&apos;小明&apos;,
  age: 6,
  ismarry: false,
  //
  sleep: ()=&amp;gt; {
    console.log(&apos;现在是小明的睡觉时间&apos;)
  },
  work:(what:string)=&amp;gt;{
    console.log(&apos;现在是小明的&apos;,what,&apos;时间&apos;)
  }
}
p1.sleep() //现在是小明的睡觉时间
p1.work(&apos;写作业&apos;) //现在是小明的写作业时间
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;数组对象&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;let peopleArr: Person[] = [{...},{},{}......]
console.log(JSON.stringify(peopleArr))
console.log(JSON.stringify(peopleArr[1]))  //通过for of也可以进行遍历
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;联合类型Union&lt;/h2&gt;
&lt;p&gt;联合类型是一种灵活的数据类型，它修饰的变量可以存储&lt;strong&gt;不同类型&lt;/strong&gt;的数据&lt;/p&gt;
&lt;p&gt;语法：let 变量名：类型1 | 类型2 | 类型3 = 值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Cat {
  // ...
}
class Dog {
  // ...
}
class Frog {
  // ...
}
type Animal = Cat | Dog | Frog | number
// Cat、Dog、Frog是一些类型（类或接口）

let animal: Animal = new Cat();
animal = new Frog();
animal = 42;
// 可以将类型为联合类型的变量赋值为任何组成类型的有效值

&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;枚举类型&lt;strong&gt;Enum&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;枚举类型是一种特殊的数据类型，约定变量只能在一组数据范围内选择值&lt;/p&gt;
&lt;p&gt;使用枚举常量时必须以枚举类型名称为前缀。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;enum ColorSet { Red, Green, Blue }
let c: ColorSet = ColorSet.Red;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;常量表达式可以用于显式设置枚举常量的值。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;enum ColorSet { White = &apos;0xFF&apos;, Grey = &apos;0x7F&apos;, Black = &apos;0x00&apos; }
let c: ColorSet = ColorSet.Black;
console.log(c)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;类型转换&lt;/h2&gt;
&lt;p&gt;1.字符串转数字&lt;/p&gt;
&lt;p&gt;Number(num)、parseInt()、parseFloat()&lt;/p&gt;
&lt;p&gt;无效时输出NaN&lt;/p&gt;
&lt;p&gt;2.数字转字符串&lt;/p&gt;
&lt;p&gt;num.toString()&lt;/p&gt;
&lt;p&gt;num.toFixed()：四舍五入转字符串，可设置保留几位小数&lt;/p&gt;
&lt;h2&gt;点击事件&lt;/h2&gt;
&lt;p&gt;说明：组件 被点击时 触发的事件&lt;/p&gt;
&lt;p&gt;作用：监听（感知）用户 点击行为，进行对应操作&lt;/p&gt;
&lt;p&gt;语法：onclick( (参数) =&amp;gt; {})&lt;/p&gt;
</content:encoded></item><item><title>计算机网络</title><link>https://minthana.github.io/blog/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</link><guid isPermaLink="true">https://minthana.github.io/blog/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</guid><pubDate>Sun, 14 Jul 2024 17:16:00 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;p&gt;本篇文章内容与摘要来自&lt;a href=&quot;https://www.bilibili.com/video/BV1c4411d7jb/?share_source=copy_web&amp;amp;vd_source=4bf637fc1e8a26c5ca8d7829888d0d52&quot;&gt;哔哩哔哩【计算机网络微课堂（有字幕无背景音乐版）】——湖科大书匠&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1&gt;概述&lt;/h1&gt;
&lt;h2&gt;计算机网络在信息时代的作用&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;计算机网络已由一种&lt;strong&gt;通信基础设施&lt;/strong&gt;发展成为一种重要的&lt;strong&gt;信息服务基础设施&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;计算机网络已经像水，电，煤气这些基础设施一样，成为我们&lt;strong&gt;生活中不可或缺&lt;/strong&gt;的一部分\&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;因特网&lt;/h2&gt;
&lt;p&gt;网络：网络（Network）由若干**结点（Node）&lt;strong&gt;和连接这些结点的&lt;/strong&gt;链路（Link）**组成。&lt;/p&gt;
&lt;p&gt;互连网（互联网）：多个网络通过路由器互连起来，这样就构成了一个覆盖范围更大的网络，即互连网（互联网）。因此，互联网又称为“网络的网络（Network of Networks）”。&lt;/p&gt;
&lt;p&gt;因特网：因特网（Internet）是世界上最大的互连网络（用户数以亿计，互连的网络数以百万计）。&lt;/p&gt;
&lt;h2&gt;三种交换方式、端点交换方式&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;C/S方式&lt;/strong&gt;：客户端与服务端之间的端对端交换方式&lt;/p&gt;
&lt;p&gt;**P2P：**结点之间的对等交换方式&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;交换技术&lt;/strong&gt;：电路交换、分组交换、报文交换&lt;/p&gt;
&lt;p&gt;1.电路交换&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2024-07-14-162910.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;2.分组交换&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2024-07-14-162959.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;三种交换方式对比&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2024-07-14-163123.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;计算机网络分类&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;1.按交换技术分类：电报交换网络、报文交换网络、分组交换网络&lt;/p&gt;
&lt;p&gt;2.按覆盖范围分类：广域网WAN、城域网MAN、局域网LAN、个域网PAN&lt;/p&gt;
&lt;p&gt;3.按使用者分类：公用网、专用网&lt;/p&gt;
&lt;p&gt;4.按覆盖范围分类：总线型网络、星型网络、环型网络、网状型网络&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;计算机网络的性能指标&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;速率，带宽，吞吐量，时延，时延带宽积，往返时间，利用率，丢包率&lt;/p&gt;
&lt;p&gt;1.速率&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/%E9%80%9F%E7%8E%87.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;2.带宽&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/%E5%B8%A6%E5%AE%BD.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;3.吞吐量&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/%E5%90%9E%E5%90%90%E9%87%8F.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;4.时延&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/%E6%97%B6%E5%BB%B6.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/%E6%97%B6%E5%BB%B62.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;5.时延带宽积&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/%E6%97%B6%E5%BB%B6%E5%B8%A6%E5%AE%BD%E7%A7%AF.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;6.往返时间&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/%E5%BE%80%E8%BF%94%E6%97%B6%E9%97%B4.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;7.利用率&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/%E5%88%A9%E7%94%A8%E7%8E%87.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;8.丢包率&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/%E4%B8%A2%E5%8C%85%E7%8E%87.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;常见的计算机网络体系结构&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;1.OSI体系 开放系统互连参考模型&lt;/p&gt;
&lt;p&gt;从下往上依次是物理层、数据链路层、网络层、运输层、会话层、表示层、应用层&lt;/p&gt;
&lt;p&gt;2.TCP/IP体系（事实上的国际标准）&lt;/p&gt;
&lt;p&gt;下往上依次是网络接口层、网际层、运输层、应用层&lt;/p&gt;
&lt;p&gt;3.原理体系结构【物理层、数据链路层、网络层、运输层、应用层】&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/tcpip.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;计算机网络体系结构分层的必要性&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;1.物理层&lt;/p&gt;
&lt;p&gt;2.数据链路层&lt;/p&gt;
&lt;p&gt;如何标识网络中的各主机（主机编址问题，例如MAC地址）&lt;/p&gt;
&lt;p&gt;如何从信号所表示的一连串比特流中区分出地址和数据&lt;/p&gt;
&lt;p&gt;如何协调各主机争用总线&lt;/p&gt;
&lt;p&gt;3.网络层&lt;/p&gt;
&lt;p&gt;如何标识各网络以及网络中的各主机 （网络和主机共同编址的问题，例如IP地址）&lt;/p&gt;
&lt;p&gt;路由器如何转发分组，如何进行路由选择&lt;/p&gt;
&lt;p&gt;4.运输层&lt;/p&gt;
&lt;p&gt;如何解决进程之间基于网络的通信问题&lt;/p&gt;
&lt;p&gt;出现传输错误时，如何处理&lt;/p&gt;
&lt;p&gt;5.应用层&lt;/p&gt;
&lt;p&gt;通过应用进程间的交互来完成特定的网络应用&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/%E5%8E%9F%E7%90%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;计算机网络体系结构分层思想举例&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&amp;lt;iframe width=&quot;100%&quot; height=&quot;468&quot; src=&quot;//player.bilibili.com/player.html?isOutside=true&amp;amp;aid=64605483&amp;amp;bvid=BV1c4411d7jb&amp;amp;cid=112162125&amp;amp;p=9&amp;amp;autoplay=0&quot; scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;no&quot; framespacing=&quot;0&quot; allowfullscreen=&quot;true&quot;&amp;gt; &amp;lt;/iframe&amp;gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;计算机网络体系结构专用术语&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;■实体：任何可发送或接收信息的硬件或软件进程&lt;/p&gt;
&lt;p&gt;■对等实体：收发双方相同层次中的实体&lt;/p&gt;
&lt;p&gt;■协议：控制两个对等实体进行逻辑通信的规则的集合&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/%E4%B8%93%E4%B8%9A%E6%9C%AF%E8%AF%AD1.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;■ 协议的三要素 （语法、语义、同步）&lt;/p&gt;
&lt;p&gt;□语法 定义所交换信息的格式&lt;/p&gt;
&lt;p&gt;□语义 定义收发双方所要完成的操作（上述分层思想举例内容）&lt;/p&gt;
&lt;p&gt;□同步 定义收发双方的时序关系&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/%E5%8D%8F%E8%AE%AE.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;■服务&lt;/p&gt;
&lt;p&gt;1.在协议的控制下，两个对等实体间的逻辑通信使得本层能够向上一层提供服务&lt;/p&gt;
&lt;p&gt;2.要实现本层协议，还需要使用下面一层所提供的服务。&lt;/p&gt;
&lt;p&gt;3.协议是&quot;水平的&quot;，服务是&quot;垂直的&quot;。&lt;/p&gt;
&lt;p&gt;4.实体看得见相邻下层所提供的服务，但并不知道实现该服务的具体协议。也就是说，下面的协议对上面的实体是&quot;透明&quot;（不可见）的。&lt;/p&gt;
&lt;p&gt;■服务访问点：在同一系统中相邻两层的实体交换信息的逻辑接口，用于区分不同的服务类型。&lt;/p&gt;
&lt;p&gt;□数据链路层的服务访问点为帧的&quot;类型&quot;字段&lt;/p&gt;
&lt;p&gt;□网络层的服务访问点为IP数据报首部中的&quot;协议字段&quot;&lt;/p&gt;
&lt;p&gt;□运输层的服务访问点为&quot;端口号&quot;&lt;/p&gt;
&lt;p&gt;■服务原语：上层使用下层所提供的服务必须通过与下层交换一些命令，这些命令称为服务原语&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/%E6%9C%8D%E5%8A%A1.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;■协议数据单元PDU：对等层次之间传送的数据包称为该层的协议数据单元&lt;/p&gt;
&lt;p&gt;■服务数据单元SDU：同一系统内，层与层之间交换的数据包称为服务数据单元。&lt;/p&gt;
&lt;p&gt;■多个SDU可以合成为一个PDU；一个SDU也可划分为几个PDU。（如上述举例中，在不同层中操作形成的SDU，传递给下一层变为PDU）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/%E6%95%B0%E6%8D%AE%E5%8D%95%E5%85%83.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h1&gt;&lt;strong&gt;物理层&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;解决在各种传输媒体上传输比特0和1的问题(数据比特流)；为数据链路层提供透明服务&lt;/p&gt;
&lt;p&gt;物理层协议的主要任务&lt;/p&gt;
&lt;p&gt;1.机械特性：指明接口所用接线器的&lt;strong&gt;形状&lt;/strong&gt;和&lt;strong&gt;尺寸&lt;/strong&gt;、&lt;strong&gt;引脚数目&lt;/strong&gt;和&lt;strong&gt;排列&lt;/strong&gt;、&lt;strong&gt;固定&lt;/strong&gt;和&lt;strong&gt;锁定&lt;/strong&gt;装置。&lt;/p&gt;
&lt;p&gt;2.电气特性：指明在接口电缆的各条线上出现&lt;strong&gt;电压的范围&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;3.功能特性：指明某条线上出现的某一电平的&lt;strong&gt;电压表示何种意义&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;4.过程特性：指明对于不同功能的各种可能&lt;strong&gt;事件的出现顺序&lt;/strong&gt;。&lt;/p&gt;
&lt;h2&gt;物理层下面的传输媒体&lt;/h2&gt;
&lt;p&gt;传输媒体也称为传输介质或传输媒介，是数据传输系统中在发送器和接收器之间的物理通路&lt;/p&gt;
&lt;p&gt;1.导引型传输媒体：双绞线、同轴电缆、光纤、电力线&lt;/p&gt;
&lt;p&gt;2.非导引型传输媒体：微波通信（2～40GHz）、无线电波、红外线、可见光&lt;/p&gt;
&lt;h2&gt;传输方式&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;1.串行传输——并行传输&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;■串行传输：是指一个比特一个比特依次发送，因此在发送接受段上只需要一条数据传输线路&lt;/p&gt;
&lt;p&gt;■并行传输：是指一次发送N个比特，因此发送接受段之间需要N条传输线路。&lt;/p&gt;
&lt;p&gt;在计算机网络中，数据传输的主要方式是串行传输，而计算机内部主要方式是并行传输&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.同步传输——异步传输——时钟同步&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;■同步传输：数据块以稳定的比特流形式传输，字节之间无间隔&lt;/p&gt;
&lt;p&gt;■时钟同步：接受端在每个比特信号的中间时刻进行检测0、1；&lt;/p&gt;
&lt;p&gt;不同设备的&lt;strong&gt;时钟频率不同&lt;/strong&gt;会导致接收端对比特信号的&lt;strong&gt;判别错位&lt;/strong&gt;并使得&lt;strong&gt;时刻误差积累。需要采取方法使得收发双方时钟保持同步&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;□外同步：在收发双方之间添加一条单独的时钟信号线&lt;/p&gt;
&lt;p&gt;□内同步：发送端将时钟同步信号编码到发送数据中一起传输（例如曼彻斯特编码）&lt;/p&gt;
&lt;p&gt;■异步传输：以字节为独立的传输单位，&lt;strong&gt;字节之间的时间间隔不固定&lt;/strong&gt;；接收端仅在每个字节起始处对字节的比特实现同步，为此&lt;strong&gt;在每个字节前后分别加上起始位和结束位&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;□字节之间异步：字节之间的时间间隔不固定&lt;/p&gt;
&lt;p&gt;□字节中的每个比特仍然要同步：各比特的持续时间是相同的&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.单向通信、双向交替通信、双向同时通信&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;■单向通信（单工）：通信双方只有一个数据传输方向；例如无线电广播&lt;/p&gt;
&lt;p&gt;■双向交替通信（半双工）：通信双方可以互相传输数据，但不能同时进行；例如对讲机&lt;/p&gt;
&lt;p&gt;■双向同时通信（全双工）：通信双方可以同时发送接受信息；例如电话&lt;/p&gt;
&lt;p&gt;单工需要一条信道，除单工以外都需要两条信道（每个方向各一条）&lt;/p&gt;
&lt;h2&gt;编码与调制&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;编码：&lt;/strong&gt; 将信号转换成数字信号&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;调制：&lt;/strong&gt; 将信号转换成模拟信号&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;模拟信号&lt;/strong&gt;：是用连续变化的物理量表示的信息&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数字信号&lt;/strong&gt;：是用离散的数值表示的信息&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;码元&lt;/strong&gt;：在使用时间域的波形表示数字信号时，代表不同离散数值的基本波形。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;数字信号是通过对模拟信号进行采样、量化和编码而得到的&lt;/p&gt;
&lt;p&gt;在计算机网络中，常见的是将数字基带信号通过编码或调制的方法在相应信道进行传输&lt;/p&gt;
&lt;p&gt;传输媒体不完全等于信道，因为存在半双工、全双工传输含有双信道，信道复用技术含有多个信道&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;images/Capture_20240715_160103.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;常用编码&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;■不归零编码NRZ&lt;/strong&gt;：所谓不归零编码，就是指在整个码元时间内，电平不会出现零电平（位于正负电平中间）&lt;/p&gt;
&lt;p&gt;（因为存在同步问题，计算机网络中的数据传输不采用此类编码）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/Screenshot_20240715_162340.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;■&lt;strong&gt;归零编码RZ&lt;/strong&gt; return zero（自同步，编码效率低）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/Capture_20240715_163355.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;■&lt;strong&gt;曼彻斯特编码&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下面理解时，注意区分比特0、1是在每个码元的中间时刻进行判定&lt;/p&gt;
&lt;p&gt;正电平跳负电平为比特1&lt;/p&gt;
&lt;p&gt;负电平跳正电平为0&lt;/p&gt;
&lt;p&gt;■&lt;strong&gt;差分曼彻斯特编码&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;差分曼彻斯特编码的比特流变化可以概述为，以第一个为基准（1），其后面为0时，变化趋势复制，当再遇到1时，取反，此刻基准变为此刻的1，后面也是如此往复&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/Capture_20240715_170320.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;基本调制方法&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;images/Capture_20240715_174148.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;调幅（Am)：即载波的振幅随基带数字信号而变化。例如，0或 1 分别对应于无载波或有载波输出。&lt;br /&gt;
调频（FM)：即载波的频率随基带数字信号而变化。例如，0或1分别对应于频率f1或f2。&lt;br /&gt;
调相（pm)：即载波的初始相位随基带数字信号而变化。例如，0或1分别对应于相位0度或180度&lt;/p&gt;
&lt;h2&gt;混合调制&lt;/h2&gt;
&lt;p&gt;频率+相位：因为&lt;strong&gt;频率和相位是相关&lt;/strong&gt;的，即频率是相位随时间的&lt;strong&gt;变化率&lt;/strong&gt;。所以一次只能调制频率和相位两个中的一个&lt;/p&gt;
&lt;p&gt;相位+振幅：通常情况下，相位和振幅可以结合起来一起调制，称为正反振幅调制QAM&lt;/p&gt;
&lt;p&gt;（通信专业相关内容，此处听不懂........）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/Capture_20240715_175124.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;信道的极限容量&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;码间串扰&lt;/strong&gt;：输入的信号波形经过信道之后，输出的信号波失真严重导致无法识别&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;失真的因素&lt;/strong&gt;：码元传输速率；信号传输距离；噪声干扰、传输媒体质量&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/Capture_20240715_175828.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;奈氏准则&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;重点为调制速率等&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2024-07-15-182832.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;只要采用更好的调制方法,让码元可以携带更多的比特,岂不是可以无限制地提高信息的传输速率?&lt;/p&gt;
&lt;p&gt;答案是否定的。因为信道的极限信息传输速率还要受限于实际的信号在信道中传输时的信噪比。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;香农公式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;重点为信道带宽、信噪比等&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意此处信噪比有两种形式（数字形式和分贝形式）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2023-09-25-213504.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;在信道带宽一定的情况下,根据奈氏准则和香农公式,要想提高信息的传输速率就必须采用多元制(更好的调制方法)和努力提高信道中的信噪比。&lt;/p&gt;
&lt;h1&gt;数据链路层&lt;/h1&gt;
&lt;h2&gt;概述&lt;/h2&gt;
&lt;p&gt;链路、数据链路、帧&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/Capture_20240730_101301.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;三个重要问题&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;点对点信道的数据链路层&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;封装成帧&lt;/h3&gt;
&lt;p&gt;添加帧头帧尾的目的都是为了在链路上以帧为单位进行传输数据&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/Capture_20240730_104035.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;差错检测&lt;/h3&gt;
&lt;p&gt;帧在物理层传输过程中会出现误码，接收方通过&lt;strong&gt;检错码&lt;/strong&gt;检测帧中是否有误码&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/Capture_20240730_104942.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;可靠传输&lt;/h3&gt;
&lt;p&gt;尽管在传输过程中无法避免误码，确保发送方发送什么接收方能接受什么&lt;/p&gt;
&lt;h3&gt;其他问题&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;如果使用广播信道的数据链路层除了包含上面三个问题外，还有一些问题要解决&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;问题一&lt;/strong&gt;：对于广播信道传输，当发出方主机A发送数据给接收方主机C时，代表帧的信号通过总线传输到各个主机。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;各个主机如何判断帧是否是传输给自己的？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/mmexport1722325323593.webp&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;答：通过将帧的目的地址添加在帧中一起传输进行判断&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20240730.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;**问题二：**数据碰撞问题，在共享信道中，当有多个主机进行传输帧信号，发生碰撞时，通过CSMA/CD协议解决问题&lt;img src=&quot;images/mmexport1722326120548.webp&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在有线领域网中，使用点对点链路和链路层交换机的交换式局域网&lt;br /&gt;
在无线局域网中，使用的是共享信道技术&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;封装成帧&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;封装成帧&lt;/strong&gt;是指数据链路层给上层交付的协议数据单元添加帧头和帧尾使之成为帧&lt;/p&gt;
&lt;p&gt;□帧头和帧尾中包含有重要的控制信息&lt;/p&gt;
&lt;p&gt;□帧头和帧尾的作用之一就是帧定界&lt;/p&gt;
&lt;p&gt;&amp;lt;figure&amp;gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/Capture_20240730_161838-1024x356.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;figcaption&amp;gt;&lt;/p&gt;
&lt;p&gt;PPP帧格式&lt;/p&gt;
&lt;p&gt;&amp;lt;/figcaption&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;/figure&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;figure&amp;gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/Capture_20240730_161805-1024x375.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;figcaption&amp;gt;&lt;/p&gt;
&lt;p&gt;MAC帧相较于PPP帧，其帧头中无帧定界&lt;/p&gt;
&lt;p&gt;&amp;lt;/figcaption&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;/figure&amp;gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;透明传输&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;是指数据链路层不对上层交付的传输数据进行任何限制&lt;/p&gt;
&lt;p&gt;在帧的数据部分中，存在部分数据内容与帧定界一致，为不影响接收方正常接受完整的数据内容采取以下方法：&lt;/p&gt;
&lt;p&gt;□字节填充：在与帧定界内容一致的数据内容前（包括转义字符）添加转义字符&lt;/p&gt;
&lt;p&gt;□比特填充：在与帧定界内容一致的数据内容前添加比特&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/Capture_20240730_163218.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;帧的数据部分长度&lt;/h3&gt;
&lt;p&gt;1.为了提高帧的传输效率，应当使帧的数据部分的长度尽可能大些。&lt;br /&gt;
2.考虑到差错控制等多种因素，每一种数据链路层协议都规定了帧的数据部分的长度上限，即最大传送单元MTU (Maximum Transfer Unit)。&lt;/p&gt;
&lt;h2&gt;差错检测&lt;/h2&gt;
&lt;p&gt;**比特差错：**实际的通信链路都不是理想的，比特在传输过程中可能会产生差错：1可能会变成0,而0也可能变成1&lt;/p&gt;
&lt;p&gt;**误码率：**传输错误的比特占所传输比特总数的比率称为误码率BER(Bit Error Rate)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用差错检测码（尾中FCS字段的检错码）来检测数据在传输过程中是否产生了比特差错，是数据链路层所要解决的重要问题之一。&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;奇偶校验&lt;/h3&gt;
&lt;p&gt;□在待发送的数据后面添加1位奇偶校验位，使整个数据（包括所添加的校验位在内）中&quot;1&quot;的个数为奇数（奇校验）或偶数（偶校验）&lt;/p&gt;
&lt;p&gt;□如果有奇数个位发生误码，则奇偶性发生变化，可以检查出误码&lt;br /&gt;
    □如果有偶数个位发生误码，则奇偶性不发生变化，不能检查出误码（漏检）&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;由于奇偶校验漏检率高，计算机网络数据链路层中一般不采用该方法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;images/Capture_20240730_165203.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;循环冗余校验&lt;/h3&gt;
&lt;p&gt;循环冗余校验CRC（Cyclic Redundancy Check）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/Capture_20240730_170438.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;例如：1.约定的多项式为 G (x) = x^4 - x^2 + x - 1&lt;/p&gt;
&lt;p&gt;2.生成多项式各项系数构成的比特串为10111&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1&lt;/strong&gt;*  x^4 + &lt;strong&gt;0&lt;/strong&gt;  *x^3 - &lt;strong&gt;1&lt;/strong&gt;*  x^2 + &lt;strong&gt;1&lt;/strong&gt;*  x - &lt;strong&gt;1&lt;/strong&gt;*  x^0&lt;/p&gt;
&lt;p&gt;3.生成多项式最高次个0 为 0000&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;常用的生成多项式(算法要求生成多项式必须包含最低次项，即x^0)&lt;/p&gt;
&lt;p&gt;$$
CRC-16=x^{16}+x^{15}+x^{2}+1
$$&lt;/p&gt;
&lt;p&gt;$$
CRC-CCITT=x^{16}+x^{12}+x^{5}+1
$$&lt;/p&gt;
&lt;p&gt;$$
CRC-32=x^{32}+x^{26}+x^{23}+x^{22}+x^{16}+x^{12}+x^{11}+x^{10}+x^{8}+x^{7}+x^{5}+x^{4}+x^{2}+x+1
$$&lt;/p&gt;
&lt;h4&gt;例题&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;images/Capture_20240730_173858.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/Capture_20240730_174258.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;关于&lt;/h3&gt;
&lt;p&gt;■检错码只能检测出帧在传输过程中出现了差错，但并&lt;strong&gt;不能定位错误&lt;/strong&gt;，因此&lt;strong&gt;无法纠正错误&lt;/strong&gt;。&lt;br /&gt;
■ 要想纠正传输中的差错，可以&lt;strong&gt;使用冗余信息更多的纠错码进行前向纠错&lt;/strong&gt;。但纠错码的开销比较大，在计算机网络中较少使用。&lt;br /&gt;
■ 循环冗余校验CRC有很好的检错能力（漏检率非常低），虽然计算比较复杂，但非常易于用硬件实现，因此被&lt;strong&gt;广泛应用于数据链路层&lt;/strong&gt;。&lt;br /&gt;
■ 在计算机网络中通常采用&lt;strong&gt;检错重传方式&lt;/strong&gt;来纠正传输中的差错，或者仅仅是丢弃检测到差错的帧，这取决于数据链路层向其上层提供的是可靠传输服务还是不可靠传输服务。&lt;/p&gt;
&lt;h2&gt;可靠传输&lt;/h2&gt;
&lt;h3&gt;基本概念&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;images/Capture_20240730_175310.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;数据链路层不一定要实现可靠传输，有线链路一般不需要实现可靠传输，无线局域网数据链路层要实现可靠传输，数据链路层可靠是点对点的可靠，并不是真的可靠，主要保证物理层的可靠&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/Capture_20240730_180055.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;可靠传输的实现机制&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;停止﹣等待协议SW 、回退N帧协议GBN、选择重传协议SR&lt;br /&gt;
这三种可靠传输实现机制的基本原理不仅限于数据链路层，可以应用到计算机网络体系结构的各层协议中。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;停止﹣等待协议SW&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;images/Capture_20240730_181515.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/Capture_20240730_182025.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/Capture_20240730_182757.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;【注意事项】&lt;br /&gt;
■接收端检测到数据分组有误码时，将其丢弃并等待发送方的超时重传。但对于误码率较高的点对点链路，为使发送方&lt;strong&gt;尽早重传&lt;/strong&gt;，也&lt;strong&gt;可给发送方发送NAK分组&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;■为了让接收方能够判断所收到的数据分组是否是重复的，需要给&lt;strong&gt;数据分组编号&lt;/strong&gt;。由于停止﹣等待协议的停等特性，&lt;strong&gt;只需1个比特编号&lt;/strong&gt;就够了，即编号0和1。&lt;br /&gt;
■为了让发送方能够判断所收到的ACK分组是否是重复的，需要给&lt;strong&gt;ACK分组编&lt;/strong&gt;号，所用比特数量&lt;strong&gt;与数据分组编号所用比特数量一样&lt;/strong&gt;。数据链路层一般不会出现ACK分组迟到的情况，因此在&lt;strong&gt;数据链路层实现停止﹣等待协议可以不用给ACK分组编号&lt;/strong&gt;。&lt;br /&gt;
■超时计时器设置的&lt;strong&gt;重传时间&lt;/strong&gt;应仔细选择。一般可将重传时间选为&lt;strong&gt;略大于&quot;从发送方到接收方的平均往返时间&quot;&lt;/strong&gt;。&lt;br /&gt;
    □在数据链路层点对点的往返时间比较确定，重传时间比较好设定。&lt;br /&gt;
    □ 然而在运输层，由于端到端往返时间非常不确定，设置合适的重传时间有时并不容易。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;对于数据链路层点对点信道而言，往返时间比较固定，不会出现确认迟到的情况&lt;/p&gt;
&lt;p&gt;因此如果只在数据链路层实现SW协议，可以不用对确认分组进行编号&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;SW的信道利用率&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;images/Capture_20240731_100927.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;回退N帧协议GBN&lt;/h3&gt;
&lt;p&gt;■停止﹣等待协议的信道利用率很低若出现超时重传，则信道利用率更低&lt;/p&gt;
&lt;p&gt;■采用流水线传输可提高信道利用率&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;采用N个比特确认分组序号&lt;/p&gt;
&lt;p&gt;发送窗口的大小在1&amp;lt; WT≤­­2N-1区间范围内&lt;/p&gt;
&lt;p&gt;接受窗口只能为 WR=1&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;images/Capture_20240731_111311.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h4&gt;无差错情况&lt;/h4&gt;
&lt;p&gt;①当发送方发送多个数据分组时，接收方在确认分组无差错后，每接受一个分组后窗口向后移动一个位置并发送确认分组；&lt;/p&gt;
&lt;p&gt;②发送方接受确认分组后，每接受一个确认分组后窗口向后移动一个位置&lt;/p&gt;
&lt;p&gt;③完成上述任务后，发送方将收到确认分组的数据从缓存中删去；接收方可将接受的数据交付上层处理&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/Capture_20240731_111730-e1722396673600.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h4&gt;累计确认&lt;/h4&gt;
&lt;p&gt;接收方&lt;strong&gt;不一定要对收到的数据分组逐个发送确认&lt;/strong&gt;，而是可以在收到几个数据分组后（由具体实现决定），&lt;strong&gt;对按序到达的最后一个数据分组发送确认&lt;/strong&gt;。ACKn表示序号为n及以前的所有数据分组&lt;strong&gt;都已正确接收&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;接受后无需逐一发送确认，赶紧实际情况发送累计确认，即使ACK1丢失，ACK4被发送方接受后，知道分组被正确接受，发送窗口依旧可以移动&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;images/Capture_20240731_113606.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h4&gt;有差错情况&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;当接收窗口与分组序号匹配不一致时，接收方会发送之前最后一组的确认分组信号；&lt;/p&gt;
&lt;p&gt;发送方收到重复的确认，就知道出现了差错，即可重新发送；&lt;/p&gt;
&lt;p&gt;除此之外，发送方也可以等待超时计时器超时并重新发送&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;images/Capture_20240731_115222.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;[admonition]在本例中，尽管序号为6,7,0,1的数据分组正确到达接收方，但由于5号数据分组误码不被接受，它们也&quot;受到牵连&quot;而不被接受，发送方还要重传这些数据分组，这就是所谓的Go-back-N（回退N帧）。[/admonition]&lt;/p&gt;
&lt;h4&gt;总结&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;images/Capture_20240731_115935.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;选择重传协议SR&lt;/h3&gt;
&lt;p&gt;■回退N帧协议的接收窗口尺寸&lt;strong&gt;WR只能等于1&lt;/strong&gt;，因此接收方&lt;strong&gt;只能按序接收正确到达的数据分组&lt;/strong&gt;。&lt;br /&gt;
■一个数据分组的误码就会导致其后续多个数据分组不能被接收方按序接收而丢弃（尽管它们无乱序和误码）。这必然会造成发送方对这些数据分组的超时重传，显然这是对&lt;strong&gt;通信资源的极大浪费&lt;/strong&gt;。&lt;br /&gt;
■为了进一步提高性能，可设法只重传出现误码的数据分组。因此，&lt;strong&gt;接收窗口的尺寸WR不应再等于1&lt;/strong&gt;（而应大于1)，以便接&lt;strong&gt;收方先收下失序到达但无误码并且序号落在接收窗口内的那些数据分组，等到所缺分组收齐后再一并送交上层&lt;/strong&gt;。这就是选择重传协议。&lt;/p&gt;
&lt;p&gt;[admonition]注意：&lt;br /&gt;
选择重传协议为了使发送方仅重传出现差错的分组，接收方不能再采用累积确认，而需要对每个正确接收到的数据分组进行逐一确认！[/admonition]&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/Capture_20240731_121437.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;当接收方&lt;strong&gt;按序&lt;/strong&gt;收到一个正确分组后，窗口才可移动；&lt;/p&gt;
&lt;p&gt;接收方非按序收到，窗口不可移动，等待发送方后续超时计时器超时重新发送接受；&lt;/p&gt;
&lt;p&gt;发送方同理&lt;strong&gt;按序&lt;/strong&gt;收到一个正确分组后，窗口才可移动；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;images/Capture_20240731_123457.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/Capture_20240731_123535.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h4&gt;总结&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;images/Capture_20240731_122124.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;点对点协议PPP&lt;/h2&gt;
&lt;h3&gt;简介&lt;/h3&gt;
&lt;p&gt;■ 点对点协议PPP(Point-to-Point Protocol）是目前使用最广泛的点对点数据链路层协议。&lt;/p&gt;
&lt;p&gt;■ PPP协议是因特网工程任务组IETF在1992年制定的。经过1993年和1994年的修订，现在的PPP协议已成为因特网的正式标准［RFC1661,RFC1662]。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/Capture_20240731_151457.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;■ PPP协议为在点对点链路传输各种协议数据报提供了一个标准方法，主要由以下三部分构成：&lt;/p&gt;
&lt;p&gt;□ 对各种协议数据报的封装方法（封装成帧）&lt;br /&gt;
    □ 链路控制协议LCP     用于建立、配置以及测试数据链路的连接&lt;br /&gt;
    □ 一套网络控制协议NCPs     其中的每一个协议支持不同的网络层协议&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/Capture_20240731_161315.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;帧格式&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;images/Capture_20240731_163430.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;PPP的透明传输&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;images/Capture_20240731_164454.jpg&quot; alt=&quot;&quot; /&gt; &lt;img src=&quot;images/Capture_20240731_164519.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;PPP的差错检测&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;images/Capture_20240731_164748.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;媒体接入控制&lt;/h2&gt;
&lt;h3&gt;基本概念&lt;/h3&gt;
&lt;p&gt;共享信道要着重考虑的一个问题就是如何协调多个发送和接收站点对一个共享传输媒体的占用，即&lt;strong&gt;媒体接入控制MAC&lt;/strong&gt;(Medium Access Control)。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/Capture_20240801_150421.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;分类&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/Capture_20240801_152258.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;静态划分信道&lt;/h3&gt;
&lt;p&gt;信道复用&lt;/p&gt;
&lt;p&gt;■ 复用（Multiplexing）是通信技术中的一个重要概念。复用就是通过一条物理线路同时传输多路用户的信号。&lt;br /&gt;
■ 当网络中传输媒体的传输容量大于多条单一信道传输的总通信量时，可利用复用技术在一条物理线路上建立多条通信信道来充分利用传输媒体的带宽。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/Capture_20240801_153138.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h4&gt;频分复用FDM&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;images/Capture_20240801_153934.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h4&gt;时分复用TDM&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;images/Capture_20240801_154021.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h4&gt;波分复用WDM&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;images/Capture_20240801_154252.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h4&gt;码分复用CDM&lt;/h4&gt;
&lt;p&gt;简介与特点&lt;/p&gt;
&lt;p&gt;■ 码分复用CDM是另一种共享信道的方法，因主要用于多址接入，&lt;strong&gt;常称为码分多址CDMA&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;■ 同理也有频分多址FDMA、时分多址TDMA&lt;/p&gt;
&lt;p&gt;■ 复用与多址区别&lt;/p&gt;
&lt;p&gt;□ 复用是指“多个共同使用的”意思；目的是让多个信号源共同使用同一个物理资源（比如同一条物理信道），并且互不干扰；&lt;/p&gt;
&lt;p&gt;□ 多址为了让用户地址之间互不干扰，地址之间必须满足相互正交；目的是来区分不同用户的一种技术；&lt;/p&gt;
&lt;p&gt;■ 相较于FDM、TDM，CDM的每一个用户可以在&lt;strong&gt;同样的时间使用同样的频带进行通信&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;■ 因为各用户使用经过特殊挑选的&lt;strong&gt;不同码型&lt;/strong&gt;，各用户之间&lt;strong&gt;不会造成干扰&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;具体实现&lt;/p&gt;
&lt;p&gt;■ 在CDMA中，每个比特时间被&lt;strong&gt;划分为m个短的间隔&lt;/strong&gt;，称为&lt;strong&gt;码片（Chip）&lt;/strong&gt;。通常m=64或128&lt;/p&gt;
&lt;p&gt;■ CMDA的每一个站被指派一个&lt;strong&gt;唯一的m bit 码片序列&lt;/strong&gt;（Chip Sequence）&lt;/p&gt;
&lt;p&gt;□ 某个站如果发送&lt;strong&gt;比特1&lt;/strong&gt;，发送自己的&lt;strong&gt;码片序列&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;□ 某个站如果发送&lt;strong&gt;比特0&lt;/strong&gt;，发送自己的&lt;strong&gt;码片序列的二进制反码&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;□ 例如：某站点唯一码片序列为：11110000，发送比特1为11110000，发送比特0为00001111&lt;/p&gt;
&lt;p&gt;通常情况，我们将二进制的1表示为+1，0表示-1。即上述码片序列为（+1,+1,+1,+1,-1,-1,-1,-1）&lt;/p&gt;
&lt;p&gt;■ 这种通信方式称为直接序列扩频 DSSS&lt;/p&gt;
&lt;p&gt;■ &lt;strong&gt;码片序列的挑选原则&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1. 分配给每个站的码片序列&lt;strong&gt;必须各不相同&lt;/strong&gt;，常采用伪随机码序列&lt;/p&gt;
&lt;p&gt;2. 分配给每个站的码片序列必须相互正交（规格化内积为0）&lt;/p&gt;
&lt;p&gt;向量S:表示站S的码片序列；向量T表示其他任何站的码片序列&lt;/p&gt;
&lt;p&gt;码片序列相互正交就是向量S和T规格化内积为0&lt;/p&gt;
&lt;p&gt;$$
S\cdot T = \frac{1}{m}\sum_{i=1}^{m}S_{i}T_{i} = 0
$$&lt;/p&gt;
&lt;p&gt;$$
S\cdot S = \frac{1}{m}\sum_{i=1}^{m}S_{i}S_{i} = 1
$$&lt;/p&gt;
&lt;p&gt;$$
S\cdot \bar{T} \equiv 0
$$&lt;/p&gt;
&lt;p&gt;$$
S\cdot \bar{S} \equiv -1
$$&lt;/p&gt;
&lt;p&gt;例题练习&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/Capture_20240801_165849.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/Capture_20240801_170205.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;动态接入控制——随机接入&lt;/h3&gt;
&lt;h4&gt;载波监听多址接入/碰撞检测   CSMA/CD&lt;/h4&gt;
&lt;p&gt;总线局域网使用的协议&lt;/p&gt;
&lt;p&gt;■ 多址接入MA：多个站&lt;strong&gt;连接在一条总线上&lt;/strong&gt;，竞争使用总线&lt;/p&gt;
&lt;p&gt;■ 载波监听CS：每一个站在发送帧之前先要检测一下总线上是否有其他站点在发送帧&lt;br /&gt;
        □ 若检测到总线空闲96比特时间（&lt;strong&gt;帧间最小间隔&lt;/strong&gt;）则发送这个帧；&lt;br /&gt;
        □ 若检测到总线忙，则继续检测并等待总线转为空闲96比特时间，然后发送这个帧。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;帧间最小间隔：使接收方检测出一个帧的结束，同时使得所有其他站点能够有机会平等竞争信道发送帧&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;■ 碰撞检测CD：每一个正在发送帧的站，&lt;strong&gt;边发送边检测碰撞&lt;/strong&gt;；一旦发现总线出现碰撞，则停止发送，退避一段随机时间后再次发送&lt;/p&gt;
&lt;h5&gt;争用期（碰撞窗口）&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;images/Capture_20240802_150351.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h5&gt;最小帧长&lt;/h5&gt;
&lt;p&gt;最小帧长＝争用期x数据传输速率&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/Capture_20240802_162249.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h5&gt;最大帧长&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;images/Capture_20240802_163643.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h5&gt;截断二进制指数退避算法&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;images/Capture_20240802_164345.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h5&gt;信道利用率&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;images/Capture_20240802_165109.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h5&gt;帧接受流程&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;images/Capture_20240802_165303.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h4&gt;载波监听多址接入/碰撞避免  CSMA/CA&lt;/h4&gt;
&lt;p&gt;无线局域网使用的协议&lt;/p&gt;
&lt;p&gt;■ &lt;strong&gt;在无线局域网中，仍然可以使用载波监听多址接入CSMA&lt;/strong&gt;，即在发送帧之前先对传输媒体进行载波监听。若发现有其他站在发送帧，就推迟发送以免发生碰撞。&lt;/p&gt;
&lt;p&gt;■ 在无线局域网中，不能使用碰撞检测CD，原因如下：&lt;br /&gt;
         □ 由于无线&lt;strong&gt;信道的传输条件特殊&lt;/strong&gt;，其信号强度的&lt;strong&gt;动态范围非常大&lt;/strong&gt;，无线网卡上接收到的信号强度往往会远远小于发送信号的强度（可能相差百万倍）。如果要&lt;strong&gt;在无线网卡上实现碰撞检测CD，对硬件的要求非常高&lt;/strong&gt;。&lt;br /&gt;
         □ 即使能够在硬件上实现无线局域网的碰撞检测功能，但由于无线电波传播的特殊性（存在隐蔽站问题），进行碰撞检测的意义也不大。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/Capture_20240804_133134.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h5&gt;帧间间隔IFS(InterFrame Space)&lt;/h5&gt;
&lt;p&gt;■ 802.11标准规定，所有的站点必须在&lt;strong&gt;持续检测到信道空闲一段指定时间后才能发送帧&lt;/strong&gt;，&lt;strong&gt;这段时间称为帧间间隔&lt;/strong&gt;IFS。&lt;br /&gt;
 ■ 帧间间隔的长短取决于该站点要发送的帧的类型：&lt;br /&gt;
        □ 高优先级帧需要等待的时间较短，因此可优先获得发送权；&lt;/p&gt;
&lt;p&gt;□ 低优先级帧需要等待的时间较长。若某个站的低优先级帧还没来得及发送，而其他站的高优先级帧已发送到信道上，则信道变为忙态，因而低优先级帧就只能再推迟发送了。这样就减少了发生碰撞的机会。&lt;/p&gt;
&lt;p&gt;■ 常用的两种帧间间隔如下：&lt;/p&gt;
&lt;p&gt;□ &lt;strong&gt;短帧间间隔SIFS&lt;/strong&gt;(28us)：是最短的帧间间隔，用来分隔开属于一次对话的各帧。一个站点应当能够在这段时间内从发送方式切换到接收方式。使用SIFS的帧类型有ACK帧、CTS帧、由过长的MAC帧分片后的数据帧、以及所有回答AP探询的帧和在PCF方式中接入点AP发送出的任何帧。&lt;/p&gt;
&lt;p&gt;□ &lt;strong&gt;DCF帧间间隔DIFS&lt;/strong&gt;(128us)：它比短帧间间隔SIFS要长得多，在DCF方式中用来发送数据帧和管理帧。&lt;/p&gt;
&lt;h5&gt;工作原理&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;images/Capture_20240804_221131.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1. 源站为什么在检测到信道空闲后还要再等待一段时间DIFS?&lt;/p&gt;
&lt;p&gt;答：考虑到可能有其他的站有高优先级的帧要发送。若有，就要让高优先级帧先发送。&lt;/p&gt;
&lt;p&gt;2. 目的站为什么正确接收数据帧后还要等待一段时间SIFS才能发送ACK帧？&lt;/p&gt;
&lt;p&gt;答：SIFS是最短的帧间间隔，用来分隔开属于一次对话的各帧。在这段时间内，一个站点应当能够从发送方式切换到接收方式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;■ 当站点检测到信道是空闲的，并且所发送的数据帧不是成功发送完上一个数据帧之后立即连续发送的数据帧，则不使用退避算法。&lt;br /&gt;
 ■ 以下情况必须使用退避算法：&lt;br /&gt;
         □ 在发送数据帧之前检测到信道处于忙状态时；&lt;br /&gt;
         □ 在每一次重传一个数据帧时；&lt;br /&gt;
         □ 在每一次成功发送后要连续发送下一个帧时（这是为了避免一个站点长时间占用信道）。&lt;/p&gt;
&lt;h5&gt;退避算法&lt;/h5&gt;
&lt;p&gt;■ 在执行退避算法时，站点为退避计时器设置一个随机的退避时间：&lt;br /&gt;
        □ 当退避计时器的&lt;strong&gt;时间减小到零&lt;/strong&gt;时，就开始&lt;strong&gt;发送数据&lt;/strong&gt;；&lt;br /&gt;
        □ 当退避计时器的时间还&lt;strong&gt;未减小到零时而信道又转变为忙状态&lt;/strong&gt;，这时就&lt;strong&gt;冻结退避计时器的数值&lt;/strong&gt;，重新&lt;strong&gt;等待信道变为空闲&lt;/strong&gt;，再&lt;strong&gt;经过时间DIFS后&lt;/strong&gt;，&lt;strong&gt;继续启动退避计时器&lt;/strong&gt;。&lt;br /&gt;
■ 在进行第i次退避时，退避时间在时隙编号｛0,1,.,22+i-1｝中随机选择一个，然后乘以基本退避时间（也就是一个时隙的长度）就可以得到随机的退避时间。这样做是为了使不同站点选择相同退避时间的概率减少。当时隙编号达到255时（对应于第6次退避）就不再增加了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/Capture_20240804_215734.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h5&gt;信道预约&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;images/Capture_20240804_222729.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/Capture_20240804_224110.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h5&gt;虚拟载波监听&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;images/Capture_20240804_224435.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;MAC地址、IP地址以及ARP协议&lt;/h2&gt;
&lt;p&gt;■ 数据链路层中：MAC地址是以太网的MAC子层所使用的地址；&lt;/p&gt;
&lt;p&gt;■ 网际层中：&lt;/p&gt;
&lt;p&gt;1. IP地址是TCP/IP体系结构网际层所使用的地址；&lt;/p&gt;
&lt;p&gt;2. ARP协议属于TCP/IP体系结构的网际层，其作用是已知设备所分配到的IP地址，使用ARP协议可以通过该IP地址获取到设备的MAC地址；&lt;/p&gt;
&lt;p&gt;■ 尽管IP地址和ARP协议属于TCP/IP体系结构的网际层（而不属于数据链路层），但是它们与MAC地址存在一定的关系，并且我们日常的网络应用都离不开MAC地址、IP地址以及ARP协议。因此，我们将这三者放在一起讨论。&lt;/p&gt;
&lt;h3&gt;MAC地址&lt;/h3&gt;
&lt;p&gt;■ 当多个主机连接在同一个广播信道上，要想实现两个主机之间的通信，则每个主机都&lt;strong&gt;必须有一个唯一的标识，即一个数据链路层地址&lt;/strong&gt;；&lt;br /&gt;
 ■ 在每个主机发送的帧中&lt;strong&gt;必须携带标识发送主机和接收主机的地址&lt;/strong&gt;。由于这类地址是用于&lt;strong&gt;媒体接入控制&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;MAC&lt;/strong&gt;(Media Access Control)，因此这类地址&lt;strong&gt;被称为MAC地址&lt;/strong&gt;；&lt;br /&gt;
         □ MAC地址一般被固化在网卡（网络适配器）的电可擦可编程只读存储器EEPROM中，因此MAC地址也被称为硬件地址；&lt;br /&gt;
         □ MAC地址有时也被&lt;strong&gt;称为物理地址&lt;/strong&gt;。请注意：这并不意味着MAC地址属于网络体系结构中的物理层！&lt;br /&gt;
 ■ 一般情况下，用户主机会包含两个网络适配器：有线局域网适配器（有线网卡）和无线局域网适配器（无线网卡）。每个网络适配器都有一个全球唯一的MAC地址。而交换机和路由器往往拥有更多的网络接口，所以会拥有更多的MAC地址。综上所述，严格来说，&lt;strong&gt;MAC地址是对网络上各接口的唯一标识，而不是对网络上各设备的唯一标识&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/Capture_20240805_160646.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h4&gt;MAC地址格式&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;images/Capture_20240805_160948.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/Capture_20240805_164738.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h4&gt;MAC地址发送顺序&lt;/h4&gt;
&lt;p&gt;如上上图&lt;/p&gt;
&lt;p&gt;字节发送顺序：1——&amp;gt;6&lt;/p&gt;
&lt;p&gt;字节内比特发送顺序：b0——&amp;gt;b7&lt;/p&gt;
&lt;h4&gt;单播MAC地址&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;images/Capture_20240805_165348.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h4&gt;广播MAC地址&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;images/Capture_20240805_165600.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h4&gt;多播MAC地址&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;images/Capture_20240805_170803.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h4&gt;随机MAC地址&lt;/h4&gt;
&lt;h3&gt;IP地址&lt;/h3&gt;
&lt;p&gt;■ IP地址是因特网（Internet）上的主机和路由器所使用的地址，用于标识两部分信息：&lt;/p&gt;
&lt;p&gt;□ 网络编号：标识因特网上数以百万计的网络&lt;/p&gt;
&lt;p&gt;□ 主机编号：标识同一网络上不同主机（或路由器各接口）&lt;/p&gt;
&lt;p&gt;■ MAC地址&lt;strong&gt;不具备区分不同网络的功能&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;□ 如果只是一个单独的网络，&lt;strong&gt;不接入因特网，可以只使用MAC地址&lt;/strong&gt;（这不是一般用户的应用方式）。&lt;/p&gt;
&lt;p&gt;□ 如果&lt;strong&gt;主机所在的网络要接入因特网&lt;/strong&gt;，则IP地址和MAC地址&lt;strong&gt;都需要使用&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/Capture_20240806_100704-e1722910113776.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/Capture_20240806_151036.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;ARP协议&lt;/h3&gt;
&lt;p&gt;地址解析协议&lt;/p&gt;
&lt;h4&gt;思路过程&lt;/h4&gt;
&lt;p&gt;通过ARP协议，获得IP地址对应设备的MAC地址&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/Capture_20240806_153617.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;在本地ARP高速缓存中，若未找到对应的MAC地址，发送ARP请求报文（广播）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/Capture_20240806_153859.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;被请求方收到请求后，发送响应报文（单播）；&lt;/p&gt;
&lt;p&gt;请求方收到响应后，将对应的IP与MAC地址记录（动态类型）在ARP高速缓存表中&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/Capture_20240806_153939.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h4&gt;ARP高速缓存类型&lt;/h4&gt;
&lt;p&gt;动态：自动获取，生命周期默认为两分钟；&lt;/p&gt;
&lt;p&gt;静态：手工设置，不同操作系统下的生命周期不同&lt;/p&gt;
&lt;h4&gt;作用范围&lt;/h4&gt;
&lt;p&gt;ARP协议的使用是逐段链路进行的，ARP协议只能在一段链路或一个网络上使用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/Capture_20240806_155014.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;集线器与交换机&lt;/h2&gt;
&lt;h3&gt;集线器&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;images/Capture_20240809_101314.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h4&gt;集线器的扩展&lt;/h4&gt;
&lt;p&gt;使用集线器HUB在物理层对以太网进行扩展&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/Capture_20240809_101604.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;交换机&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;images/Capture_20240809_102337.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;集线器与交换机区别&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;忽略ARP过程&lt;/p&gt;
&lt;p&gt;假设交换机的帧交换表已‘学习好’&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1.对于发送广播帧，二者无显著差别&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/Capture_20240809_102748.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;2.两台主机向目标主机同时发送单播帧，交换机对比集线器不会产生碰撞&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/Capture_20240809_104226.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;3.对于二者扩展以太网进行发送广播帧，无显著差别&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/Capture_20240809_104602.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;4.对于二者扩展以太网进行发送单播帧，交换机对比集线器有显著优势&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/Capture_20240809_104536.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;5.对于二者扩展以太网进行竞争总线，交换机对比集线器有显著优势&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/Capture_20240809_104947.jpg&quot; alt=&quot;&quot; /&gt;6.交换机对比集线器，起到隔离碰撞域作用&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/Capture_20240809_105226.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;集线器HUB&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;■ 早期以太网的互连设备&lt;br /&gt;
■ 工作在OSI体系结构的&lt;strong&gt;物理层（在物理层扩展以太网）&lt;/strong&gt;&lt;br /&gt;
■ 对接收到的信号进行放大、转发&lt;br /&gt;
■ 使用集线器作为互连设备的以太网仍然属于共享总线式以太网。集线器互连起来的所有主机共享总线带宽&lt;strong&gt;属于同一个碰撞域和广播域&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;交换器SWITCH&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;■ 目前以太网中使用最广泛的互连设备&lt;br /&gt;
■ 工作在OSI体系结构的&lt;strong&gt;数据链路层&lt;/strong&gt;（也包括物理层）根据MAC地址对帧进行转发（&lt;strong&gt;在数据链路层扩展以太网）&lt;/strong&gt;&lt;br /&gt;
■ 使用交换机作为互连设备的以太网，称为交换式以太网。交换机可以根据MAC地址过滤帧，即隔离碰撞域。&lt;br /&gt;
■ 交换机的每个接口是一个独立的碰撞域&lt;br /&gt;
■ 交换机隔离碰撞域但不隔离广播域（VLAN除外）&lt;/p&gt;
&lt;h2&gt;以太网交换机自学习、转发帧流程&lt;/h2&gt;
&lt;p&gt;■ 以太网交换机工作在&lt;strong&gt;数据链路层&lt;/strong&gt;（也包括物理层）&lt;br /&gt;
■ 以太网&lt;strong&gt;交换机收到帧&lt;/strong&gt;后，在&lt;strong&gt;帧交换表&lt;/strong&gt;中&lt;strong&gt;查找帧的目的MAC地址所对应的接口号&lt;/strong&gt;，然后通过该接口转发帧。&lt;br /&gt;
■ 以太网交换机是一种即插即用设备，&lt;strong&gt;刚上电启动时其内部的帧交换表是空的&lt;/strong&gt;。随着网络中各主机间的通信，以太网交换机&lt;strong&gt;通过自学习算法自动逐渐建立起帧交换表&lt;/strong&gt;。&lt;br /&gt;
■ 以太网交换机自学习和转发帧的流程：&lt;br /&gt;
①&lt;strong&gt;收到帧后进行登记&lt;/strong&gt;。登记的内容为帧的&lt;strong&gt;源MAC地址&lt;/strong&gt;及&lt;strong&gt;进入交换机的接口号&lt;/strong&gt;；&lt;br /&gt;
② 根据帧的目的MAC地址和交换机的帧交换表对帧进行转发，有以下三种情况：&lt;br /&gt;
         □ 明确转发：交换机知道应当从哪个（或哪些）接口转发该帧（单播，多播，广播）&lt;br /&gt;
         □ 盲目转发：交换机&lt;strong&gt;不知道应当从哪个端口转发帧&lt;/strong&gt;，只能将其通过除进入交换机的&lt;br /&gt;
                                  接口外的其他所有接口转发（也称为泛洪）。&lt;br /&gt;
         □ 明确丢弃：交换机知道不应该转发该帧，将其丢弃。&lt;br /&gt;
 ■ 帧交换表中的每条记录都有自己的有效时间，到期删除。原因如下&lt;br /&gt;
        □ 交换机的接口改接另一个主机。&lt;br /&gt;
        □ 主机更换了网卡。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/Capture_20240809_172306.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;以太网交换机的生成树协议STP&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;images/Capture_20240809_173148.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;显然，添加冗余链路（即BC线）后，即使AB或AC线出现链路故障，也不会影响各个交换机之间通信&lt;/p&gt;
&lt;p&gt;但添加冗余链路形成网络环路会使得广播帧不断的在各链路中循环（逆时针和顺时针同时进行）转发，造成其他的负面影响&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;■ 以太网交换机使用&lt;strong&gt;生成树协议STP&lt;/strong&gt;(Spanning Tree Protocol),可以在增加冗余链路来&lt;strong&gt;提高网络可靠性&lt;/strong&gt;的同时又&lt;strong&gt;避免网络环路带来的各种问题&lt;/strong&gt;。&lt;br /&gt;
         □ 不论交换机之间采用怎样的物理连接，交换机都能够&lt;strong&gt;自动计算并构建一个逻辑上没有环路的网络&lt;/strong&gt;，其逻辑拓扑结构必须是树型的（无逻辑环路）;&lt;br /&gt;
         □ 最终生成的树型逻辑拓扑&lt;strong&gt;要确保连通整个网络&lt;/strong&gt;；&lt;br /&gt;
         □ 当首次连接交换机或网络&lt;strong&gt;物理拓扑发生变化&lt;/strong&gt;时（有可能是人为改变或故障），交换机都将&lt;strong&gt;进行生成树的重新计算&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/Capture_20240809_174600.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;虚拟局域网VLAN&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;随着交换式以太网的扩大，广播域也随之扩大。&lt;/p&gt;
&lt;p&gt;巨大的广播域会造成很多弊端（广播风暴、难以管理和维护、潜在安全问题）&lt;/p&gt;
&lt;p&gt;占用大量网络资源和各主机CPU资源&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;■ 网络中会频繁出现广播信息&lt;br /&gt;
         □ TCP/IP协议栈中的很多协议都会使用广播：&lt;br /&gt;
                      1. 地址解析协议ARP（已知IP地址，找出其相应的MAC地址）&lt;br /&gt;
                      2. 路由信息协议RIP（一种小型的内部路由协议）&lt;br /&gt;
                      3. 动态主机配置协议DHCP（用于自动配置IP地址）&lt;br /&gt;
         □ NetBEUI:Widnows下使用的广播型协议  &lt;br /&gt;
         □ IPX/SPX:Novell网络的协议栈&lt;br /&gt;
         □ Apple Talk:Apple公司的网络协议栈&lt;/p&gt;
&lt;p&gt;■ 分割广播域&lt;/p&gt;
&lt;p&gt;□ 使用路由器可以隔离广播域：由于路由器默认情况下&lt;strong&gt;不对广播数据包进行转发&lt;/strong&gt;，但由于&lt;strong&gt;路由器成本高&lt;/strong&gt;，局域网内部全部使用路由器来隔离广播域是&lt;strong&gt;不现实&lt;/strong&gt;的&lt;/p&gt;
&lt;p&gt;□ 虚拟局域网VLAN技术应运而生&lt;/p&gt;
&lt;h3&gt;概述&lt;/h3&gt;
&lt;p&gt;■ 虚拟局域网VLAN(Virtual Local Area Network）是一种将局域网内的&lt;strong&gt;设备划分成与物理位置无关的逻辑组的技术，这些逻辑组具有某些共同的需求&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/Capture_20240809_180923-e1723198206406.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;实现机制&lt;/h3&gt;
&lt;h4&gt;IEEE 802.1Q帧&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;images/Capture_20240809_181515.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h4&gt;端口类型&lt;/h4&gt;
&lt;p&gt;■ 交换机的端口类型有以下三种：&lt;br /&gt;
        □ Access&lt;br /&gt;
        □ Trunk&lt;br /&gt;
        □ Hybrid&lt;br /&gt;
■交换机各端口的缺省VLAN ID&lt;br /&gt;
        □ 在思科交换机上称为Native VLAN，即本征VLAN。&lt;br /&gt;
        □ 在华为交换机上称为Port VLAN ID，即端口VLAN ID，简记为PVID&lt;/p&gt;
&lt;h5&gt;Access&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;images/Capture_20240809_182237.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/Capture_20240809_182255.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h5&gt;Trunk&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;images/Capture_20240809_182655.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h5&gt;Hybrid&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;images/Capture_20240809_183259.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h1&gt;&lt;strong&gt;网络层&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;网络层：实现网络互连，进而实现数据包在各网络之间的传输&lt;/p&gt;
&lt;p&gt;解决的问题：提供可靠/不可靠传输服务；寻址问题;路由（路径）选择问题（帧交换表）&lt;/p&gt;
&lt;p&gt;网际层使用TCP/IP协议栈（地址解析协议ARP、网际控制报文协议ICMP、网际组管理协议IGMP)&lt;/p&gt;
&lt;h2&gt;提供的两种服务&lt;/h2&gt;
&lt;p&gt;面向连接的虚电路服务、无连接的数据包服务&lt;/p&gt;
&lt;p&gt;■ 可靠通信由网络来保证&lt;/p&gt;
&lt;p&gt;■ 必须建立网络层的连接﹣﹣虚电路VC(Virtual Circuit)&lt;/p&gt;
&lt;p&gt;■ 通信双方沿着已建立的虚电路发送分组&lt;/p&gt;
&lt;p&gt;■ 目的主机的地址仅在连接建立阶段使用，之后每个分组的首部只需携带一条虚电路的编号（构成虚电路的每一段链路都有一个虚电路编号）。&lt;/p&gt;
&lt;p&gt;■这种通信方式如果再使用可靠传输的网络协议，就可使所发送的分组最终正确到达接收方（无差错按序到达、不丢失、不重复）&lt;/p&gt;
&lt;p&gt;■通信结束后，需要释放之前所建立的虚电路。&lt;/p&gt;
&lt;p&gt;■ 很多广域分组交换网都使用面向连接的虚电路服务。例如，曾经的X.25和逐渐过时的帧中继FR、异步传输模式ATM&lt;/p&gt;
</content:encoded></item><item><title>暴力破解简易密码的RAR加密文件</title><link>https://minthana.github.io/blog/posts/%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3%E7%AE%80%E6%98%93%E5%AF%86%E7%A0%81%E7%9A%84rar%E5%8A%A0%E5%AF%86%E6%96%87%E4%BB%B6/</link><guid isPermaLink="true">https://minthana.github.io/blog/posts/%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3%E7%AE%80%E6%98%93%E5%AF%86%E7%A0%81%E7%9A%84rar%E5%8A%A0%E5%AF%86%E6%96%87%E4%BB%B6/</guid><pubDate>Mon, 08 Jul 2024 23:11:00 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;p&gt;在获得某出版社网络分享的rar文件资料时，偶尔会遇到加密情况。&lt;/p&gt;
&lt;p&gt;通常出版社的加密密码需要教师身份申请才能获得，同时设置的密码较为简单。&lt;/p&gt;
&lt;p&gt;因此我们可以密码库进行暴力破解&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;提醒&lt;/h2&gt;
&lt;p&gt;密码破解的时间受到&lt;strong&gt;密码的长度&lt;/strong&gt;，&lt;strong&gt;复杂程度（字母、字符）&lt;/strong&gt;、&lt;strong&gt;电脑设备&lt;/strong&gt;等因素影响&lt;/p&gt;
&lt;p&gt;因此，此方法&lt;strong&gt;只适用于简单常规密码&lt;/strong&gt;的破解！！！&lt;/p&gt;
&lt;h2&gt;准备工作&lt;/h2&gt;
&lt;p&gt;工具：电脑&lt;/p&gt;
&lt;p&gt;软件：&lt;/p&gt;
&lt;p&gt;1. &lt;strong&gt;john the ripper&lt;/strong&gt; ：https://www.openwall.com&lt;/p&gt;
&lt;p&gt;下载并解压&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2024-07-08-223012.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2024-07-08-223138.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;2. &lt;strong&gt;hashcat&lt;/strong&gt; ：https://hashcat.net&lt;/p&gt;
&lt;p&gt;下载并解压&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2024-07-08-223424.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;破解步骤&lt;/h2&gt;
&lt;h3&gt;获取Hash值&lt;/h3&gt;
&lt;p&gt;进入解压后 john文件内的二级目录 run中，并把需要破解的rar压缩文件存放在此处&lt;/p&gt;
&lt;p&gt;（注：压缩文件名字不能出现中文字符!!!）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2024-07-08-223701.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;然后点击文件路径输入cmd进入控制台后输入指令（中间有空格符合）后，会获得一个或多个Hash值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;rar2john.exe 文件名.rar
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2024-07-08-225305.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;暴力破解&lt;/h3&gt;
&lt;p&gt;打开hashcat文件夹，同理打开cmd控制台后输入指令（HashValue替换为前步骤获得的值）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;hashcat.exe -m 13000 -w 4 -a 3 HashValue -o password.txt 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2024-07-08-225809.png&quot; alt=&quot;&quot; /&gt;出现起始终止时间即破解成功&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2024-07-08-225859.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;查看密码&lt;/h3&gt;
&lt;p&gt;在hashcat文件目录最后即可看见password.txt文件，里面存放着Hash值以及其对应的密码&lt;/p&gt;
</content:encoded></item><item><title>5G在工业4.0的应用场景</title><link>https://minthana.github.io/blog/posts/5g%E5%9C%A8%E5%B7%A5%E4%B8%9A4-0%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/</link><guid isPermaLink="true">https://minthana.github.io/blog/posts/5g%E5%9C%A8%E5%B7%A5%E4%B8%9A4-0%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/</guid><pubDate>Thu, 13 Jun 2024 21:08:00 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;p&gt;阿里云大咖课堂期末论文&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;摘  要&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;本次课题将围绕5G技术的核心特性，包括高速率、低时延、大连接等，这些特性使得5G在工业领域具有广泛的应用前景。接着，详细阐述了工业4.0的概念、特点以及在中国的发展现状，特别是中国在推动工业4.0方面的政策扶持和取得的成果。在5G与工业4.0结合的应用场景方面，分析了5G技术在智能制造、远程监控、智能物流、智能维护等多个领域的应用实例。通过具体的事件案例，展示了5G技术如何提升生产效率、降低成本、增强安全性等。此外，还讨论中国在5G和工业4.0领域的政策扶持。政府通过制定战略规划、提供财政支持、加强人才培养等措施，为5G和工业4.0的发展提供了有力保障。这些政策的实施，为中国在全球竞争中赢得了先机。最后，本文总结了5G在工业4.0应用中的挑战与机遇，并展望了未来发展方向。随着5G技术的不断成熟和普及，相信其在工业4.0中的应用将更加广泛和深入，为中国制造业的转型升级和高质量发展注入新的动力。&lt;/p&gt;
&lt;p&gt;关键词：5G；工业4.0；互联网；工业应用&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Application scenarios of 5G in Industry 4.0&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Abstract&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;This topic will focus on the core characteristics of 5G technology, including high speed, low latency, and large connection, which make 5G have a wide range of application prospects in the industrial field. Then, the concept and characteristics of Industry 4.0 and the development status in China were elaborated, especially the policy support and achievements of China in promoting Industry 4.0. In terms of the application scenarios of the combination of 5G and Industry 4.0, the application examples of 5G technology in many fields such as intelligent manufacturing, remote monitoring, intelligent logistics, and intelligent maintenance are analyzed. Through specific event cases, it shows how 5G technology can improve production efficiency, reduce costs, and enhance security. In addition, China&apos;s policy support in the field of 5G and Industry 4.0 was discussed. The government has provided a strong guarantee for the development of 5G and Industry 4.0 by formulating strategic plans, providing financial support, and strengthening talent training. The implementation of these policies has won China a head start in global competition. Finally, this paper summarizes the challenges and opportunities of 5G in Industry 4.0 applications, and looks forward to the future development direction. With the continuous maturity and popularization of 5G technology, it is believed that its application in Industry 4.0 will be more extensive and deeper, injecting new impetus into the transformation, upgrading and high-quality development of China&apos;s manufacturing industry.&lt;/p&gt;
&lt;p&gt;Key words: 5G; Industry 4.0; Internet; Industrial Applications&lt;/p&gt;
&lt;h1&gt;绪  论&lt;/h1&gt;
&lt;h2&gt;课题研究的背景及意义&lt;/h2&gt;
&lt;p&gt;工业4.0是基于物联网、大数据、云计算等先进技术，实现智能化、网络化和数字化的工业生产方式。它打破了传统制造业的界限，推动了产业链的重构和升级。工业4.0的核心是智能制造，通过引入先进的信息技术，实现生产过程的自动化、智能化和个性化。&lt;/p&gt;
&lt;p&gt;5G技术作为新一代移动通信技术，其峰值速率、时延、连接密度等关键性能指标均得到显著提升。这些特性使得5G技术在工业领域具有广泛的应用前景。通过5G网络，可以实现设备间的高效连接、实时数据分析和远程控制，为工业4.0的发展提供了强有力的支撑。&lt;/p&gt;
&lt;p&gt;中国作为制造业大国，对工业4.0和5G技术的融合应用尤为重视。在政策层面，中国政府出台了一系列支持政策，鼓励企业加大在工业4.0和5G技术领域的投入。同时，中国也在加快5G网络的建设和普及，为工业4.0的发展提供了良好的基础设施支持。&lt;/p&gt;
&lt;p&gt;5G技术在工业4.0领域的应用，可以推动制造业向智能化、网络化和数字化方向转型升级，提高生产效率、降低生产成本，并提升企业的核心竞争力。5G技术可以促进设备间的无缝连接和数据共享，推动各行业之间的协同创新和资源整合。通过5G+工业互联网的融合，企业可以构建起智能化的生产系统，实现跨部门、跨领域的协同合作，促进产业链的优化和升级。5G技术不仅可以应用于工业领域，还可以为智慧城市的建设提供有力支持。通过连接城市中的各种智能设备，如智能路灯、交通监控、环境监测等，实现城市管理的智能化和自动化，提升城市运行效率和居民生活质量。&lt;/p&gt;
&lt;h1&gt;工 业 4.0 + 5 G的 应 用 场 景&lt;/h1&gt;
&lt;h2&gt;智能制造&lt;/h2&gt;
&lt;p&gt;在智能制造领域，5G技术可以实现工厂内大量传感器、机器人和自动化设备的高效连接，支持实时数据分析和远程控制。通过5G网络，工厂内的设备可以实现实时数据交换和协同作业，从而提高生产效率和灵活性。例如，利用5G技术，可以实现生产线上的设备远程监控和维护，及时发现并解决设备故障，降低生产中断的风险。此外，5G技术还可以支持高精度定位服务，为智能制造提供精确的位置信息支持。&lt;/p&gt;
&lt;h2&gt;车联网自动驾驶&lt;/h2&gt;
&lt;p&gt;5G车联网助力汽车、交通应用服务的智能化升级。5G网络的大带宽、低时延等特性，支持实现车载VR视频通话、实景导航等实时业务。借助于车联网C-V2X（包含直连通信和5G网络通信）的低时延、高可靠和广播传输特性，车辆可实时对外广播自身定位、运行状态等基本安全消息，交通灯或电子标志标识等可广播交通管理与指示信息，支持实现路口碰撞预警、红绿灯诱导通行等应用，显著提升车辆行驶安全和出行效率。5G网络可支持港口岸桥区的自动远程控制、装卸区的自动码货以及港区的车辆无人驾驶应用，显著降低自动导引运输车控制信号的时延以保障无线通讯质量与作业可靠性，可使智能理货数据传输系统实现全天候全流程的实时在线监控。&lt;/p&gt;
&lt;h2&gt;无人智能巡检&lt;/h2&gt;
&lt;p&gt;通过内置5G模组或部署5G网关等设备，实现巡检机器人或无人机等移动化、智能化安防设备的5G网络接入，替代巡检人员进行巡逻值守，采集现场视频、语音、图片等各项数据，自动完成检测、巡航以及记录数据、远程告警确认等工作；相关数据通过5G网络实时回传至智能巡检系统，智能巡检系统利用图像识别、深度学习等智能技术和算法处理，综合判断得出巡检结果，有效提升安全等级、巡检效率及安防效果。&lt;/p&gt;
&lt;h2&gt;采矿行业&lt;/h2&gt;
&lt;p&gt;通过开通5G煤矿井下网络，建成井下“超千兆上行”煤矿5G专用网络，实现了远程设备操控场景的应用，取得5G网络设备隔爆认证。5G技术实现了对掘进机、挖煤机、液压支架等综采设备的实时远程操控，实现了对爆破全过程的高清监测与控制，解决了传统人工作业操作危险系数大、劳动强度高的问题，改善一线工人的工作环境，大幅降低安全风险，显著提升采掘效率。利用5G技术实现综采面无人操作，解决了井下设备运行过程中线缆维护量大、信号经常缺失等问题，有效降低危险作业区域安全事故发生率。&lt;/p&gt;
&lt;h2&gt;电力行业&lt;/h2&gt;
&lt;p&gt;利用5G技术，实践在发电环节的现场辅助装配、输电环节的无人智能巡检、配电环节的设备故障诊断、用电环节的生产现场监测等典型应用场景，改善了信息孤岛、设备实时监管难、精细化管理难等问题。通过5G专网+AR等技术，工人可以佩戴AR眼镜在专家远程指导下成功装配设备组件，解决了因疫情等突发因素导致专家无法到现场等问题，有力推动了专家资源共享和辅助装配效率的提升。以12.8K的采样率，对电能质量进行监测。利用5G大带宽、低时延技术特点，将仪表的分析部分云化部署，前端只保留采集装置，解决了传统采集装置功能复杂、成本高的问题，将仪表设备成本降低90%。有效解决了电力运行监测成本行业性难题，有力推动了电能质量监测的规模部署。设备（CPE）进行高精度网络授时，通过5G网络低时延特性，采集配电网电流相量数据，传输至配电自动化主站，及时掌握线路情况，并进行在线监测和诊断，发现故障区段后，依靠配电自动化主站进行故障隔离和供电恢复，解决了传统配电自动化故障发现时间长、故障隔离区域大的问题。&lt;/p&gt;
&lt;h2&gt;钢铁行业&lt;/h2&gt;
&lt;p&gt;5G技术实现天车、加渣机械臂的远程设备操控场景的应用。通过天车远程操控，利用5G超大上行与下载速率，为操作员提供第一视角的高清视频，操作人员可在远程操控室实时操控天车卸车、吊运装槽、配合检修等作业，保障远程操控的精准度和实时性，另外，加渣机械臂和控制系统可以通过5G网络互通，利用5G手机远程一键启动，自动运行，降低工人在高温锅炉旁作业风险，提升作业安全性。&lt;/p&gt;
&lt;p&gt;在机器视觉质检方面，通过部署工业相机拍摄高清图片、采集质检数据，利用5G网络将采集到的冷轧现场4K/8K等高清图像数据回传至操作室平台，通过平台的视觉AI分析能力对图像进行处理分析，完成带钢表面缺陷的实时检测通过在皮带通廊部署4K高清摄像监控系统，覆盖皮带通廊出入口与皮带作业重点区域，利用5G网络实时回传人员目标及动作、环境、原料、皮带检测等信息至云平台，实现人员作业安全检测、作业调度信息化、施工作业的安全管理，保障现场工作人员的安全。&lt;/p&gt;
&lt;h1&gt;政 策 扶 持&lt;/h1&gt;
&lt;p&gt;政府在5G工业4.0的政策扶持涵盖了财政补贴、总部企业奖励、租赁办公用房补贴、5G产业园区示范支持、关键技术攻关支持、人才队伍建设以及公共服务与创新平台建设等多个方面，旨在推动5G技术与工业4.0的深度融合，促进相关产业的高质量发展。&lt;/p&gt;
&lt;h1&gt;总结与展望&lt;/h1&gt;
&lt;p&gt;5G技术在工业4.0的应用场景中展现了巨大的潜力和优势。首先，5G的超高网络传输速率和低延迟特性，使得实时监测与控制成为可能，显著提升了生产效率和安全性。其次，5G技术支持下的工厂自动化和工业物联网（IIoT）应用，促进了设备间的无缝连接和协同工作，推动了制造业向智能化、绿色化、服务化方向转型升级。此外，5G在促进工业、医疗、教育等多个行业领域数字化、智能化转型方面也发挥了重要作用。&lt;/p&gt;
&lt;p&gt;未来，随着5G技术的不断发展和完善，其在工业4.0中的应用将更加广泛和深入。首先，5G技术将进一步推动工业互联网的创新发展，促进制造业与信息技术的深度融合。其次，5G将助力构建更加智能、高效、绿色的生产体系，提升全球产业链和供应链的韧性和竞争力。最后，政府和企业应加大对5G技术的研发和应用投入，推动相关政策和标准的制定与完善，为5G技术在工业4.0中的广泛应用提供有力支持。&lt;/p&gt;
&lt;h1&gt;参考文献&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;[1].BICS:5G数字变革赋能工业4.0[J].单片机与嵌入式系统应用,2022,22(04):93.&lt;/p&gt;
&lt;p&gt;[2]震霆.解锁工业4.0：了解5G时代的物联网[J].服务外包,2020,(10):94-95.&lt;/p&gt;
&lt;p&gt;[3]杨洁.工信部：探索建设“5G+工业互联网”融合应用先导区[N].中国证券报,2023-11-21(A02).DOI:10.28162/n.cnki.nczjb.2023.005680.&lt;/p&gt;
&lt;p&gt;[4]2020中国5G+工业互联网成果展在武汉举行[J].台声,2020,(23):68-69.&lt;/p&gt;
&lt;/blockquote&gt;
</content:encoded></item><item><title>全球洗钱案例分析</title><link>https://minthana.github.io/blog/posts/%E5%85%A8%E7%90%83%E6%B4%97%E9%92%B1%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/</link><guid isPermaLink="true">https://minthana.github.io/blog/posts/%E5%85%A8%E7%90%83%E6%B4%97%E9%92%B1%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/</guid><pubDate>Sun, 09 Jun 2024 16:53:00 GMT</pubDate><content:encoded>&lt;p&gt;python数据分析期末案例&lt;/p&gt;
&lt;h1&gt;全球洗钱案例分析 &lt;img src=&quot;images/%E5%85%A8%E7%90%83%E6%B4%97%E9%92%B1%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90-images-0.jpg&quot; alt=&quot;全球洗钱案例分析 第 1 页&quot; /&gt; &lt;img src=&quot;images/%E5%85%A8%E7%90%83%E6%B4%97%E9%92%B1%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90-images-1.jpg&quot; alt=&quot;全球洗钱案例分析 第 2 页&quot; /&gt; &lt;img src=&quot;images/%E5%85%A8%E7%90%83%E6%B4%97%E9%92%B1%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90-images-2.jpg&quot; alt=&quot;全球洗钱案例分析 第 3 页&quot; /&gt; &lt;img src=&quot;images/%E5%85%A8%E7%90%83%E6%B4%97%E9%92%B1%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90-images-3.jpg&quot; alt=&quot;全球洗钱案例分析 第 4 页&quot; /&gt; &lt;img src=&quot;images/%E5%85%A8%E7%90%83%E6%B4%97%E9%92%B1%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90-images-4.jpg&quot; alt=&quot;全球洗钱案例分析 第 5 页&quot; /&gt; &lt;img src=&quot;images/%E5%85%A8%E7%90%83%E6%B4%97%E9%92%B1%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90-images-5.jpg&quot; alt=&quot;全球洗钱案例分析 第 6 页&quot; /&gt; &lt;img src=&quot;images/%E5%85%A8%E7%90%83%E6%B4%97%E9%92%B1%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90-images-6.jpg&quot; alt=&quot;全球洗钱案例分析 第 7 页&quot; /&gt; &lt;img src=&quot;images/%E5%85%A8%E7%90%83%E6%B4%97%E9%92%B1%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90-images-7.jpg&quot; alt=&quot;全球洗钱案例分析 第 8 页&quot; /&gt; &lt;img src=&quot;images/%E5%85%A8%E7%90%83%E6%B4%97%E9%92%B1%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90-images-8.jpg&quot; alt=&quot;全球洗钱案例分析 第 9 页&quot; /&gt; &lt;img src=&quot;images/%E5%85%A8%E7%90%83%E6%B4%97%E9%92%B1%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90-images-9.jpg&quot; alt=&quot;全球洗钱案例分析 第 10 页&quot; /&gt; &lt;img src=&quot;images/%E5%85%A8%E7%90%83%E6%B4%97%E9%92%B1%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90-images-10.jpg&quot; alt=&quot;全球洗钱案例分析 第 11 页&quot; /&gt; &lt;img src=&quot;images/%E5%85%A8%E7%90%83%E6%B4%97%E9%92%B1%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90-images-11.jpg&quot; alt=&quot;全球洗钱案例分析 第 12 页&quot; /&gt; &lt;img src=&quot;images/%E5%85%A8%E7%90%83%E6%B4%97%E9%92%B1%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90-images-12.jpg&quot; alt=&quot;全球洗钱案例分析 第 13 页&quot; /&gt; &lt;img src=&quot;images/%E5%85%A8%E7%90%83%E6%B4%97%E9%92%B1%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90-images-13.jpg&quot; alt=&quot;全球洗钱案例分析 第 14 页&quot; /&gt; &lt;img src=&quot;images/%E5%85%A8%E7%90%83%E6%B4%97%E9%92%B1%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90-images-14.jpg&quot; alt=&quot;全球洗钱案例分析 第 15 页&quot; /&gt; &lt;img src=&quot;images/%E5%85%A8%E7%90%83%E6%B4%97%E9%92%B1%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90-images-15.jpg&quot; alt=&quot;全球洗钱案例分析 第 16 页&quot; /&gt; &lt;img src=&quot;images/%E5%85%A8%E7%90%83%E6%B4%97%E9%92%B1%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90-images-16.jpg&quot; alt=&quot;全球洗钱案例分析 第 17 页&quot; /&gt; &lt;img src=&quot;images/%E5%85%A8%E7%90%83%E6%B4%97%E9%92%B1%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90-images-17.jpg&quot; alt=&quot;全球洗钱案例分析 第 18 页&quot; /&gt; &lt;img src=&quot;images/%E5%85%A8%E7%90%83%E6%B4%97%E9%92%B1%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90-images-18.jpg&quot; alt=&quot;全球洗钱案例分析 第 19 页&quot; /&gt; &lt;img src=&quot;images/%E5%85%A8%E7%90%83%E6%B4%97%E9%92%B1%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90-images-19.jpg&quot; alt=&quot;全球洗钱案例分析 第 20 页&quot; /&gt; &lt;img src=&quot;images/%E5%85%A8%E7%90%83%E6%B4%97%E9%92%B1%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90-images-20.jpg&quot; alt=&quot;全球洗钱案例分析 第 21 页&quot; /&gt; &lt;img src=&quot;images/%E5%85%A8%E7%90%83%E6%B4%97%E9%92%B1%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90-images-21.jpg&quot; alt=&quot;全球洗钱案例分析 第 22 页&quot; /&gt; &lt;img src=&quot;images/%E5%85%A8%E7%90%83%E6%B4%97%E9%92%B1%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90-images-22.jpg&quot; alt=&quot;全球洗钱案例分析 第 23 页&quot; /&gt; &lt;img src=&quot;images/%E5%85%A8%E7%90%83%E6%B4%97%E9%92%B1%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90-images-23.jpg&quot; alt=&quot;全球洗钱案例分析 第 24 页&quot; /&gt; &lt;img src=&quot;images/%E5%85%A8%E7%90%83%E6%B4%97%E9%92%B1%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90-images-24.jpg&quot; alt=&quot;全球洗钱案例分析 第 25 页&quot; /&gt; &lt;img src=&quot;images/%E5%85%A8%E7%90%83%E6%B4%97%E9%92%B1%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90-images-25.jpg&quot; alt=&quot;全球洗钱案例分析 第 26 页&quot; /&gt; &lt;img src=&quot;images/%E5%85%A8%E7%90%83%E6%B4%97%E9%92%B1%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90-images-26.jpg&quot; alt=&quot;全球洗钱案例分析 第 27 页&quot; /&gt; &lt;img src=&quot;images/%E5%85%A8%E7%90%83%E6%B4%97%E9%92%B1%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90-images-27.jpg&quot; alt=&quot;全球洗钱案例分析 第 28 页&quot; /&gt; &lt;img src=&quot;images/%E5%85%A8%E7%90%83%E6%B4%97%E9%92%B1%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90-images-28.jpg&quot; alt=&quot;全球洗钱案例分析 第 29 页&quot; /&gt;&lt;/h1&gt;
</content:encoded></item><item><title>大数据在电力行业应用探究</title><link>https://minthana.github.io/blog/posts/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9C%A8%E7%94%B5%E5%8A%9B%E8%A1%8C%E4%B8%9A%E5%BA%94%E7%94%A8%E6%8E%A2%E7%A9%B6/</link><guid isPermaLink="true">https://minthana.github.io/blog/posts/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9C%A8%E7%94%B5%E5%8A%9B%E8%A1%8C%E4%B8%9A%E5%BA%94%E7%94%A8%E6%8E%A2%E7%A9%B6/</guid><pubDate>Sat, 08 Jun 2024 12:30:00 GMT</pubDate><content:encoded>&lt;p&gt;企业大数据期末论文&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;摘  要&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;随着电力技术和大数据技术的发展，电力大数据产业受到双向驱动，未来电力和大数据融合程度将进一步加深向高融合方向发展。其中，大数据技术在技术强度、数据广度和应用深度等方面的趋势进步，不仅有助于推动电力系统和大数据的技术融合，也是促进大数据成为电力系统智能化发展的基础。&lt;/p&gt;
&lt;p&gt;本文将介绍大数据特点和电力行业发展现状，并分析了大数据在多个电力场景的应用，在管理方面、生产领域、消费领域、用户体验、成本管理方面发挥了重要作用。在论述大数据应用的同时，对其面临的挑战，如数据安全和隐私保护等问题进行了讲述。&lt;/p&gt;
&lt;p&gt;最后在文末，展望了大数据在电力行业中的未来发展趋势。随着技术的不断进步和应用场景的不断拓展，大数据将在电力行业中发挥更加重要的作用，推动电力行业的数字化转型和可持续发展。同时，大数据也将为电力行业带来更多的机遇和挑战，需要我们持续关注和研究。&lt;/p&gt;
&lt;p&gt;关键词：大数据；电力行业；应用案例&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Research on the application of big data in the power industry&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Abstract&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;With the development of power technology and big data technology, the power big data industry is driven by both directions, and the integration of power and big data will be further deepened in the future and develop in the direction of high integration. Among them, the trend of big data technology in terms of technical intensity, data breadth and application depth not only helps to promote the technical integration of power system and big data, but also promotes the foundation of big data to become the intelligent development of power system.&lt;/p&gt;
&lt;p&gt;This article will introduce the characteristics of big data and the development status of the power industry, and analyze the application of big data in multiple power scenarios, which plays an important role in management, production, consumption, user experience, and cost management. While discussing the application of big data, the challenges it faces, such as data security and privacy protection, are discussed.&lt;/p&gt;
&lt;p&gt;Finally, at the end of the paper, the future development trend of big data in the power industry is prospected. With the continuous advancement of technology and the continuous expansion of application scenarios, big data will play a more important role in the power industry and promote the digital transformation and sustainable development of the power industry. At the same time, big data will also bring more opportunities and challenges to the power industry, which requires our continuous attention and research.&lt;/p&gt;
&lt;p&gt;Key words: Big data; SpringCloud; Power industry; Application examples&lt;/p&gt;
&lt;h1&gt;绪 论&lt;/h1&gt;
&lt;h2&gt;研究背景与意义&lt;/h2&gt;
&lt;p&gt;随着信息化时代的快速发展，电力行业作为国民经济的命脉，其运营效率和安全性对于社会稳定和经济发展具有至关重要的作用。然而，传统的电力行业运营模式在数据处理和决策支持方面存在诸多局限，难以满足日益增长的市场需求和复杂的运营环境。近年来，大数据技术的快速发展为电力行业提供了新的解决方案和思路，其在电力行业的应用日益广泛，成为推动电力行业转型升级和可持续发展的重要力量。&lt;/p&gt;
&lt;p&gt;电力行业在运营过程中产生了海量的数据，包括生产一线的实时数据、管理层决策相关的半结构化数据，以及由多媒体组成的非结构化数据。这些数据蕴含着丰富的价值，对于优化电力生产、提高运营效率、降低运营成本具有重要意义。然而，如何有效地收集、整理、计算和分析这些数据，以挖掘其中的价值，成为电力行业面临的重要挑战。&lt;/p&gt;
&lt;p&gt;大数据技术的应用可以帮助电力行业实现对海量数据的实时收集、整理和分析，为电力企业的运营和决策提供精准的数据支持。通过对发电厂生产一线数据的挖掘和分析，可以及时发现潜在问题，优化生产策略，提高资源利用效率，降低生产成本。同时，大数据还可以辅助管理层进行决策，提高决策效率和准确性，推动电力行业的转型升级。&lt;/p&gt;
&lt;p&gt;此外，大数据技术的应用还有助于电力行业实现智能化升级。通过对电力生产、传输、配送等各个环节的数据进行深度挖掘和分析，可以发现潜在的优化空间和创新点，推动电力行业的技术创新和产业升级。同时，大数据技术的应用还能够提高电力供应的可靠性和稳定性，降低故障率和停电时间，提升用户体验和服务质量。&lt;/p&gt;
&lt;p&gt;综上所述，大数据技术在电力行业的应用具有重要的研究背景和意义。它不仅有助于解决传统电力行业运营模式在数据处理和决策支持方面的局限性，还能够推动电力行业的智能化升级和可持续发展。因此，加强对大数据技术在电力行业应用的研究和探索具有重要的学术价值和现实意义。&lt;/p&gt;
&lt;h2&gt;电力行业现状分析&lt;/h2&gt;
&lt;p&gt;电力行业作为国民经济的支柱产业，其规模持续扩大，对经济发展起着至关重要的作用。中国发电规模位列世界第一，占全球总发电量的比重达到30%，显著领先于其他国家。这一成就不仅体现了中国电力行业的强大实力，也反映了中国经济快速发展的需求。&lt;/p&gt;
&lt;p&gt;电力市场主要由电力现货市场和电力期货市场组成，市场规模逐年增长。中国电力市场规模预计将从2023年的581.7亿元人民币增长到2028年的840.6亿元人民币，年复合增长率达到8.7%。同时，电力市场化改革持续推进，市场化交易电量大幅提升，电力市场配置资源的作用明显增强。&lt;/p&gt;
&lt;p&gt;在能源结构方面，电力行业正经历着由传统化石能源向可再生能源转型的过程。非化石能源发电装机容量占比逐年提高，2023年底已突破50%，达到53.9%。风电和太阳能发电成为新增发电装机的主要力量，尤其是太阳能发电新增装机容量占新增发电装机总容量的58.5%。&lt;br /&gt;
    现阶段，电网公司在向数据中台等加速数字化底层部署，国家电网为例，2020年国家电网已经完成总部及27家省公司内网云和数据中台部署，可以预见未来电网数字化转型、数字化投入重心在于电力大数据价值挖掘，将数据资源作为核心资产进行管理和运营，赋能电力行业科学规划、智能运行及商业模式创新。未来持续增长的电网公司数字化转型投入，将有效驱动电网领域大数据分析市场的快速发展。&lt;/p&gt;
&lt;h1&gt;案 例 描 述 与 分 析&lt;/h1&gt;
&lt;h2&gt;发电厂大数据优化运营&lt;/h2&gt;
&lt;p&gt;随着发电厂信息化程度的提升，发电厂在日常运营中产生了大量的结构化、半结构化和非结构化数据。这些数据包括生产一线的实时数据、管理层决策相关的半结构化数据，以及由多媒体组成的非结构化数据，如监控视频和事故视频。发电厂面临的主要挑战是如何有效地收集、整理、计算和分析这些数据，以挖掘其中的价值，进而指导电厂的生产运营。&lt;/p&gt;
&lt;p&gt;通过传感器、电子设备等实时采集发电厂的生产一线数据进行数据采集并存储到统一的数据平台中，利用大数据分析技术对数据进行挖掘和分析，特别是针对发电厂用电率等关键指标进行相关性分析。将分析结果以直观、易懂的方式展示给电厂管理层，辅助其进行决策。&lt;/p&gt;
&lt;p&gt;通过大数据分析，发电厂能够更准确地把握生产运营状况，及时发现潜在问题，优化生产策略。能够更有效地利用资源，降低生产成本，提高经济效益。据估算，数据利用率提高10%，电网利润率可提高20%~40%。基于大数据的决策支持，电厂管理层能够更科学地制定决策，提高决策效率和准确性。&lt;/p&gt;
&lt;h2&gt;大数据在风力发电机安装选址中的作用&lt;/h2&gt;
&lt;p&gt;传统的人工选址需要数周甚至数月的时间来完成对选定地区环境数据的收集、整理和分析。然而，通过导入环境数据至大数据模型进行测算，风电企业可以在几个小时内完成选址的初步评估，大大提高了选址的效率。&lt;/p&gt;
&lt;p&gt;大数据技术的数据挖掘和处理能力使得风电企业能够对风电场周边环境状况进行全面的分析。通过对地形、地貌、气候、交通等因素的考量，大数据模型能够为企业提供详尽的数据支持。基于大数据模型的分析结果，风电企业可以对不同的风电场建设方案进行综合对比。通过对各个方案的发电量、投资成本、运维费用等因素的考量，大数据模型能够为企业提供最优的建设方案，确保项目的最终受益。&lt;/p&gt;
&lt;h2&gt;事故预警及诊断&lt;/h2&gt;
&lt;p&gt;大数据技术能够实时收集风电机组运行过程中的各种数据，包括温度、湿度、振动、转速、功率等关键指标。通过对这些数据的深入分析，可以全面了解风电机组的运行状态和性能。基于大数据的预测算法和模型，可以对风电机组可能出现的故障进行预测。一旦出现故障，大数据技术能够迅速诊断出问题的根源，为维修人员提供准确的故障信息。结合历史数据和实时数据，大数据技术可以优化风电场的运维流程。通过预测外部环境的变化，如温度、湿度、风向、风力等，可以帮助维修部门提前做好调度安排，减少故障停机时间，提高风电场的运行效率。&lt;/p&gt;
&lt;h2&gt;提升运营效果、改善用户体验&lt;/h2&gt;
&lt;p&gt;大数据分析能帮助电力企业提升运营效率和改善客户体验。运营效益包括收益保证、网络和产品管理、需求预测、资产管理和支撑功能优化。类似的，分析有助于通过客户关系优化、主动营销以及定制优惠和服务来改善客户体验。通过大数据平台对收集的历史数据（包括电力中断时间、恢复时间、客户反馈等）进行预处理和清洗后，利用数据分析找出最佳恢复时间与客户满意度的关系。根据分析结果调整恢复策略，并在实际中断中验证效果。&lt;/p&gt;
&lt;p&gt;企业能够制定更合理的服务策略，提升客户满意度。同时，也提示了电力行业在大数据应用方面需要关注数据质量和分析准确性。&lt;/p&gt;
&lt;h2&gt;电网运行状态的实时监测、故障的快速感知&lt;/h2&gt;
&lt;p&gt;数据技术在电力行业具有广泛的应用前景，可以帮助企业实现电网运行状态的实时监测、故障的快速感知和智能决策支持等功能。国网河南省电力公司为了提升配网故障抢修效率，创新打造了配电线路故障停电“百秒感知”模式。&lt;/p&gt;
&lt;p&gt;采用先进的传感器和计量设备，实时采集电网数据并对电网运行状态的实时监测。利用大数据技术快速识别并定位故障发生的位置和类型。并基于历史数据和实时数据，智能预测故障发展趋势，为抢修提供决策支持。&lt;/p&gt;
&lt;p&gt;通过“百秒感知”模式，国网河南省电力公司成功将故障研判时间从过去的45分钟左右缩短到100秒以内，显著提高了抢修效率。同时，故障得到快速响应和处理，客户停电时间大幅减少，客户满意度显著提升。&lt;br /&gt;
    但在利用大数据技术进行电网监测和故障处理时，需要关注数据安全和隐私保护问题。应建立完善的数据安全管理制度和技术防范措施，确保数据的安全性和可靠性。&lt;/p&gt;
&lt;h2&gt;减少损失、降低成本&lt;/h2&gt;
&lt;p&gt;大数据技术在电力行业减少损失、降低成本方面的巨大潜力。通过深度挖掘和分析电力生产、传输、配送等各个环节的数据，电力公司能够发现存在的问题并采取有效的优化措施。&lt;/p&gt;
&lt;p&gt;建立了完善的数据收集系统，实时收集包括电力生产数据、设备运行状态数据、用户用电数据等在内的海量数据。通过对电力生产数据的分析，发现部分生产设备存在效率低下、能耗高等问题；通过对设备运行状态数据的分析，公司能够预测设备故障并提前进行维护；通过对用户用电数据的分析，公司能够优化电力配送策略，减少电力资源损耗，从而减少损失、降低成本。&lt;/p&gt;
&lt;h1&gt;总结与展望&lt;/h1&gt;
&lt;p&gt;本章将主要对大数据在电力行业应用探究和案例描述分析进行总结，并结合实际情况，对未来的发展、研究方向进行进一步的讨论。&lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;经过对大数据在电力行业应用的深入探究，我们不难发现，大数据技术已经成为推动电力行业转型升级和可持续发展的重要力量。通过大数据技术的应用，电力行业在数据收集、处理、分析和应用方面取得了显著成效，为电力行业的运营决策、资源配置、故障预警等方面提供了有力支持。&lt;/p&gt;
&lt;p&gt;首先，大数据技术的应用提高了电力行业的运营效率。通过实时收集和分析生产一线数据，电力行业能够更准确地掌握市场动态，优化生产计划，降低生产成本。同时，大数据技术还能实现故障预警和快速响应，提高电力供应的可靠性和稳定性。&lt;/p&gt;
&lt;p&gt;其次，大数据技术的应用优化了资源配置并提升了服务质量。通过对用户用电数据的分析，电力行业能够预测用户的用电需求，提前调整生产计划，确保电力供应的充足性。此外，大数据技术还能实现智能调度和智能运维，优化电网运行状态，提高供电质量和供电效率。&lt;/p&gt;
&lt;p&gt;最后，大数据技术的应用推动了电力行业的技术创新和产业升级。通过对大数据的分析和应用，电力行业可以发现新的能源利用方式和能源技术，推动能源技术的创新和发展。同时，大数据技术还能帮助电力行业优化产业链布局，推动电力产业的升级和转型。&lt;/p&gt;
&lt;h2&gt;展望&lt;/h2&gt;
&lt;p&gt;展望未来，大数据在电力行业的应用将呈现出更加广阔的发展前景。随着技术的不断进步和应用场景的不断拓展，大数据将在电力行业的更多领域发挥重要作用。&lt;/p&gt;
&lt;p&gt;首先，大数据技术将在智能电网建设中发挥更加核心的作用。智能电网是电力行业未来的重要发展方向，而大数据是智能电网建设的关键技术之一。通过大数据技术的应用，可以实现电网的智能化管理和优化运行，提高电网的可靠性和安全性。&lt;/p&gt;
&lt;p&gt;其次，大数据技术将促进电力行业的数字化转型。数字化转型是电力行业适应新时代发展的重要途径，而大数据是数字化转型的重要支撑。通过大数据技术的应用，可以实现电力行业的数字化转型，提高电力行业的智能化水平和运营效率。&lt;/p&gt;
&lt;p&gt;最后，大数据技术将推动电力行业的跨界融合和创新发展。随着能源互联网、物联网等技术的不断发展，电力行业将与更多领域进行跨界融合和创新发展。而大数据技术作为跨界融合和创新发展的关键技术之一，将为电力行业的跨界融合和创新发展提供有力支持。&lt;/p&gt;
&lt;h1&gt;参考文献&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;[1] 王建锋.智能电网大数据处理技术现状与挑战[J].大众标准化,2020,(24):142-143.&lt;/p&gt;
&lt;p&gt;[2]万义飞,艾徐华,陶镇威.面向智能电网应用的电力大数据关键技术研究[J].电子世界,2020(18):58-59.DOI:10.19353/j.cnki.dzsj.2020.18.028.&lt;/p&gt;
&lt;p&gt;[3]丁嘉熹,周寒英,董治洲,等.基于大数据分析技术的智能电网研究[J].光源与照明,2020(09):43-44.&lt;/p&gt;
&lt;p&gt;[4]陈钱潜,骆应东.智能电网与电力系统可持续发展分析[J].集成电路应用,2023,40(10):404-405.DOI:10.19339/j.issn.1674-2583.2023.10.186.&lt;/p&gt;
&lt;p&gt;[5]李欣怡.大数据技术在智能电网中的应用策略分析[J].数字通信世界,2023(02):115-117.&lt;/p&gt;
&lt;/blockquote&gt;
</content:encoded></item><item><title>Gitee+Sourcetree 多人协同开发代码项目</title><link>https://minthana.github.io/blog/posts/giteesourcetree-%E5%A4%9A%E4%BA%BA%E5%8D%8F%E5%90%8C%E5%BC%80%E5%8F%91%E4%BB%A3%E7%A0%81%E9%A1%B9%E7%9B%AE/</link><guid isPermaLink="true">https://minthana.github.io/blog/posts/giteesourcetree-%E5%A4%9A%E4%BA%BA%E5%8D%8F%E5%90%8C%E5%BC%80%E5%8F%91%E4%BB%A3%E7%A0%81%E9%A1%B9%E7%9B%AE/</guid><pubDate>Tue, 21 May 2024 23:57:00 GMT</pubDate><content:encoded>&lt;p&gt;在课程任务安排的团队项目时候，可以使用托管平台+工具进行实时更新或修改项目代码，以此达到团队或个人完成项目代码的共同编辑&lt;/p&gt;
&lt;h1&gt;准备工作&lt;/h1&gt;
&lt;h2&gt;下载Git&lt;/h2&gt;
&lt;p&gt;可以通过官网或电脑自带的应用商店进行下载&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://git-scm.com/download&quot;&gt;Git - 下载 (git-scm.com)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2024-05-21-172742-1024x384.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;注册Gitee账号&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://gitee.com/signup#lang=zh-CN&quot;&gt;注册 - Gitee.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;注册好账号之后在设置-邮箱管理当中添加自己的邮箱账号&lt;/p&gt;
&lt;h2&gt;安装Sourcetree&lt;/h2&gt;
&lt;p&gt;可以通过官网或电脑自带的应用商店进行下载&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.sourcetreeapp.com/&quot;&gt;Sourcetree | Free Git GUI for Mac and Windows (sourcetreeapp.com)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2024-05-21-175122.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h4&gt;破解登录&lt;/h4&gt;
&lt;p&gt;⚠一定要完成&lt;/p&gt;
&lt;p&gt;教程：&lt;a href=&quot;http://t.csdnimg.cn/6Wd0v&quot;&gt;Sourcetree安装详细步骤-潮汐未见潮落(CSDN)&lt;/a&gt;&lt;/p&gt;
&lt;h1&gt;项目仓库搭建&lt;/h1&gt;
&lt;h2&gt;创建仓库&lt;/h2&gt;
&lt;p&gt;进入Gitee官网点击右上角‘+’号-新建仓库&lt;/p&gt;
&lt;p&gt;按照下列选项或根据自身需求创建仓库&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2024-05-21-180824.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;添加成员&lt;/h2&gt;
&lt;p&gt;点击管理-仓库成员管理 即可添加团队成员&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2024-05-21-233443.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;克隆项目&lt;/h2&gt;
&lt;p&gt;打开Sourcetree-Clone&lt;/p&gt;
&lt;p&gt;复制仓库的HTTPS链接克隆仓库后，将会生成对应的文件夹&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2024-05-21-233943.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2024-05-21-234135.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;更新修改仓库内容&lt;/h2&gt;
&lt;p&gt;在文件夹内添加test.txt文件后，可在Sourcetree-文件状态里查询未暂存文件&lt;/p&gt;
&lt;p&gt;通过勾选想要更新修改的文件，添加备注并提交，点击导航栏上的拉取、推送后即可更新成功&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2024-05-21-234740.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2024-05-21-234954.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</content:encoded></item><item><title>Argon-Wordpress页面设计</title><link>https://minthana.github.io/blog/posts/wordpress%E9%A1%B5%E9%9D%A2%E8%AE%BE%E8%AE%A1/</link><guid isPermaLink="true">https://minthana.github.io/blog/posts/wordpress%E9%A1%B5%E9%9D%A2%E8%AE%BE%E8%AE%A1/</guid><pubDate>Sun, 14 Apr 2024 15:21:00 GMT</pubDate><content:encoded>&lt;h1&gt;404页面设计&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://h5.qzone.qq.com/ugc/share?sharetag=74523D4AB0F0B67551A911C4F287F27C&amp;amp;bp7=&amp;amp;bp2=&amp;amp;bp1=&amp;amp;_wv=1&amp;amp;res_uin=1220121213&amp;amp;appid=2&amp;amp;cellid=1634123064&amp;amp;no_topbar=1&amp;amp;subid=&amp;amp;g_ut=3&amp;amp;from=mp&amp;amp;g_f=5758&amp;amp;srctype=62&amp;amp;ticket=&quot;&gt;腾讯404公益——QQ空间&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在网站中的404.php页面中进行添加修改&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!doctype html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;utf-8&quot;&amp;gt;
    &amp;lt;meta name=&quot;description&quot; content=&quot; XXXX的 404 错误页面，当您看到这个页面，表示您的访问出错，这个错误是您打开的页面不存在，请确认您输入的地址是正确的!虽然你访问的页面找不回来了，但是我们可以一起贡献自己的一份力量!&quot; /&amp;gt;
    &amp;lt;meta name=&quot;keywords&quot; content=&quot;404,404 错误页面,404 公益计划&quot; /&amp;gt;
    &amp;lt;title&amp;gt;404 Not Found - 公益计划&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;script type=&quot;text/javascript&quot; src=&quot;https://volunteer.cdn-go.cn/404/latest/404.js&quot; charset=&quot;utf-8&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2024-04-14-152004-1024x544.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h1&gt;网站停用提示页&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt; 
&amp;lt;html lang=&quot;en&quot;&amp;gt; 
&amp;lt;head&amp;gt; 
&amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt; 
&amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&amp;gt; 
&amp;lt;title&amp;gt;站点暂停访问&amp;lt;/title&amp;gt; 
&amp;lt;style&amp;gt; 
    body { 
        margin: 0; 
        padding: 0; 
        font-family: &apos;Arial&apos;, sans-serif; 
        background-color: #f2f2f2; 
        display: flex; 
        justify-content: center; 
        align-items: center; 
        height: 100vh; 
        overflow: hidden; 
    } 

    .pause-container { 
        text-align: center; 
        position: relative; 
        width: 100%; 
        max-width: 600px; 
    } 

    .pause-icon { 
        font-size: 48px; 
        color: #333; 
        margin-bottom: 20px; 
        animation: pulse 2s infinite; 
    } 

    @keyframes pulse { 
        0% { transform: scale(1); } 
        50% { transform: scale(1.1); } 
        100% { transform: scale(1); } 
    } 

    h1 { 
        font-size: 32px; 
        font-weight: bold; 
        color: #333; 
        margin: 0 0 20px 0; 
    } 

    p { 
        font-size: 18px; 
        color: #666; 
        margin: 0; 
    } 

    .pause-overlay { 
        position: absolute; 
        top: 0; 
        left: 0; 
        width: 100%; 
        height: 100%; 
        background: url(&apos;data:image/svg+xml;utf8,&amp;lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; viewBox=&quot;0 0 200 200&quot;&amp;gt;&amp;lt;path d=&quot;M0,100 C100,0 200,100 100,200&quot; style=&quot;fill:none;stroke:rgba(0,0,0,0.1);stroke-width:2&quot; /&amp;gt;&amp;lt;/svg&amp;gt;&apos;); 
        background-size: 50px 50px; 
        animation: overlay-animation 2s linear infinite; 
        opacity: 0.5; 
    } 

    @keyframes overlay-animation { 
        0% { background-position: 0 0; } 
        100% { background-position: 50px 50px; } 
    } 

    /* 响应式布局 */ 
    @media (max-width: 600px) { 
        h1 { 
            font-size: 28px; 
        } 
        p { 
            font-size: 16px; 
        } 
    } 
&amp;lt;/style&amp;gt; 
&amp;lt;/head&amp;gt; 
&amp;lt;body&amp;gt; 
    &amp;lt;div class=&quot;pause-container&quot;&amp;gt; 
    &amp;lt;div class=&quot;pause-icon&quot;&amp;gt;&amp;lt;/div&amp;gt; 
    &amp;lt;h1&amp;gt;站点暂停访问&amp;lt;/h1&amp;gt; 
    &amp;lt;p&amp;gt;很抱歉，该站点暂时无法访问。请联系管理员了解详情。&amp;lt;/p&amp;gt; 
    &amp;lt;div class=&quot;pause-overlay&quot;&amp;gt;&amp;lt;/div&amp;gt; 
    &amp;lt;/div&amp;gt; 
&amp;lt;/body&amp;gt; 
&amp;lt;/html&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2024-04-14-151841-1024x541.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h1&gt;随机诗词&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://jinrishici.com&quot;&gt;jinrishici.com&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;p style=&quot;color:white;font-weight:bold&quot;&amp;gt;随机诗词&amp;lt;/p&amp;gt;
&amp;lt;script src=&quot;https://sdk.jinrishici.com/v2/browser/jinrishici.js&quot; charset=&quot;utf-8&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;div id=&quot;poem_sentence&quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;div id=&quot;poem_info&quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
    jinrishici.load(function(result) {
        var sentence = document.querySelector(&quot;#poem_sentence&quot;)
        var info = document.querySelector(&quot;#poem_info&quot;)
        sentence.innerHTML = result.data.content
        info.innerHTML = &apos;【&apos; + result.data.origin.dynasty + &apos;】&apos; + result.data.origin.author + &apos;《&apos; + result.data.origin.title + &apos;》&apos;
    });
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;随机一言&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.hitokoto.cn/sentence/demo.html&quot;&gt;https://developer.hitokoto.cn/sentence/demo.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;https://v1.hitokoto.cn/（从7种分类中随机抽取）&lt;br /&gt;
https://v1.hitokoto.cn/?c=b （请求获得一个分类是漫画的句子）&lt;br /&gt;
https://v1.hitokoto.cn/?c=f&amp;amp;encode=text （请求获得一个来自网络的句子，并以纯文本格式输出）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;p style=&quot;color:white;font-weight:bold&quot;&amp;gt;随机一言&amp;lt;/p&amp;gt;
&amp;lt;p id=&quot;hitokoto&quot;&amp;gt;&amp;lt;a href=&quot;#&quot; id=&quot;hitokoto_text&quot;&amp;gt;:D 获取中...&amp;lt;/a&amp;gt;&amp;lt;/p&amp;gt;
&amp;lt;p id=&quot;hitokoto&quot;&amp;gt;&amp;lt;a href=&quot;#&quot; id=&quot;hitokoto_info&quot;&amp;gt;:D 获取中...&amp;lt;/a&amp;gt;&amp;lt;/p&amp;gt;
&amp;lt;script&amp;gt;
    fetch(&apos;https://v1.hitokoto.cn/?c=b &apos;)
        .then(response =&amp;gt; response.json())
        .then(data =&amp;gt; {
            const hitokoto = document.querySelector(&apos;#hitokoto_text&apos;)
            hitokoto.href = `https://v1.hitokoto.cn/?c=b?uuid=${data.uuid}`
            hitokoto.innerText = data.hitokoto
            const hitokotoInfo = document.querySelector(&apos;#hitokoto_info&apos;)
            hitokotoInfo.href = `https://v1.hitokoto.cn/?c=b?uuid=${data.uuid}`
            hitokotoInfo.innerText = data.from_who+&quot;《&quot;+data.from+&quot;》&quot;
    })
    .catch(console.error)
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;背景滚动模糊&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!--滚动模糊--&amp;gt;
&amp;lt;script&amp;gt;
    window.addEventListener(&quot;scroll&quot;, function (e) {
    if (window.scrollY &amp;gt; window.innerHeight * 0.3) {
    	document.querySelector(&quot;#content&quot;).classList.add(&quot;scrolled&quot;);
    } else {
    	document.querySelector(&quot;#content&quot;).classList.remove(&quot;scrolled&quot;);
    }});
&amp;lt;/script&amp;gt;
&amp;lt;style&amp;gt;
    #content.scrolled::before, #content.scrolled::after {
        filter: blur(6px); /*数字越大虚化越明显*/
        transform: scale(1.02); /*数字越大背景放大越明显*/
    }
    #content::before, #content::after {
        transition: filter .3s ease, transform .3s ease !important;
        filter: blur(0px);
        transform: scale(1.02);
    }
&amp;lt;/style&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>机器学习案例</title><link>https://minthana.github.io/blog/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%A1%88%E4%BE%8B/</link><guid isPermaLink="true">https://minthana.github.io/blog/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%A1%88%E4%BE%8B/</guid><pubDate>Wed, 27 Mar 2024 16:45:00 GMT</pubDate><content:encoded>&lt;p&gt;&lt;a href=&quot;https://gitee.com/rongwu651/machine-learning-case-tutorial/blob/master/pdf/%E5%AE%9E%E9%AA%8C1%E7%94%B5%E5%BD%B1%E7%A5%A8%E6%88%BF%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1.pdf&quot;&gt;实验1电影票房数据统计.pdf · Mint/机器学习案例教程 &lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://gitee.com/rongwu651/machine-learning-case-tutorial/blob/master/pdf/%E5%AE%9E%E9%AA%8C2%E6%B3%B0%E5%9D%A6%E5%B0%BC%E5%85%8B%E5%8F%B7%E6%95%B0%E6%8D%AE%E2%80%94%E2%80%94%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B.pdf&quot;&gt;实验2泰坦尼克号数据——特征工程.pdf · Mint/机器学习案例教程&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://gitee.com/rongwu651/machine-learning-case-tutorial/blob/master/pdf/%E5%AE%9E%E9%AA%8C3%E6%B3%A2%E5%A3%AB%E9%A1%BF%E6%88%BF%E4%BB%B7%E9%A2%84%E6%B5%8B%E2%80%94%E2%80%94%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92.pdf&quot;&gt;实验3波士顿房价预测——线性回归.pdf · Mint/机器学习案例教程 &lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://gitee.com/rongwu651/machine-learning-case-tutorial/blob/master/pdf/%E5%AE%9E%E9%AA%8C4%E9%B8%A2%E5%B0%BE%E8%8A%B1%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92%E5%88%86%E7%B1%BB%E5%AE%9E%E8%B7%B5%E2%80%94%E2%80%94%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92.pdf&quot;&gt;实验4鸢尾花逻辑回归分类实践——逻辑回归.pdf · Mint/机器学习案例教程 &lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://gitee.com/rongwu651/machine-learning-case-tutorial/blob/master/pdf/%E5%AE%9E%E9%AA%8C5KNN%E7%BA%A2%E8%91%A1%E8%90%84%E9%85%92%E5%93%81%E8%B4%A8%E5%88%86%E7%B1%BB%E9%A2%84%E6%B5%8B%E2%80%94%E2%80%94K%E9%82%BB%E8%BF%91.pdf&quot;&gt;实验5KNN红葡萄酒品质分类预测——K邻近.pdf · Mint/机器学习案例教程 &lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://gitee.com/rongwu651/machine-learning-case-tutorial/blob/master/pdf/%E5%AE%9E%E9%AA%8C6NaiveBayesian%E5%9E%83%E5%9C%BE%E9%82%AE%E4%BB%B6%E5%88%86%E7%B1%BB%E9%A2%84%E6%B5%8B%E2%80%94%E2%80%94%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF.pdf&quot;&gt;实验6NaiveBayesian垃圾邮件分类预测——朴素贝叶斯.pdf · Mint/机器学习案例教程 &lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://gitee.com/rongwu651/machine-learning-case-tutorial/blob/master/pdf/%E5%AE%9E%E9%AA%8C7%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95%E5%AF%B9%E7%B3%96%E5%B0%BF%E7%97%85%E8%BF%9B%E8%A1%8C%E8%AF%8A%E6%96%AD%E2%80%94%E2%80%94ANN%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C.pdf&quot;&gt;实验7神经网络算法对糖尿病进行诊断——ANN神经网络.pdf · Mint/机器学习案例教程 &lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://gitee.com/rongwu651/machine-learning-case-tutorial/blob/master/pdf/%E5%AE%9E%E9%AA%8C8%E5%86%B3%E7%AD%96%E6%A0%91%E9%A2%84%E6%B5%8B%E5%B9%BF%E5%91%8A%E7%82%B9%E5%87%BB%E2%80%94%E2%80%94%E5%86%B3%E7%AD%96%E6%A0%91.pdf&quot;&gt;实验8决策树预测广告点击——决策树.pdf · Mint/机器学习案例教程 &lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://gitee.com/rongwu651/machine-learning-case-tutorial/blob/master/pdf/%E5%AE%9E%E9%AA%8C9%E4%BF%A1%E7%94%A8%E5%8D%A1SVM%E5%88%86%E7%B1%BB%E5%AE%9E%E8%B7%B5%E2%80%94%E2%80%94%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA.pdf&quot;&gt;实验9信用卡SVM分类实践——支持向量机.pdf · Mint/机器学习案例教程 &lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://gitee.com/rongwu651/machine-learning-case-tutorial/blob/master/pdf/%E5%AE%9E%E9%AA%8C10%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95%E5%AF%B9%E5%AE%A2%E6%88%B7%E7%BB%86%E5%88%86%E2%80%94%E2%80%94%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95.pdf&quot;&gt;实验10聚类算法对客户细分——聚类算法.pdf · Mint/机器学习案例教程 &lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://gitee.com/rongwu651/machine-learning-case-tutorial/blob/master/pdf/%E5%AE%9E%E9%AA%8C11%E5%AE%9A%E6%9C%9F%E5%AD%98%E6%AC%BE%E5%AE%A2%E6%88%B7%E9%A2%84%E6%B5%8B%E2%80%94%E2%80%94%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97.pdf&quot;&gt;实验11定期存款客户预测——随机森林.pdf · Mint/机器学习案例教程 &lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://gitee.com/rongwu651/machine-learning-case-tutorial/blob/master/pdf/%E5%AE%9E%E9%AA%8C12MNIST%E6%95%B0%E6%8D%AE%E9%9B%86%E8%BF%9B%E8%A1%8CPCA%E9%99%8D%E7%BB%B4%E4%B8%8E%E9%87%8D%E6%9E%84%E2%80%94%E2%80%94PCA.pdf&quot;&gt;实验12MNIST数据集进行PCA降维与重构——PCA.pdf · Mint/机器学习案例教程 &lt;/a&gt;&lt;/p&gt;
</content:encoded></item><item><title>数据库概论</title><link>https://minthana.github.io/blog/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E8%AE%BA/</link><guid isPermaLink="true">https://minthana.github.io/blog/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E8%AE%BA/</guid><pubDate>Mon, 26 Feb 2024 10:40:00 GMT</pubDate><content:encoded>&lt;p&gt;数据库管理系统：MySQL&lt;/p&gt;
&lt;h2&gt;第一章 数据库系统概论&lt;/h2&gt;
&lt;h3&gt;数据库基本概念&lt;/h3&gt;
&lt;h4&gt;信息与数据及数据处理&lt;/h4&gt;
&lt;p&gt;1．信息（Information)&lt;br /&gt;
(1）信息的定义&lt;br /&gt;
在不同的领域中，信息的含义有所不同。一般认为，信息是关于现实世界事物的存在方式或运动状态反映的综合。&lt;br /&gt;
(2）信息的特征&lt;br /&gt;
①信息依附于物质载体和能量。&lt;br /&gt;
②信息是可以感知的。&lt;br /&gt;
③信息是可存储、加工、传递和再生的。&lt;/p&gt;
&lt;p&gt;2．数据（Data)&lt;br /&gt;
(1）数据的定义&lt;br /&gt;
数据是用来记录信息的可识别的符号，是信息的具体表现形式。&lt;/p&gt;
&lt;p&gt;(2)数据的表现形式&lt;br /&gt;
数据有多种表现形式，不仅包含数字和文字，还包括图形、图像、声音、语言等。&lt;/p&gt;
&lt;p&gt;3.数据与信息的联系&lt;/p&gt;
&lt;p&gt;数据是信息的符号表示或载体，信息则是数据的内涵，是对数据的语义解释，数据与其语义是不可分的。&lt;br /&gt;
如&quot;80&quot;是一个数据，可以是一个学生的某门课程的成绩，也可以是某个人体重，还可以是某个人的年龄包含数字和文字，还包括图形、图像、声音、语言等。&lt;/p&gt;
&lt;p&gt;4．数据处理&lt;br /&gt;
数据处理是指对各种形式的数据进行收集、存储、传播、检索、分类、加工或计算，打印各类报表或输出各种需要的图形。&lt;br /&gt;
数据处理的目的一是借助计算机科学地保存和管理大量复杂的数据，以便人们方便而充分地利用这些信息资源；二是从大量的原始数据抽取并推导出对人们有价值的、有意义的信息，为进一步的活动提供决策的依据。可用下式直观地表示信息、数据与数据处理的关系：&lt;/p&gt;
&lt;p&gt;信息＝数据＋数据处理&lt;/p&gt;
&lt;h4&gt;数据库、数据库管理系统及数据库系统&lt;/h4&gt;
&lt;p&gt;1．数据库&lt;br /&gt;
(1）数据库的定义&lt;br /&gt;
数据库（Database，简称DB）是长期储存在计算机内、有组织的、可共享的大量数据的集合。&lt;br /&gt;
(2）数据库的基本特征&lt;br /&gt;
数据按一定的数据模型组织、描述和储存；&lt;br /&gt;
可为各种用户共享；冗余度较小；&lt;br /&gt;
数据独立性较高；易扩展。&lt;/p&gt;
&lt;p&gt;广义：数据库是存储数据的东西&lt;/p&gt;
&lt;p&gt;狭义：数据库是存储在计算机内，结构化的表格&lt;/p&gt;
&lt;p&gt;2．数据库管理系统&lt;br /&gt;
(1）什么是DBMS&lt;br /&gt;
位于用户与操作系统之间的一层数据管理软件。是基础软件，是一个大型复杂的软件系统&lt;br /&gt;
(2)   DBMS的用途&lt;br /&gt;
科学地组织和存储数据、高效地获取和维护数据&lt;/p&gt;
&lt;p&gt;(3)   DBMS的主要功能&lt;br /&gt;
数据定义功能：&lt;br /&gt;
    提供数据定义语言（DDL);&lt;br /&gt;
    定义数据库中的数据对象。&lt;br /&gt;
数据组织、存储和管理：&lt;br /&gt;
    分类组织、存储和管理各种数据；&lt;br /&gt;
    确定组织数据的文件结构和存取方式；&lt;br /&gt;
    实现数据之间的联系；&lt;br /&gt;
    提供多种存取方法提高存取效率。&lt;/p&gt;
&lt;p&gt;数据操纵功能：&lt;br /&gt;
提供数据操纵语言（DML)&lt;br /&gt;
实现对数据库的基本操作（查询、插入、删除和修改）。&lt;/p&gt;
&lt;p&gt;数据库的事务管理和运行：&lt;br /&gt;
数据库在建立、运行和维护时由DBMS统一管理和控制；&lt;br /&gt;
保证数据的安全性、完整性、多用户对数据的并发使用；发生故障后的系统恢复。&lt;/p&gt;
&lt;p&gt;3．数据库系统&lt;br /&gt;
数据库系统（Database System，简称DBS）在计算机系统中引入数据库后的系统构成。&lt;/p&gt;
&lt;h4&gt;数据管理技术的产生和发展&lt;/h4&gt;
&lt;p&gt;数据管理技术的发展动力&lt;br /&gt;
应用需求的推动&lt;br /&gt;
计算机硬件的发展&lt;br /&gt;
计算机软件的发展&lt;/p&gt;
&lt;h4&gt;数据库系统的特点&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;面向全组织的复杂的数据结构&lt;/li&gt;
&lt;li&gt;数据的共享性高，冗余度低，易扩充&lt;/li&gt;
&lt;li&gt;有较高的数据和程序的独立性&lt;/li&gt;
&lt;li&gt;统一的数据控制功能&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;数据模型&lt;/h3&gt;
&lt;h4&gt;数据抽象的过程&lt;/h4&gt;
&lt;p&gt;信息是对客观事物及其关系的描述，数据是信息的具体化、形象化，是表示信息的一种符号。数据、信息、物质三者之间互为联系，自成一体。而从事物的状态到表示该状态的数据，经历了三个不同的世界：现实世界、信息世界（即观念世界）和数据世界（即计算机世界）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/Capture_20240226_111916-1024x255.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h4&gt;数据模型及组成要素&lt;/h4&gt;
&lt;p&gt;数据模型&lt;/p&gt;
&lt;p&gt;(1) 概念模型&lt;br /&gt;
也称信息模型，它是按用户的观点来对数据和信息建模，用于数据库设计。&lt;/p&gt;
&lt;p&gt;(2) 逻辑模型&lt;br /&gt;
主要包括网状模型、层次模型、关系模型、面向对象模型等，按计算机系统的观点对数据建模，用于DBMS实现。&lt;/p&gt;
&lt;p&gt;(3) 物理模型&lt;br /&gt;
是对数据最底层的抽象，描述数据在系统内部的表示方式和存取方法，在磁盘或磁带上的存储方式和存取方法。&lt;/p&gt;
&lt;p&gt;组成要素&lt;br /&gt;
数据模型是严格定义的一组概念的集合。这些概念精确地描述了系统的静态特性、动态特性和完整性约束条件。因此数据模型通常由数据结构、数据操作和数据的完整性约束条件三部分组成。&lt;/p&gt;
&lt;p&gt;(1) 数据结构&lt;br /&gt;
数据结构描述的是数据库的组成对象以及对象之间的联系，是对系统静态特性的描述。&lt;/p&gt;
&lt;p&gt;(2) 数据操作&lt;br /&gt;
数据操作是指对数据库中各种对象(型)的实例(值)允许执行的操作的集合，包括操作及有关的操作规则，是对系统动态特性的描述。&lt;/p&gt;
&lt;p&gt;(3) 数据的完整性约束条件数据的完整性约束条件是一组完整性规则，是对系统静态特性的描述。&lt;/p&gt;
&lt;h2&gt;第二章 关系模型&lt;/h2&gt;
&lt;p&gt;用二维表格的形式表示实体以及实体间联系的数据模型称为关系模型，这个二维表被称为关系，这是一种非形式化的定义。&lt;br /&gt;
关系模型是建立在集合代数理论的基础上的，因此，这里从集合论角度给出关系的形式化定义。首先引入域和笛卡尔积的概念。&lt;/p&gt;
&lt;h3&gt;域&lt;/h3&gt;
&lt;p&gt;域是一组具有相同数据类型的值的集合，又称为值域，用D表示。域中所包含的值的个数称为域的基数，用m表示。例如：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;D2=性别集合={男，女}，m2=2;&lt;/p&gt;
&lt;p&gt;在关系模型中用域来表示属性的取值范围，在上面例子中，D2为域名，表示学生关系中性别的集合。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;笛卡尔积&lt;/h3&gt;
&lt;p&gt;笛卡尔积可表示为一个二维表，表中的每行对应一个元组，表中的每列对应一个域&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2024-03-04-134523-1024x399.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;关系&lt;/h3&gt;
&lt;p&gt;笛卡尔积D1×D2× ... ×Dn的子集称为定义在域D1，D2，…， Dn上的关系，表示为R(D1，D2，…，Dn)，R表示关系的名字，n称为关系的目或度(Degree)&lt;br /&gt;
当n=1时，称该关系为单元关系&lt;br /&gt;
当n=2时，称该关系为二元关系&lt;/p&gt;
&lt;p&gt;(1) 如果一个关系的元组个数是无限的，则称该关系是无限关系;如果一个关系的元组个数是有限的，则称该关系是有限关系。一般仅处理有限关系。&lt;/p&gt;
&lt;p&gt;(2) 关系是笛卡尔积的有限子集，所以关系也是一个二维表，表中的每行对应一个元组，表中的每列对应一个域。&lt;/p&gt;
&lt;p&gt;(3) 由于表中的列可以是相同的域，为了加以区别，每列必须起一个名字，称为属性，n目关系必须有n个属性，属性的名字惟一，属性的取值范围D(i=1，2，…，n)称为值域。&lt;/p&gt;
&lt;h3&gt;三类关系&lt;/h3&gt;
&lt;p&gt;(1) 基本关系(基本表或基表)&lt;br /&gt;
实际存在的表，是实际存储数据的逻辑表示&lt;/p&gt;
&lt;p&gt;(2) 查询表&lt;br /&gt;
查询结果对应的表&lt;/p&gt;
&lt;p&gt;(3) 视图表&lt;br /&gt;
由基本表或其他视图表导出的表，是虚表，不对应实际存储的数据&lt;/p&gt;
&lt;h3&gt;关系的基本性质&lt;/h3&gt;
&lt;p&gt;在关系模型中，对关系作了种种限制，关系具有如下性质&lt;/p&gt;
&lt;p&gt;(1) 每一个分量都必须是不可再分的数据项。&lt;/p&gt;
&lt;p&gt;(2) 每一列中的分量必须是同一类型的数据，来自同一个域。&lt;/p&gt;
&lt;p&gt;(3) 每列必须有不同的属性名，不同的列可以来自同一个域。&lt;/p&gt;
&lt;p&gt;(4) 列的顺序可以是任意,&lt;/p&gt;
&lt;p&gt;(5) 任意两个元组不能完全相同。&lt;/p&gt;
&lt;p&gt;(6) 行的顺序可以是任意。&lt;/p&gt;
&lt;h3&gt;码&lt;/h3&gt;
&lt;p&gt;(1) 候选码：若关系中的某一属性组的值能唯一地标识一个元组，则称该属性组为候选码&lt;/p&gt;
&lt;p&gt;(2) 全码：关系模式的所有属性组是这个关系模式的候选码，称为全码&lt;/p&gt;
&lt;p&gt;(3) 主码：若一个关系有多个候选码，则选定其中一个为主码&lt;/p&gt;
&lt;p&gt;(4) 主属性：候选码的诸属性称为主属性，不包含在任何侯选码中的属性称为非主属性或非码属性&lt;/p&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在学生实体中，“学号”是能唯一的区分学生实体的，同时又假设“姓名”、“班级”的属性组合足以区分学生实体，那么{学号}和{姓名，班级}都是候选码。&lt;/p&gt;
&lt;p&gt;候选码就是可以被选为主码的属性或属性组。当一个关系有N个属性或属性组可以唯一标识时，则说明该关系有N个候选码，可以选定其中一个作为主码。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://8.134.219.154/%e5%85%8d%e8%b4%a3%e5%a3%b0%e6%98%8e/&quot;&gt;数据库中，码、主码、候选码的区别？ - 炸弹客的回答 - 知乎&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;关系模型的三级体系结构&lt;/h3&gt;
&lt;h4&gt;关系模式&lt;/h4&gt;
&lt;p&gt;关系模式是对关系的描述，关系模式是型，关系是值。关系模式的形式化定义为  &lt;strong&gt;R(U,D, dom，F)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;关系模式通常可以简记为 R(U)或 R(A1,A2,... An)&lt;/p&gt;
&lt;p&gt;R：关系名&lt;br /&gt;
U：组成该关系的属性名集合&lt;br /&gt;
D：属性组4属性所来自的域&lt;br /&gt;
DOM：属性向域的映象集合&lt;br /&gt;
F：属性间的数据依赖关系集合&lt;br /&gt;
A1，A2，……，An：属性名&lt;/p&gt;
&lt;h4&gt;关系子模式&lt;/h4&gt;
&lt;p&gt;关系子模式是用户所需或感兴趣数据的结构的描述，其中包括这些数据来自哪些模式和应满足哪些条件。&lt;/p&gt;
&lt;p&gt;例如，在学生选课数据库中，学生最关心自己所选课程的成绩、学分等信息。这时就需要用到成绩子模式(学号，姓名，课程名，成绩，学分)子模式对应的数据来源于学生关系、选课关系和课程关系，在构造时应满足学生关系和选课关系的元组在学号上的值相等，选课关系和课程关系的元组在课程号上的值相等。&lt;/p&gt;
&lt;h4&gt;存储模式&lt;/h4&gt;
&lt;p&gt;存储模式描述了关系是如何在物理存储设备上存储的。&lt;/p&gt;
&lt;h3&gt;关系数据库&lt;/h3&gt;
&lt;p&gt;关系数据库采用的是关系模型，所有关系模式的集合构成了关系数据库的式，即关系数据库型的描述。关系数据库的值是这些关系模式在某一时刻对应的关系的集合，通常称之为关系数据库。&lt;/p&gt;
&lt;h3&gt;关系代数&lt;/h3&gt;
&lt;h4&gt;关系代数运算符&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2024-03-04-142750-2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h4&gt;传统的集合运算&lt;/h4&gt;
&lt;p&gt;(1) 并：R∪S&lt;/p&gt;
&lt;p&gt;(2) 差：R−S = R−(R∩S)&lt;/p&gt;
&lt;p&gt;(3) 交：R∩S&lt;/p&gt;
&lt;p&gt;(4) 笛卡尔积：R×S&lt;/p&gt;
&lt;h4&gt;专门的关系运算&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;http://t.csdnimg.cn/yVHTB&quot;&gt;相关文章: 《关系数据库：专门关系运算》 -目睹整个事件的易先生的文章 -CSDN&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;(1) 投影：π&lt;/p&gt;
&lt;p&gt;从R中选择出若干属性列组成新的关系&lt;/p&gt;
&lt;p&gt;(2) 选择：&lt;strong&gt;σ&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;(3) 连接：&lt;strong&gt;⋈&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;(4) 除：÷&lt;/p&gt;
&lt;h2&gt;第三章 关系型数据库标准语言SQL&lt;/h2&gt;
&lt;p&gt;SQL语言特点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一体化&lt;/li&gt;
&lt;li&gt;高度非过程化&lt;/li&gt;
&lt;li&gt;面向集合的操作方式&lt;/li&gt;
&lt;li&gt;提供多种使用方式&lt;/li&gt;
&lt;li&gt;功能强大、简洁易用&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;相关概念&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;基本表：本身独立存在的表;SQL中一个关系就对应一个基本表;一个(或多个)基本表对应一个存储文件;一个表可以带若干索引。&lt;/li&gt;
&lt;li&gt;视图：从一个或几个基本表导出的表;数据库中只存放视图的定义而不存放视图对应的数据，&lt;br /&gt;
视图是一个虚表;用户可以在视图上再定义视图。&lt;/li&gt;
&lt;li&gt;存储文件：逻辑结构组成了关系数据库的内模式;物理结构是任意的，对用户透明。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;基本数据类型&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2024-03-16-133302.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;SQL分类&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2024-03-25-134225.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;数据定义&lt;/h3&gt;
&lt;p&gt;SQL的数据定义功能：模式定义、表定义、视图和索引的定义&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2024-03-25-134535.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h4&gt;模式的定义和创建&lt;/h4&gt;
&lt;p&gt;模式的创建：在SQL中，一个模式由模式名和模式的拥有者的用户名来确定&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CREATE SCHEMA&amp;lt;模式名&amp;gt;AUTHORIZATION&amp;lt;用户名&amp;gt;[&amp;lt;表定义子句&amp;gt;|&amp;lt;视图定义子句&amp;gt;|&amp;lt;授权定义子句&amp;gt;]&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE SCHEAM Study AUTHORIZATION 张明
CREATE TABLE Study(  ......
);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;模式的删除：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;DROP SCHEMA&amp;lt;模式名&amp;gt;&amp;lt;CASCADE|RESTRICT&amp;gt;;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;其中CASCADE和RESTRICT两者必选其一。&lt;/p&gt;
&lt;p&gt;CASCADE（级联）：删除该模式中所有的数据库对象。&lt;/p&gt;
&lt;p&gt;RESTRICT（限制）：如果该模式中已经定义了下属的数据库对象，则拒绝该删除语句的执行。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; DROP SCHEMA Study CASCADE
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;基本表的定义、删除和修改&lt;/h4&gt;
&lt;p&gt;定义基本表&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE&amp;lt;表名&amp;gt;(  &amp;lt;列名&amp;gt; &amp;lt;数据类型&amp;gt; [&amp;lt;列级完整性约束性条件&amp;gt;],  &amp;lt;列名&amp;gt; &amp;lt;数据类型&amp;gt; [&amp;lt;列级完整性约束性条件&amp;gt;],  ......  [&amp;lt;表级完整性约束条件&amp;gt;]); 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;修改基本表&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ALTER TABLE &amp;lt;表名&amp;gt;
[ALTER COLUMN &amp;lt;列名&amp;gt; &amp;lt;新数据类型&amp;gt;] |
[ADD [COLUMN] &amp;lt;列名&amp;gt; &amp;lt;数据类型&amp;gt;] |
[DROP COLUMN &amp;lt;列名&amp;gt;] |
[ADD PRIMARY KEY (列名[,...n])] |
[ALTER FOREIGN KEY &amp;lt;列名&amp;gt; REFERNECES 表名 (列名)];
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;删除基本表&lt;/p&gt;
&lt;p&gt;RESTRICT: 如果存在被其他表的约束引用，则不能被删除&lt;/p&gt;
&lt;p&gt;CLUSTER：无视依赖，并把相关依赖对象直接删除&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;DROP TABLE &amp;lt;表名&amp;gt; [RESTRICT | CASCADE];
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;索引的创建和删除&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;#创建索引  次序：ASC(升序)  DESC(降序)
CREATE [UNIQUE]|[CLUSTER] INDEX &amp;lt;索引名&amp;gt; ON [表名](&amp;lt;列名&amp;gt;[&amp;lt;次序&amp;gt;],...)
#删除索引
DROP INDEX &amp;lt;索引名&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;数据查询&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2024-03-25-151102.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h4&gt;单表查询&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;1.查询指定列
SELECT `NAME`,`ID`,`PWD` FROM USERS;
2.查询全部列
SELECT * FROM USERS;
3.查询经过计算的列  (算数表达式、字符串常量、函数、列别名)
SELECT `PWD` AS `密码` FROM USERS;
SELECT CONCAT(`姓名 = `,`NAME`) FROM USERS;
4.消除取值重复行
SELECT DISTINCT `ID` FROM USERS;

#————————————————————————

5.比较大小 =,&amp;lt;,&amp;gt;,&amp;lt;=,&amp;gt;=,!=
SELECT &apos;BIRTH&apos; FROM USERS WHERE `BIRTH`&amp;gt; &apos;2000-01-01&apos;;
6.确认范围 between and,not between and
SELECT `ID` FROM USERS WHERE `ID` BETWEEN 1 AND 10;
7.确认集合 in, not in
SELECT `NAME` FROM USERS WHERE `BIRTH` IN(&apos;2000-01-01&apos;,&apos;2024-01-01&apos;);
8.字符匹配 like, not like  %匹配0或多个任意字符， _匹配任意一个字符
SELECT * FROM USERS WHERE `NAME` LIKE &apos;张三&apos;;  #查询张三信息
SELECT * FROM USERS WHERE `NAME` LIKE &apos;张%&apos;;  #查询姓张的 
SELECT * FROM USERS WHERE `NAME` LIKE &apos;张_&apos;;  #查询张某(两字) 
9.is null, is not null  &apos;is&apos;不能用&apos;=&apos;替换
SELECT `NAME` FROM USERS WHERE `PWD` IS NULL;
10.多重条件查询 and, or  and&amp;gt;or(优先级)

#————————————————————————
11.对结果进行排序 ORDER BY  次序：ASC(升序) DESC(降序) 默认值为升序
SELECT * FROM USERS ORDER BY `ID` DESC;

#————————————————————————
12.聚集函数 COUNT()、SUM()、AVG()平均值、MAX()、MIN()
SELECT COUNT(*) FROM USERS #查询人数

#————————————————————————
13.分组查询 GROUP BY [HAVING] 通过以某列进行分组 再做聚集函数计算
SELECT region, SUM(population), SUM(area)
FROM bbc
GROUP BY region
HAVING SUM(area)&amp;gt;1000000
#在这里，我们不能用where来筛选超过1000000的地区，因为表中不存在这样一条记录。相反，having子句可以让我们筛选成组后的各组数据
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;多表连接查询&lt;/h4&gt;
&lt;h4&gt;嵌套查询&lt;/h4&gt;
&lt;h4&gt;集合查询&lt;/h4&gt;
&lt;h4&gt;存储查询结果到表中&lt;/h4&gt;
&lt;h4&gt;基于派生表的查询&lt;/h4&gt;
</content:encoded></item><item><title>云服务器搭建jupyter notebook</title><link>https://minthana.github.io/blog/posts/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BAjupyter-notebook/</link><guid isPermaLink="true">https://minthana.github.io/blog/posts/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BAjupyter-notebook/</guid><pubDate>Fri, 02 Feb 2024 18:11:00 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;p&gt;利用阿里云服务器搭建jupyter notebook，完成简单的机器学习和数据分析&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;个人需求操作&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;conda activate kr# 进入kr虚拟环境
nohup jupyter notebook --allow-root &amp;amp; #启动Jupyter服务
lsof -i:9999 #查询进程pid
kill -9 pid #结束进程
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2&gt;正文内容&lt;/h2&gt;
&lt;h3&gt;下载Linux版本的anaconda&lt;/h3&gt;
&lt;p&gt;在根目录下mkdir目录anaconda3并通过宝塔上传文件至该目录。在终端中安装anaconda&lt;/p&gt;
&lt;p&gt;镜像下载anaconda ：&lt;a href=&quot;https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/&quot;&gt;https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cd /anaconda3
bash Anaconda3-2023.09-0-Linux-x86_64.sh #根据个人下载的版本选择
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;一直按Enter键，输入两次yes（一次确认安装，一次确认安装路径）&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;添加环境配置&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;sudo vim /etc/profile # 步骤一：进入配置文件中
PATH=/root/anaconda3/bin:$PATH  # 步骤二：在文件尾部添加该代码
source /etc/profil # 步骤三：保存并退出文件后更新配置
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输入python出现带有anaconda的字样说明成功&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;安装Jupyter Notebook&lt;/h3&gt;
&lt;p&gt;建立一个名为kr的虚拟环境&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;conda create -n kr python=3.8
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;进入虚拟环境&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;conda activate kr # 进入虚拟环境
conda deactivate #退出虚拟环境
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在kr中安装jupyter notebook&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;pip install jupyter
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;设置密码&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;python # 步骤一：进入Python环境
from jupyter_server.auth import passwd# 步骤二：设置密码
passwd() 
# 步骤三：然后输入两次密码来设置密码，然后会产生私钥，我们一定要记下来
exit()# 步骤四：退出python
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h3&gt;添加jupyter配置信息&lt;/h3&gt;
&lt;p&gt;输入命令，生成.py配置文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;jupyter notebook --generate-config
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;会在./root/.jupyter生成一个.py文件&lt;/p&gt;
&lt;p&gt;添加配置信息&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/Screenshot_20240202_173804.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;进入文件中添加以上内容&lt;/p&gt;
&lt;p&gt;password：更改为自己保存的哈希值密码（即私钥）&lt;/p&gt;
&lt;p&gt;notebook_dir：自定义存放jupyter文件的根目录（可删，默认为/root）&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;放行端口&lt;/h3&gt;
&lt;p&gt;在宝塔和阿里云中放行9999端口&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;启动和关闭Jupyter服务&lt;/h3&gt;
&lt;p&gt;启动服务：域名+端口9999即可访问&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;nohup jupyter notebook --allow-root &amp;amp;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;nohup表示no hang up, 就是不挂起, 于是这个命令执行后即使终端退出, 也不会停止运行。但要手动结束&lt;/p&gt;
&lt;p&gt;结束服务&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;lsof -i:9999 # 查看运行jupyter进程的pid
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;images/Screenshot_20240202_180152.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kill -9 pid #结束进程
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>Python数据分析</title><link>https://minthana.github.io/blog/posts/python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/</link><guid isPermaLink="true">https://minthana.github.io/blog/posts/python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/</guid><pubDate>Wed, 24 Jan 2024 21:40:00 GMT</pubDate><content:encoded>&lt;p&gt;教材：&lt;a href=&quot;http://www.tup.tsinghua.edu.cn/booksCenter/book_09195101.html&quot;&gt;Python数据分析案例教程（微课版）清华大学出版社&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;开发环境：Anaconda + Jupyter Notebook&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;数据分析概论&lt;/h2&gt;
&lt;h3&gt;概论&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;数据&lt;/strong&gt;是人们进行各种统计、计算、科学研究或技术设计等所依据的数值等原材料&lt;/p&gt;
&lt;p&gt;在计算机科学领域，数据是指所有能输入计算机并能被计算机程序处理的符号的总称，是具有一定意义的数字、字母、符号和模拟量的统称&lt;/p&gt;
&lt;p&gt;数据的&lt;strong&gt;形式&lt;/strong&gt;:表现为数值、文字、图像、音频、视频、动画或计算机可以识别和处理的其他形式&lt;/p&gt;
&lt;p&gt;数据的&lt;strong&gt;来源&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;政府数据：统计数据、人口普查、经济年报&lt;/li&gt;
&lt;li&gt;社会数据：商业数据、生产数据、媒体数据&lt;/li&gt;
&lt;li&gt;个人数据：社交网络、个人消费&lt;/li&gt;
&lt;li&gt;其他&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;数据按照表示形式分：结构化数据、半结构化数据和非结构化数据等&lt;/p&gt;
&lt;h3&gt;定义和分类&lt;/h3&gt;
&lt;p&gt;定义：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;数据分析是运用适当的统计分析方法对收集来的大量数据进行分析、汇总，理解并消化它们，以求最大化地开发数据的功能，发挥数据的作用&lt;/li&gt;
&lt;li&gt;数据分析是为了提取有用信息和形成结论而对数据加以详细研究和概括总结的过程它是数学与计算机科学相结合的产物&lt;/li&gt;
&lt;li&gt;数据分析的目的是把隐藏在一批看似杂乱无章数据中的信息集中、茎取和提炼出来，找出研究对象的内在规律。在实际应用中，数据分析可帮助人们做出正确判断，以便采取适当行动&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;分类：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;描述性数据分析：是指仅依赖数据本身的语义描述实现数据分析的方法**。**它的目的是描述数据的特征，找到数据的基本规律，对数据以外的事情不进行深入推论。这是数据分析的初级阶段&lt;/li&gt;
&lt;li&gt;探索性数据分析**：**是为了形成值得假设的检验而对数据进行分析的一种方法，是对传统统计学假设检验手段的补充。探索性数据分析侧重在数据之中发现新的特征，通常比较灵活，讲究让数据自己说话。&lt;/li&gt;
&lt;li&gt;验证性数据分析：验证性数据分析是在已有假设的基础上进行证实或者证伪。因此，在验证性数据分析之前往往已经有了预先设定的数据模型，数据分析过程中需要把现有的数据套入模型，通过数据分析来帮助确认模型的性能。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;综述数据分析&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;有组织有目的地收集数据&lt;/li&gt;
&lt;li&gt;采用适当的统计分析方法对收集到的数据进行分析、概括和总结&lt;/li&gt;
&lt;li&gt;提取出有用信息&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;基本步骤&lt;/h3&gt;
&lt;p&gt;数据分析主要包括&lt;strong&gt;明确目的、数据&lt;strong&gt;&lt;strong&gt;收集、数据预处理、数据分析、结&lt;/strong&gt;&lt;/strong&gt;果呈现和撰写报告&lt;/strong&gt;等几个阶段&lt;/p&gt;
&lt;p&gt;数据预处理：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;数据清理：数据清洗是对数据进行重新审查和校验的过程，它是发现并纠正数据中可识别错误的最后一道程序，目的在于删除重复信息、纠正存在的错误，处理无效数据和缺失值，并检查数据一致性等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数据转换：将数据从一种表示形式变为另一种表示形式的过程。在数据转换中，数据的含义保持完全不变。数据转换一般发生在当前输入数据不能满足软件处理要求的情况下，通过对数据进行规格化操作，构成适合数据处理的描述形式。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数据集成：将来自多个数据源，包含不同格式和特点的数据在逻辑上或物理上有机地结合在一起形成一个统一的数据集合，以便为顺利完成数据分析工作提供完整的数据基础。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数据提取：从响应中获取数据分析所需数据的过程，它涉及从各种来源检索数据的操作。如果数据是结构化的，则数据提取通常在源系统内进行，常用的提取方法有完全提取法和增量提取法两种。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数据归约：在尽可能保持数据原貌的前提下，最大限度地精简数据量。当然，完成数据归约的必要前提是理解数据分析的目的并熟悉数据本身的特点及内容。数据归约主要有两个途径：属性选择和数据采样，分别针对原始数据集中的属性和记录进行操作。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;数据分析：利用适当的分析方法和工具，对收集来的数据进行分析，提取有价值的信息，形成有效结论的过程。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;Python基本语法与组合数据类型&lt;/h2&gt;
&lt;p&gt;基本语法：数据类型、运算符和表达式、控制结构、程序的循环结构、程序的异常处理、函数&lt;/p&gt;
&lt;p&gt;组合数据类型：容器（列表、元组、字典、集合），字符串常用方法，推导式，迭代器对象和生成器表达式&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Python基础为本课程的预修课程，不过多赘述，简要概括基本内容&lt;/p&gt;
&lt;p&gt;在线预览：&lt;a href=&quot;http://www.datazzh.top/wp-content/uploads/2024/01/%E7%AC%AC%E4%BA%8C%E7%AB%A0.pdf&quot;&gt;第二章 python基本语法&lt;/a&gt;   &lt;a href=&quot;http://www.datazzh.top/wp-content/uploads/2024/01/%E7%AC%AC%E4%B8%89%E7%AB%A0.pdf&quot;&gt;第三章 组合数据类型&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;相关资源来源 &lt;a href=&quot;http://www.tup.tsinghua.edu.cn/upload/books/kj/097249-01.rar&quot;&gt;Python数据分析与可视化案例实战（项目实战·源码解读·微课视频版）课件官网下载链接&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr /&gt;
&lt;h2&gt;本地数据采集和操作&lt;/h2&gt;
&lt;h3&gt;文件的基本操作&lt;/h3&gt;
&lt;p&gt;建立文件对象就是建立文件与内存中数据存储区的联系读取数据是将文件中的数据读到内存的数据存储区写数据是将内存中数据存储区的数据按照一定的格式存入文件。&lt;/p&gt;
&lt;h4&gt;文件打开：Python提供内置函数open()创建文件对象&lt;/h4&gt;
&lt;p&gt;&amp;lt;文件对象名&amp;gt;=open(&amp;lt;文件名&amp;gt;，[&amp;lt;打开模式&amp;gt;]，[&amp;lt;缓冲区设置策略&amp;gt;])&lt;/p&gt;
&lt;p&gt;&amp;lt;figure&amp;gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;打开模式&lt;/th&gt;
&lt;th&gt;功能&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&apos;r&apos;&lt;/td&gt;
&lt;td&gt;只读方式打开文件(默认方式)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&apos;w&apos;&lt;/td&gt;
&lt;td&gt;只写方式打开文件，如果文件存在，清除原来的内容&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&apos;x&apos;&lt;/td&gt;
&lt;td&gt;创建一个新文件，只写方式打开文件，如果文件已存在则抛出异常&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&apos;a&apos;&lt;/td&gt;
&lt;td&gt;只写方式打开文件，若文件存在，将要写入的数据追加在原文件内容之后&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&apos;b&apos;&lt;/td&gt;
&lt;td&gt;二进制文件模式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&apos;t&apos;&lt;/td&gt;
&lt;td&gt;文本文件模式(默认方式)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&apos;+&apos;&lt;/td&gt;
&lt;td&gt;读/写方式打开文件，用于更改文件内容&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&amp;lt;figcaption&amp;gt;&lt;/p&gt;
&lt;p&gt;open函数的打开方式&lt;/p&gt;
&lt;p&gt;&amp;lt;/figcaption&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;/figure&amp;gt;&lt;/p&gt;
&lt;h4&gt;文件关闭：Python提供colse()关闭文件&lt;/h4&gt;
&lt;h4&gt;文件读取：常用的方法包括read()、readline()、readlines()&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;f1=open(&apos;/path&apos;)
f2.read(8)#读取前8个字符
f1.read(10)#从当前位置继续读取10个字符
f1.readline()#从当前位置读取一行
f1.readlines(2)#读取相当于字节数的行数
f1.readlines()#读取文本文件中的多行数据,并返回列表
f1.close()#关闭文件
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;文件写入：常用函数有write()、writelines()&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;s1=&quot;Hello&quot;
s2=[&quot;i&quot;,&quot;am&quot;,&quot;python&quot;]
f1=open(&apos;/path&apos;,&apos;a+&apos;)
f1.write(s1)#写入数据,英文字符和汉字同等对待
f1.writelines(s2)
f1.close()
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;文件指针定位：每个打开的文件都有一个隐含的文件指针用于标识文件读写操作的当前位置。&lt;/h4&gt;
&lt;p&gt;例如:以包含“r”或“w”的方式打开文件则文件指针初始位置指向文件头部以包含“a”的方式打开文件则指针初始位置指向文件尾部。每当读写一定数目的字节，文件指针就后移相应的字节数。&lt;/p&gt;
&lt;p&gt;Python中与文件指针相关的函数有tell()和seek()&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#某文件内容
&quot;&quot;&quot;I LOVE PYTHON&quot;&quot;&quot;
f = open(&apos;/path&apos;)
f.read(3) #I L
f.tell() #使得指针下次读写操作在此(3)开始
f.read(10) #OVE PYTHON
f.seek(0) #使得指针从0开始
f.read(4) #I LO
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;使用with语句读取文件：使用with关键字可以确保代码发生异常后，能够正常调用close()&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;with open(&apos;/path&apos;) as f:
  f.read
with open(&apos;/t1&apos;,&apos;r&apos;) as file_out,open(&apos;t2&apos;,&apos;w&apos;) as file_in:
  file_in.write(file_out.read())
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;OS模板操作文件与目录&lt;/h3&gt;
&lt;p&gt;文件目录，又称为文件夹，是文件系统用于组织和管理文件的一种结构对象。Python的标准库os提供了操作文件与文件夹的函数，标准库os.path提供了路径判断、切分、连接及文件夹遍历的函数。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;函数&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;remove(&quot;filename&quot;)&lt;/td&gt;
&lt;td&gt;删除指定文件flename;如果文件不存在，则抛出异常&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;rename(&quot;oldname&quot;,&quot;newname&quot;)&lt;/td&gt;
&lt;td&gt;文件重命名&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;getcwd( )&lt;/td&gt;
&lt;td&gt;查看当前所在路径&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;listdir(&quot;path&quot;)&lt;/td&gt;
&lt;td&gt;返回指定目录下的所有文件和文件夹，，返回列表类型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;mknod(&quot;filename.txt&quot;)&lt;/td&gt;
&lt;td&gt;创建空文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;mkdir(&quot;path&quot;)&lt;/td&gt;
&lt;td&gt;创建目录&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;mkdirs(&quot;path&quot;)&lt;/td&gt;
&lt;td&gt;创建多层目录&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;rmdir(&quot;path&quot;)&lt;/td&gt;
&lt;td&gt;删除指定目录(只能删除空目录)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;chdir(&quot;path&quot;)&lt;/td&gt;
&lt;td&gt;改变当前工作目录到指定路径&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&amp;lt;center style=&quot;color:#808080; font-size:15px;&quot;&amp;gt;python标准库os常用函数&amp;lt;/center&amp;gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;函数&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;abspath(&quot;path&quot;)&lt;/td&gt;
&lt;td&gt;返回指定路径的绝对路径&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;basename(&quot;path&quot;)&lt;/td&gt;
&lt;td&gt;返回指定路径的文件名&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;dirname(&quot;path&quot;)&lt;/td&gt;
&lt;td&gt;返回指定路径的目录名&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;exists(&quot;path&quot;)&lt;/td&gt;
&lt;td&gt;判断给定的路径或文件是否存在&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;isabs(&quot;path&quot;)&lt;/td&gt;
&lt;td&gt;判断给定的路径是否为绝对路径&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;isdir(&quot;path&quot;)&lt;/td&gt;
&lt;td&gt;判断给定的路径是否为目录&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;isfile(&quot;path&quot;)&lt;/td&gt;
&lt;td&gt;判断给定的路径是否为文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;getsize(&quot;path&quot;)&lt;/td&gt;
&lt;td&gt;获得给定文件的大小&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;getctime(&quot;path&quot;)&lt;/td&gt;
&lt;td&gt;获取路径创建时间&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;getmtime(&quot;path&quot;)&lt;/td&gt;
&lt;td&gt;获取路径修改时间&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;getatime(&quot;path&quot;)&lt;/td&gt;
&lt;td&gt;获取路径最后一次访问时间&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&amp;lt;center style=&quot;color:#808080; font-size:15px;&quot;&amp;gt;获取文件属性的常用操作&amp;lt;/center&amp;gt;&lt;/p&gt;
&lt;h3&gt;JSON文件操作&lt;/h3&gt;
&lt;p&gt;JSON(JavaScript Object Notation)是一种轻量级的数据交换格式。它采用完全独立于编程语言的文本格式来存储和表示数据，易于阅读和编写,同时也易于机器解析和生成,其简洁清晰的层次结构使得 JSON 成为理想的数据交换语言。&lt;/p&gt;
&lt;p&gt;JSON文件：JSON数据保存为一个扩展名为「.json」的文件&lt;/p&gt;
&lt;p&gt;JSON对象：JSON对象是一个由大括号“{}”括起来的无序键值对集合，键值对数据之间用逗号隔开，数据结构为{key1:value1, key2:value2,..}。其中键key描述对象的属性，一般采用整数或字符串类型;值value可以是任意类型的数据。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;例如:{ &quot;firstName&quot;:&quot; John &quot;,&quot;lastName&quot;:&quot;Smith&quot;}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;JSON数组：JSON数组是用方括号“[ ]”括起来的一组数据元素，元素之间用逗号隔开，数据结构为[val1,val2,… valn，….]。JSON数组如同对象一样可以使用键值对，但还是使用索引更多一些。同样，数组元素可以是任意类型的数据。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;例如:{ &quot;people&quot;:[
{&quot;firstName&quot;:&quot; John &quot;,&quot;lastName&quot;:&quot;Smith&quot;},
{&quot;firstName&quot;:&quot; TOM&quot;,&quot;lastName&quot;:&quot;Smith&quot;}
] }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;常见的Python标准数据类型与JSON数据格式的转换对照&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Python数据类型&lt;/th&gt;
&lt;th&gt;JSON数据类型&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;dict&lt;/td&gt;
&lt;td&gt;object&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;list, tuple&lt;/td&gt;
&lt;td&gt;array&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;str&lt;/td&gt;
&lt;td&gt;string&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;int, float&lt;/td&gt;
&lt;td&gt;number&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;True&lt;/td&gt;
&lt;td&gt;true&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;False&lt;/td&gt;
&lt;td&gt;false&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;None&lt;/td&gt;
&lt;td&gt;null&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&amp;lt;center style=&quot;color:#808080; font-size:15px;&quot;&amp;gt;常见的Python标准数据类型与JSON数据格式的转换对照&amp;lt;/center&amp;gt;&lt;/p&gt;
&lt;h4&gt;JSON文件读写操作：导入json模板 import json&lt;/h4&gt;
&lt;p&gt;json.loads(str)函数将JSON数据格式转换为Python数据类型，这个过程称为解码&lt;/p&gt;
&lt;p&gt;json.dumps(obj)函数将Python数据类型转换为JSON数据格式，这个过程称为编码&lt;/p&gt;
&lt;p&gt;①读操作：常用函数有json.loads(str)、json.load()&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import json
json.loads(&apos;{&quot;a&quot;:97}&apos;) # {&apos;a&apos;:97} loads(str)用于处理字符串
json.loads(&quot;{\&quot;a\&quot;:97}&quot;)

filename=&apos;/path/filename.json&apos;
wiht open(filename,r) as f:
  f.data = json.load(f) # json.load()用于从指向的JSON文件类型对象将其数据转换为python的数据
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;②写操作：常用函数有json.dumps(obj)、json.dump()&lt;/p&gt;
&lt;p&gt;参数dump(d, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, cls=None, indent=None, separators=None)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import json
# dumps(obj)函数只能实现字典类型对象转换
json.dumps({&apos;a&apos;:123,&apos;b&apos;:&apos;ABC&apos;}) # &apos;{&quot;a&quot;:123,&quot;b&quot;:&quot;ABC&quot;}&apos; 

# json.dump()函数将生成的JSON数据保存到JSON文件中
filename=&apos;/path/filename.json&apos;
list = [{},{},{},……{}]
with open(filename,mode=&apos;w&apos;,encoding=&apos;utf-8&apos;) as f:
  json.dump(list,f)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;CSV文件&lt;/h3&gt;
&lt;p&gt;CSV(Comma Seperated Values)是一种以逗号为分隔符的纯文本文件格式,通常用来存储电子表格数据。CSV文件的第一行通常为列名或字段名，其余的每行存储一个样本或记录。整个CSV文件由任意数目的记录组成，记录间以某种换行符分隔，每条记录由字段组成，字段间使用分隔符分隔，最常见的分隔符是逗号。CSV文件常用于不同程序之间的数据交换,特别是电子表格和数据库内容的导入导出操作。&lt;/p&gt;
&lt;p&gt;CSV文件也是一种文本文件，完全可以按照普通文本文件的操作对CSV数据进行读写。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
with open(&apos;/path/filename.csv&apos;,&apos;w&apos;) as f:
  f.write(&apos;…………&apos;) #写入操作

with open(&apos;/path/filename.csv&apos;,&apos;r&apos;) as f:
  s = f.read().split(&apos;\n&apos;) #读取操作
  for i in s:
    print(i)
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;使用CSV模块进行读写操作&lt;/h4&gt;
&lt;p&gt;①读操作：函数reader(csvfile),创建并返回一个可迭代的读对象，每次迭代以字符串列表的形式返回文件中的一行数据。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from csv import reader
with open(&apos;/path/filename.csv&apos;,&apos;r&apos;) as f:
  lines = reader(f)
  for line in lines:
    print(line)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;②写操作：函数writer(csvfile)，创建并返回一个可迭代的写对象，写对象支持writerow()和writerows()将数据写入目标文件。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from csv import writer
lines = [[&apos;1&apos;,&apos;98&apos;],[&apos;2&apos;,&apos;90&apos;],[&apos;3&apos;,&apos;88&apos;],[&apos;4&apos;,&apos;70&apos;]]
with open(&apos;/path/filename.csv&apos;,&apos;a&apos;,newline = &apos;&apos;) as f:
  wr = writer(f)  
  for line in lines:   
    wr.writerow(line)
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;使用numpy模块进行读写操作&lt;/h4&gt;
&lt;p&gt;Python第三方库numpy提供loadtetxt()函数进行读取操作，要求文件各行数据数量相同&lt;/p&gt;
&lt;p&gt;利用numpy模块的loadtxt()函数读取CSV文件内容时需要列名预处理等比较复杂&lt;br /&gt;
的操作，&lt;strong&gt;一般不推荐使用。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;loadtxt(filepath,dtype=＂float＂,delimiter=None,skiprows=0,usecols=None)&lt;/p&gt;
&lt;p&gt;filepath  指定加载文件路径及文件名&lt;br /&gt;
dtype     指定返回的数据类型，默认为float&lt;br /&gt;
delimiter   字符串类型可选参数，指定加载文件中数据的分隔符，默认是空格&lt;br /&gt;
skiprows    指定文件中不需要读取的行数;&lt;br /&gt;
usecols      元组类型可选参数，指定加载文件中特定列的索引，默认读取所有列&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;提供savetxt()函数进行写入操作&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;savetxt(filepath,data,delimiter,fmt)&lt;br /&gt;
data 要写入的数据&lt;br /&gt;
delimiter   保存到CSV文件的数据间隔符&lt;br /&gt;
fmt   写入的数据格式&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;import numpy as np #导入模板
filename = &apos;/path/filename.csv&apos; #文件路径
with open(filename,&quot;r&quot;) as f
  col_name_str = f.readline()[:-1] #获得文件首行除去&apos;\n&apos;的列名字符串

col_name_list = col_name_str.split(&apos;,&apos;) #将字符串转换成列表
use_col_name_list = […………] #想要的列表名

data_array = np.loadtxt(filename,delimiter=&apos;,&apos;,skiprows=1,dtype=str,useclos=use_col_name_list) # 从文件中获得想要的数据
type(data_array) # numpy.ndarray

np.savetxt(&apos;/new.csv&apos;,data_array, delimiter=&apos;,&apos;,fmt = &apos;%s&apos;) #将读取到的数据存储至新CSV

&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;使用pandas模块进行读写操作&lt;/h4&gt;
&lt;p&gt;Python第三方库pandas也提供简单的CSV文件读写函数，返回一个DataFrame类型的数据对象。&lt;strong&gt;利用pandas处理CSV文件快捷方便，也是常用的CSV文件读写方式。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;①读操作：&lt;/p&gt;
&lt;p&gt;pandas模块提供了用于读取CSV文件内容的pandas.read_csv()函数，该函数快速而直接地打开、读取并分析CSV文件，并将数据存储在DataFrame对象中。&lt;/p&gt;
&lt;p&gt;pandas模块自动识别CSV文件第一行列名。如果第一行没有列名，可添加参数names提供列名。同时忽略现有列名或覆盖列名，需要使用参数header=0&lt;/p&gt;
&lt;p&gt;此外，pandas模块的DataFrame对象具有从零开始的整数索引。如果需要使用CSV文件中其他列作为DataFrame对象的索引，可以在pandas.read csv()函数中添加可选参数index_col&lt;/p&gt;
&lt;p&gt;②写操作：&lt;/p&gt;
&lt;p&gt;使用pandas.to_csv()函数将DataFrame对象写入CSV文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
import pandas as pd #导入pandas模板
filename = &apos;/path/filename.csv&apos; 
df = pd.read_csv(filename,index_col = &quot;?&quot;,header = 0,names=[…………]) # 读取文件数据
print(df) #打印

df.to_csv(&apos;/path/new.csv&apos;,index = False) # 保存至新文件（不包含索引）
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2&gt;网络数据获得&lt;/h2&gt;
&lt;h3&gt;网络爬虫简介&lt;/h3&gt;
&lt;p&gt;网络爬虫(web spider)又称网络机器人、网络蜘蛛，是一种根据既定规则，自动提取网页信息的程序或者脚本，传统爬虫以一个或若干初始网页的统一资源定位符(Uniform Resource Location,URL)为起点，下载每一个URL指定的网页分析并获取页面内容，并不断从当前页面抽取新的URL放入队列，记录每一个已经爬取过的页面，直到URL队列为空或满足设定的停止条件为止。&lt;/p&gt;
&lt;p&gt;按照系统结构和实现技术，网络爬虫大致分为四种类型，实际应用中的网络爬虫系统通常是几种爬虫技术相结合实现的&lt;/p&gt;
&lt;p&gt;网络爬虫分类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;通用网络爬虫(GeneraPurpose Web Crawler)又称全网爬虫，爬行对象从一些种子URL扩充到整个Web，主要为门户站点搜索引擎和大型Web服务提供商采集数据&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;深度优先爬行策略:按照深度由低到高的顺序，依次访问下一级网页链接，直到不能再深入为止。爬虫在完成一个爬行分支后返回上一个链接节点进一步搜索其它链接&lt;/li&gt;
&lt;li&gt;广度优先爬行策略:按照网页内容目录层次深浅来爬行页面，优先爬取目录层次较浅的页面。当同一层次的页面爬行完毕，再深入下一层次继续爬取&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;聚焦网络爬虫(FocusedWeb Crawler )又称主题网络爬虫，它会选择性地爬取与预定主题相关的页面&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;基于内容评价的爬行策略&lt;/li&gt;
&lt;li&gt;基于链接结构的搜索策略&lt;/li&gt;
&lt;li&gt;基于增强学习的爬行策略&lt;/li&gt;
&lt;li&gt;基于语境图的爬行策略&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;增量式网络爬虫(Incremental Web Crawler),对已下载的网页采取增量式更新策略，只爬行新产生或已经发生变化的网页，在一定程度上保证爬行尽可能新的页面&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;统一更新法:爬虫以相同的频率访问所有网页，不考虑网页的改变频率&lt;/li&gt;
&lt;li&gt;个体更新法:爬虫根据个体网页的改变频率重新访问各页面&lt;/li&gt;
&lt;li&gt;基于分类的更新法:爬虫根据网页改变频率分为更新较快网页子集和更新较慢网页子集两类，然后以不同的频率访问这两类网页&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;深层网络爬虫(DeepWeb Crawler),Web页面按照存在方式可以分为表层网页和深层网页两类。表层网页是指传统搜索引擎可以索引到的页面，以超链接可以到达的静态网页为主。深层网页是指隐藏在搜索表单后，大部分内容不能通过静态链接获取，只有用户提交关键词才能获得的Web页面。深层网页是目前互联网上最大、发展最快的新型信息资源深层网页爬中爬行过程中最重要的部分就是表单填写，表单填写方法可以分为两类&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;基于领域知识的表单填写&lt;/li&gt;
&lt;li&gt;基于网页结构分析的表单填写&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;网络爬虫任务：主要完成两个任务，即&lt;strong&gt;下载目标网页&lt;/strong&gt;和&lt;strong&gt;从目录网页中解析信息&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;网络爬虫基本架构&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/Capture_20240131_113235.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;URL管理模板：添加新的URL链接、管理已爬行的URL和未爬行的URL以及获取待爬行的URL&lt;/li&gt;
&lt;li&gt;网页下载模板：用于从URL管理模块中将指定URL对应的页面下载到本地，或者以字符串形式读入内存，方便后续使用字符串相关操作解析网页内容&lt;/li&gt;
&lt;li&gt;网页分析模板：用于从网页下载模块获取已下载的网页，并解析出有效数据交给数据存储器&lt;/li&gt;
&lt;li&gt;数据存储器：负责将网页解析模块解析出的数据存储起来，用于后续的数据分析和信息利用&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;网页下载模块&lt;/h3&gt;
&lt;p&gt;requests库：是Python中一个处理HTTP请求的第三方库&lt;/p&gt;
&lt;p&gt;requests库的网页请求&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;函数&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;get(url[,timeout = n])&lt;/td&gt;
&lt;td&gt;对应HTTP的GET方式, 可选参数timeout设定每次请求超时时间，单位为秒&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;post(url,data={&apos;key&apos;: &apos;value&apos;})&lt;/td&gt;
&lt;td&gt;对应HTTP的POST方式, 其中字典用于传递客户数据&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;put(url,data={&apos;key&apos;: &apos;value&apos;})&lt;/td&gt;
&lt;td&gt;对应HTTP的PUT方式, 其中字典用于传递客户数据&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;delete(url)&lt;/td&gt;
&lt;td&gt;对应HTTP的DELETE方式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;head(url)&lt;/td&gt;
&lt;td&gt;对应HTTP的HEAD方式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;options(url)&lt;/td&gt;
&lt;td&gt;对应HTTP的OPTIONS方式&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&amp;lt;center style=&quot;color:#808080; font-size:15px;&quot;&amp;gt;requests库的网页请求方法&amp;lt;/center&amp;gt;&lt;/p&gt;
&lt;p&gt;response对象：调用网页请求方法后，返回的网页内容保存为一个response对象&lt;/p&gt;
&lt;p&gt;response对象常见属性&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;status_code&lt;/td&gt;
&lt;td&gt;HTTP请求返回的状态码，为整数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;headers&lt;/td&gt;
&lt;td&gt;HTTP相应内容的网页header信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;encoding&lt;/td&gt;
&lt;td&gt;HTTP响应内容的编码形式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;text&lt;/td&gt;
&lt;td&gt;HTTP响应内容的字符串形式，即url对应的页面内容&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;content&lt;/td&gt;
&lt;td&gt;HTTP响应内容的二进制形式&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&amp;lt;center style=&quot;color:#808080; font-size:15px;&quot;&amp;gt;response对象常见属性&amp;lt;/center&amp;gt;&lt;/p&gt;
&lt;p&gt;在调用请求方法后，可以使用response.status_code属性返回HTTP请求状态，如果请求状态未被响应，需要中止内容处理&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为response.encoding属性赋值可以改变编码方式，便于处理中文字符&lt;/li&gt;
&lt;li&gt;除了属性，response对象也提供了一些方法response.json()，可以解析HTTP响应内容中的JSON格式数据；response.raise_for_status()，如果状态码不是“200”,则会抛出异常&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;import requests
def getHTMLText(url)
  try:
    r_obj = requests.get(url)
    r_obj = raise_for_status()
    r_obj.encoding = &apos;utf-8&apos;
    return r_obj.text
  except:
    return &quot;&quot;
url = &quot;http://www.datazzh.top&quot;
print(getHTMLText(url))
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;网页解析模块&lt;/h3&gt;
&lt;p&gt;beautifulsoup4库：Python第三方库，用于解析和处理HTML、xml文件并提取数据&lt;/p&gt;
&lt;p&gt;作为第三方库需要预先安装，在Python解释器中导入使用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;pip install beautifulsoup4 #命令窗口中安装库
from bs4 import Beautifulsoup #解释器中导入模组
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;文档对象模型：一个网页文件通常可以表示一个文档对象模型（DOM），DOM是一种处理HTML、XML文件的标准编程接口，将网页文档表示为一个树形结构，每一个节点表示一个HTML标签（tag）或标签内的文本项&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/Capture_20240203_124927.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;将HTML或XML文档转化为DOM树的过程称为解析&lt;/p&gt;
&lt;p&gt;HTML 文档被解析后，转化为DOM树，因此对HTML文档的处理可以通过对DOM树的操作实现&lt;/p&gt;
&lt;p&gt;导入bs4库的BeautifulSoup类之后，使用BeautifulSoup(）创建一个BeautifulSoup对象。实例化的BeautifulSoup对象相当于一个页面，表示一个文档的全部内容&lt;/p&gt;
</content:encoded></item><item><title>机器学习</title><link>https://minthana.github.io/blog/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link><guid isPermaLink="true">https://minthana.github.io/blog/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid><pubDate>Sun, 21 Jan 2024 16:28:00 GMT</pubDate><content:encoded>&lt;p&gt;教材：《机器学习》——周志华 （西瓜书）&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;傍晚小街路面上沁出微雨后的湿润，和煦的细风吹来，抬头看看天边的晚霞，嗯，明天又是一个好天气．走到水果摊旁，挑了个根蒂蜷缩、敲起来声音浊响的青绿西瓜，一边满心期待着皮薄肉厚瓤甜的爽落感，一边愉快地想着。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr /&gt;
&lt;h2&gt;绪论&lt;/h2&gt;
&lt;p&gt;从上述周志华老师的引言来看，为什么微湿路面，和煦细风，天边晚霞的场景认为明天是好天气；根蒂蜷缩，敲声浊响，青绿的西瓜是好瓜。可以十分巧妙的看出，人类通过自身积累的经验对于新情况能够做出有效的预判。&lt;/p&gt;
&lt;p&gt;而什么是机器学习，通俗来讲，指的是在计算机系统中，将“经验”以“数据”形式存储，基于这些数据，利用“学习算法”产生模型。在面对新情况时（一个未剖开的西瓜），基于该模型得到相应的判断结果（好瓜/烂瓜）&lt;/p&gt;
&lt;h3&gt;基本术语&lt;/h3&gt;
&lt;p&gt;示例或样本：数据集中的每一条数据记录&lt;/p&gt;
&lt;p&gt;样例：拥有标记信息的样本&lt;/p&gt;
&lt;p&gt;特征或属性：反映事件或对象在某方面的表现或性质的事项&lt;/p&gt;
&lt;p&gt;属性值：属性上的取值&lt;/p&gt;
&lt;p&gt;属性空间：将属性张成描述事件或对象的d维空间&lt;/p&gt;
&lt;p&gt;特征向量：每个示例都能在属性空间找到自己的坐标，因此一个示例又称“特征向量”&lt;/p&gt;
&lt;p&gt;学习算法：从数据中产生“模型” 的算法，即“学习算法”&lt;/p&gt;
&lt;p&gt;学习或训练：通过执行“学习算法”，从数据中学得模型的过程&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;P(|ƒ (X) - Y| ≤ ε) ≥ 1- δ   我们希望以很高的概率获得一个很好的模型&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;假设：学习模型对应了关于某条潜在的规律为假设；&lt;/p&gt;
&lt;p&gt;真相：学得模型的某种潜在的规律为真相&lt;/p&gt;
&lt;p&gt;学习器：学习算法对一个数据和一个参数在给定实列化之后，得到的一个结果&lt;/p&gt;
&lt;p&gt;分类、回归：前者欲预测的是离散型，后者为连续型&lt;/p&gt;
&lt;p&gt;聚类：感知样本间的相似度进行类别归纳&lt;/p&gt;
&lt;p&gt;监督学习、无监督学习：前者代表有分类和回归，后者代表有代表有聚类（根据训练数据是否拥有标记信息划分这两大类）&lt;/p&gt;
&lt;p&gt;二分类、多分类、正类、反类&lt;/p&gt;
&lt;p&gt;未知分布：通常假设样本空间的样本服从某假设(规律)的一个分布为未知分布&lt;/p&gt;
&lt;p&gt;未见样本：训练模型中的样本为某一假设(规律)分布(未见分布)中的一部分，而同处于这个假设的其他样本为未见样本&lt;/p&gt;
&lt;p&gt;独立同分布(i.i.d)：如果多个随机变量之间相互独立，并且具有相同的分布函数，那么这些随机变量就是独立同分布的&lt;/p&gt;
&lt;p&gt;泛化：模型对新数据的处理能力更好，泛化能力更强   |ƒ(X) - Y| ≤ ε&lt;/p&gt;
&lt;h3&gt;归纳偏好&lt;/h3&gt;
&lt;p&gt;机器学习算法在学习过程中对某种类型假设的偏好，任何一个有效的机器学习算法必有其偏好&lt;/p&gt;
&lt;p&gt;一般原则（奥卡姆剃刀）：若非必要，无增实体&lt;/p&gt;
&lt;p&gt;学习算法的归纳偏好是否与问题本身匹配，大多数时候直接决定了算法能否取得好的性能&lt;/p&gt;
&lt;h3&gt;NFL定理&lt;/h3&gt;
&lt;p&gt;一个算法£a若在某些问题是比另一个算法£b好，必存在另一个问题£b比£a好&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2024-01-21-124148.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;NFL定理的重要前提：所有“问题”出现的机会相同、或所有问题同等重要&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;具体问题，具体分析！&lt;/p&gt;
&lt;p&gt;最优方案往往来自：按需设计，度身定制&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr /&gt;
&lt;h2&gt;模型评估与选择&lt;/h2&gt;
&lt;h3&gt;过拟合和欠拟合&lt;/h3&gt;
&lt;p&gt;泛化误差：在“未来”样本上的误差&lt;/p&gt;
&lt;p&gt;经验误差：在训练集上的误差，亦称训练误差&lt;/p&gt;
&lt;p&gt;过拟合：过拟合是指模型在训练数据上表现得过于优秀，但在未见数据上表现较差&lt;/p&gt;
&lt;p&gt;欠拟合：欠拟合是指模型无法很好地拟合训练数据，无法捕捉到数据中的真实模式和关系&lt;/p&gt;
&lt;h3&gt;三大问题&lt;/h3&gt;
&lt;p&gt;模型选择上的三个关键问题：&lt;/p&gt;
&lt;p&gt;如何获得测试结果？ ——&amp;gt;评估方法&lt;/p&gt;
&lt;p&gt;如何评估性能优劣？ ——&amp;gt;性能度量&lt;/p&gt;
&lt;p&gt;如何判断实质差别？ ——&amp;gt;比较检验&lt;/p&gt;
&lt;h3&gt;评估方法&lt;/h3&gt;
&lt;p&gt;常见的方法：留出法、交叉验证法、自助法&lt;/p&gt;
&lt;h4&gt;留出法(hold-out)&lt;/h4&gt;
&lt;p&gt;直接将数据集划分为两个互斥的集合，一个作为训练集，另一个作为测试集&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2024-01-21-214840.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;保持数据分布一致性（例如：分层采样）&lt;/li&gt;
&lt;li&gt;多次重复划分（例如：100次随机划分）&lt;/li&gt;
&lt;li&gt;测试集不能太大、不能太小（例如：1/5~1/2）&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;k-折交叉验证法(cross vaildation)&lt;/h4&gt;
&lt;p&gt;将样本集分为k份，其中k-1份作为训练数据集，剩下的1份作为验证数据集&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2024-01-21-215420.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h4&gt;自助法(bootstrap)&lt;/h4&gt;
&lt;p&gt;自助法亦称有放回采样、可重复采样&lt;/p&gt;
&lt;p&gt;是一种从给定训练集中有放回的均匀抽样方法，为划分训练集后，留有充足的测试集进行测试&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2024-01-21-220039.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h4&gt;调参与验证集&lt;/h4&gt;
&lt;p&gt;算法的参数：一般由人工设定，亦称“超参数”&lt;/p&gt;
&lt;p&gt;模型的参数：一般由学习确定&lt;/p&gt;
&lt;p&gt;调参：调参是指在机器学习过程中，对算法参数进行设定的过程。调参的目的是为了找到最优的参数组合，使得机器学习模型能够更好地适应训练数据，提高模型的准确性和泛化能力。&lt;/p&gt;
&lt;p&gt;验证集：是指用于模型选择和调参的数据集。它是从训练集中再分拆出来的，用于对学习算法调整参数、选择特征或做其他决策&lt;/p&gt;
&lt;h3&gt;性能度量&lt;/h3&gt;
&lt;p&gt;性能度量是衡量模型泛化能力的评价标准，反映了任务需求&lt;/p&gt;
&lt;p&gt;回归任务常用均方误差：&lt;/p&gt;
&lt;p&gt;$$
E(ƒ;D) = \frac{1}{m}\sum_{m}^{i=1}(ƒ(x_{i})-y_{i})^{2}
$$&lt;/p&gt;
&lt;p&gt;分类任务常用错误率和精度：&lt;/p&gt;
&lt;p&gt;$$
E(ƒ;D)= \frac{1}{m}\sum_{m}^{i = 1}\mathbb I(ƒ(x_{i})≠y_{i})
$$&lt;/p&gt;
&lt;p&gt;$$
acc(ƒ;D) = \frac{1}{m}\sum_{m}^{i = 1}\mathbb I(ƒ(x_{i})＝y_{i})=1-E(ƒ;D)
$$&lt;/p&gt;
&lt;p&gt;查准率、查全率：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;真实情况&lt;/th&gt;
&lt;th&gt;预测结果&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;正例&lt;/td&gt;
&lt;td&gt;反例&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;正例&lt;/td&gt;
&lt;td&gt;TP(真正例)&lt;/td&gt;
&lt;td&gt;FN(假反例)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;反例&lt;/td&gt;
&lt;td&gt;FP(假正例)&lt;/td&gt;
&lt;td&gt;TN(真反例)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;查准率：P = TP/(TP + FP)&lt;/p&gt;
&lt;p&gt;查全率：R = TP/(TP + FN)&lt;/p&gt;
&lt;p&gt;F1度量是一种综合考虑查准率和查全率的度量方式，通常用于衡量二元分类模型的性能。&lt;/p&gt;
&lt;p&gt;其一般形式可以表示为：&lt;/p&gt;
&lt;p&gt;$$
F1 = \frac{2 × P × R}{(P + R)} =\frac{2× TP}{样例总数+TP-TN}
\frac{1}{F1} = \frac{1}{2}× (\frac{1}{P}+\frac{1}{R} )
$$&lt;/p&gt;
&lt;p&gt;若对查准率/查全率有不同偏好：β&amp;gt;1时查全率有更大影响；β&amp;lt;1时查准率有更大影响&lt;/p&gt;
&lt;p&gt;$$
F_{\beta } =\frac{(1+\beta^{2}\times P\times R )}{(\beta^{2}\times P)+R}
\frac{1}{F_{\beta } } =\frac{1}{1+\beta^{2}} \times (\frac{1}{P}+\frac{\beta^{2}}{R} )
$$&lt;/p&gt;
&lt;h3&gt;比较检验&lt;/h3&gt;
&lt;p&gt;常用方法：统计假设检验，为学习器性能比较提供了重要依据&lt;/p&gt;
&lt;p&gt;两学习器比较&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;交叉验证t检验（基于成对t检验）：比较两组数据的均值是否存在显著差异。例：通过判断两学习器的误差差值的均值或标准差进行检验，&lt;/li&gt;
&lt;li&gt;McNemar检验（基于列联表，卡方检验）用于比较两个分类器在不同数据集上性能差异的统计检验。例：比较两个分类器在不同数据集上的查准率和查全率等指标，判断它们是否存在显著差异&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2&gt;线性模型&lt;/h2&gt;
&lt;p&gt;线性模型试图学得一个通过属性的线性组合来进行预测的函数&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2024-02-18-192241.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;$$
f(x) = \omega &lt;em&gt;{1} x&lt;/em&gt;{1}+\omega &lt;em&gt;{2}x&lt;/em&gt;{2}+...+\omega &lt;em&gt;{d}x&lt;/em&gt;{d}+b
$$&lt;/p&gt;
&lt;p&gt;$$
向量形式：f(x) = \omega ^{T} x+b
$$&lt;/p&gt;
&lt;p&gt;线性模型优点：&lt;/p&gt;
&lt;p&gt;形式简单、易于建模&lt;/p&gt;
&lt;p&gt;可解释性&lt;/p&gt;
&lt;p&gt;非线性模型的基础，引入层级结构或高维映射&lt;/p&gt;
&lt;h3&gt;线性回归&lt;/h3&gt;
&lt;p&gt;$$
线性回归要做的是 找到f(x_{i} ) = \omega x_{i}+b使得f(x_{i} )\simeq y_{i}
$$&lt;/p&gt;
&lt;p&gt;线性回归擅长处理数值属性&lt;/p&gt;
&lt;p&gt;对于离散属性数值处理时，对于有序关系，如身高：高中低，进行连续化处理1（高）,0.5（中）,0（低）&lt;/p&gt;
&lt;p&gt;对于无序关系，离散属性有k个可能取值，转化为k维向量表示，如西瓜颜色：青绿色[1 0 0], 浅绿色[0 1 0], 白色[0 0 1]&lt;/p&gt;
&lt;h3&gt;最小二乘法&lt;/h3&gt;
&lt;p&gt;最小二乘法：是基于均方误差最小化来进行模型求解的方法&lt;/p&gt;
&lt;p&gt;令均方误差最小化，有&lt;/p&gt;
&lt;p&gt;$$
(w^{&lt;em&gt;},b^{&lt;/em&gt;}) = \mathop{arg min}\limits_{(w,b)}\sum_{i=1}^{m} (f(x)&lt;em&gt;{i}-y&lt;/em&gt;{i})^2
=\mathop{arg min}\limits_{(w,b)}\sum_{i=1}^{m} (y_{i}-wx_{i}-b)^2
$$
对
$$
E_{(w,b)}=⁡∑^{m}&lt;em&gt;{i=1} (y&lt;/em&gt;{i}-wx_{i}-b)^{2 }进行最小二乘参数估计
$$&lt;/p&gt;
&lt;p&gt;分别对w和b求导，可得：&lt;/p&gt;
&lt;p&gt;$$
\frac{\partial E_{(w,b)}}{\partial w} = 2(w\sum_{i=1}^{m} x_{i}^2-\sum_{i=1}^{m}(y_{i}-b)x_{i})
$$&lt;/p&gt;
&lt;p&gt;$$
\frac{\partial E_{(w,b)}}{\partial b} = 2(mb-\sum_{i=1}^{m}(y_{i}-wx_{i}))
$$&lt;/p&gt;
&lt;p&gt;令倒数为0，得到闭式解：&lt;/p&gt;
&lt;p&gt;$$
w=\frac{\sum_{i=1}^{m}y_{i}(x_{i}-\bar{x} ) }{\sum_{i=1}^{m}x_{i}^2-\frac{1}{m}(\sum_{i=1}^{m}x_{i})^2 }
$$&lt;/p&gt;
&lt;p&gt;$$
b = \frac{1}{m} \sum_{i=1}^{m} (y_{i}-wx_{i})
$$&lt;/p&gt;
&lt;h3&gt;回归方程评估&lt;/h3&gt;
&lt;p&gt;SSR为回归平方和，SSE为残差平方和，SST为总离差平方和。&lt;/p&gt;
&lt;p&gt;SSR：是拟合数据与原始数据均值之差的平方和。&lt;/p&gt;
&lt;p&gt;SST：是原始数据和均值之差的平方和，即SST=SSE+SSR。&lt;/p&gt;
&lt;p&gt;R2：是通过数据的变化来表征一个拟合的好坏&lt;/p&gt;
&lt;p&gt;R2(判定系数)的正常取值范围为[0,1]，越接近1，表明方程变量的解释能力越强，模型对数据的拟合程度也越好&lt;/p&gt;
&lt;p&gt;$$
R^2=\frac{SSR}{SST}=\frac{SST-SSE}{SST} =1-\frac{SSE}{SST}
$$&lt;/p&gt;
&lt;h2&gt;逻辑回归&lt;/h2&gt;
&lt;h3&gt;梯度下降法&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://www.bilibili.com/video/BV18P4y1j7uH/?vd_source=177a578c33d2447cb2c9ed14e875bdc1&quot;&gt;哔哩哔哩【梯度下降】3D可视化讲解通俗易懂 —— 梗直哥丶&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;视频详细讲解梯度下降法的主要思想和相关内容&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;梯度下降的主要目的是通过&lt;strong&gt;迭代&lt;/strong&gt;找到目标函数的&lt;strong&gt;最小值&lt;/strong&gt;，或者收敛到最小值&lt;/p&gt;
&lt;p&gt;&amp;lt;figure&amp;gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/tdxj-1024x508.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;figcaption&amp;gt;&lt;/p&gt;
&lt;p&gt;图源网络&lt;/p&gt;
&lt;p&gt;&amp;lt;/figcaption&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;/figure&amp;gt;&lt;/p&gt;
&lt;p&gt;梯度下降的步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;定义代价函数&lt;/li&gt;
&lt;li&gt;给定起始点&lt;/li&gt;
&lt;li&gt;计算梯度&lt;/li&gt;
&lt;li&gt;按学习率前进&lt;/li&gt;
&lt;li&gt;重复3、4步，直到找到最低点&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;梯度下降的分类：批量、随机、小批量梯度下降法&lt;/p&gt;
&lt;p&gt;学习率：学习率是机器学习中的超参数，影响目标函数的收敛速度和效果&lt;/p&gt;
&lt;h3&gt;逻辑回归&lt;/h3&gt;
&lt;p&gt;逻辑回归虽然被称为回归，实际是分类模型，常用于二分类&lt;/p&gt;
&lt;p&gt;原理：找到一条能够将不同类别的样本区分开来的线&lt;/p&gt;
&lt;p&gt;逻辑回归的输出是一个概率值，范围在0到1之间，表示样本属于某个类别的概率。对于二分类问题，通常设置一个阈值（如0.5），将概率值大于阈值的样本归为正类，小于阈值的归为负类（最理想的函数：单位阶跃函数）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2024-07-08-101552.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</content:encoded></item><item><title>快速搭建个人网站</title><link>https://minthana.github.io/blog/posts/%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99/</link><guid isPermaLink="true">https://minthana.github.io/blog/posts/%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99/</guid><pubDate>Fri, 12 Jan 2024 16:47:00 GMT</pubDate><content:encoded>&lt;h1&gt;本文内容将教你如何快速搭建个人网站&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;步骤一：购买域名&lt;/li&gt;
&lt;li&gt;步骤二：购买轻量应用服务器&lt;/li&gt;
&lt;li&gt;步骤三：登录宝塔&lt;/li&gt;
&lt;li&gt;步骤四：域名解析&lt;/li&gt;
&lt;li&gt;步骤五：一键部署WordPress&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;搭建前的准备：域名（11块钱左右）、云服务器（初期成本61左右）&lt;/p&gt;
&lt;p&gt;成本共计：￥72&lt;/p&gt;
&lt;h2&gt;工作原理讲解：&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;域名：域名（Domain Name）就是就是大家经常输入的 xxx.com，xxx.cn 之类的网址。域名本质上是一种人类可读的计算机名，它被用来在数据网络中定位计算机的位置。对于人类来说，类似192.168.0.104这样的IP地址并不容易记忆，因此，人类设计出了域名，比如baidu.com。计算机通过域名系统（DNS，Domain Name System）将域名和IP地址相互映射，使人们更方便地访问互联网，而无需记住机器可读的IP地址。域名还可以传递品牌信息，增加品牌认知度和曝光度。&lt;/li&gt;
&lt;li&gt;服务器：服务器是一种提供服务的计算机，它通过网络向用户提供信息、服务或数据。当用户请求一个网页时，服务器会处理该请求并返回相应的网页。服务器的工作原理可以理解为：用户发出请求，服务器接收请求并处理，然后将结果返回给用户。服务器需要持续运行并维护，以确保用户可以随时访问网站。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;大致了解完工作原理之后，开始我们的搭建网站步骤&lt;/p&gt;
&lt;h2&gt;步骤一：购买域名&lt;/h2&gt;
&lt;p&gt;我这里选择的是&lt;a href=&quot;https://cn.aliyun.com/&quot;&gt;阿里云平台&lt;/a&gt;提供的服务，当然大家也可以选择其他平台渠道购入，为了方便同一管理和网站搭建，后续的操作基本上在阿里云平台上进行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;温馨提示：如果你不想购买域名，也可以通过后续购买的云服务器的IP进行访问网站&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.打开阿里云的官网，注册账号（&lt;a href=&quot;https://account.aliyun.com/register/qr_register.htm?oauth_callback=https%3A%2F%2Fcn.aliyun.com%2F%3Faccounttraceid%3D4a94144046614a7898203f73a9e5172epjzf&quot;&gt;阿里云注册页 (aliyun.com)&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;2.点击右上角头像进入主页，绑定个人安全邮箱、完成实名验证&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2024-01-12-132919.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;3.打开左上角控制台菜单，输入“注册域名”，进入域名控制台&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2024-01-12-134757.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;4.依据个人喜好的域名查询并加入清单（推荐使用.top后缀，优点：便宜     &lt;strong&gt;温馨提示：价格会随着域名购买年限的增加&lt;/strong&gt;）&lt;/p&gt;
&lt;p&gt;5.创建信息模板并进行邮箱验证，等待验证成功后会发短信通知你（根据《互联网域名管理办法》及ICANN政策要求，注册域名需使用实名并完成邮箱验证的模板。）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2024-01-12-135523.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;6.模板创建成功后，即可购买域名 （购买成功后会发邮箱通知）&lt;/p&gt;
&lt;h2&gt;步骤二：购买轻量应用服务器&lt;/h2&gt;
&lt;p&gt;购买云服务器可以选择两种云服务器：中国大陆或者海外的云服务器。&lt;/p&gt;
&lt;p&gt;根据国内的相关法律法规，域名访问中国大陆的服务器需要进行备案操作，而海外服务器不需要进行备案操作。&lt;/p&gt;
&lt;p&gt;推荐大家购买香港的云服务器，可以省去备案操作。由于阿里云提供的香港服务器售卖有限，本步骤以大陆服务器作为案例进行操作。&lt;/p&gt;
&lt;p&gt;搭建个人博客，云服务器不需要太高配置，我选择的是2核2G 3M带宽的配置的轻量应用服务器&lt;/p&gt;
&lt;p&gt;1.新用户第一次购买云服务享有折扣优惠，官网首页会在轮播图中有进入链接&lt;a href=&quot;https://www.aliyun.com/daily-act/ecs/activity_selection?spm=5176.28508143.J_ahRFo5CaAe_asSOaCgS4J.2.5421154abtH1M6&amp;amp;scm=20140722.M_10071131.P_149.MO_2274-ID_10071131-MID_10071131-CID_30876-ST_9607-V_1&quot;&gt;热卖云服务器低至61元/年&lt;/a&gt;，点击立刻购买&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2024-01-12-143542.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;2.选择地域和可用区（任意）、应用镜像（宝塔Linux面板），点击购买&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2024-01-12-145211.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;步骤三：登录宝塔&lt;/h2&gt;
&lt;p&gt;1.购买成功后（邮箱会通知），打开控制台输入“轻量应用服务器”，点击「我的轻量」进行查看管理云服务器信息&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2024-01-12-145725.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;2.进入「我的轻量」后，我们点击应用详情，根据蓝色指示获取用户名和密码。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2024-01-12-150353.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;3.访问：你的公网IP:8888进入宝塔后台。进入后台后选择LNMP（推荐）极速安装，一键安装&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2024-01-12-152139.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/p450390.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;步骤四：域名解析&lt;/h2&gt;
&lt;p&gt;1.进入阿里云官网-域名控制台-域名列表，选择自己的域名，点击操作-解析&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2024-01-12-153326.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;2.点击添加记录，按照以下图片的选择，添加两条解析&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2024-01-12-153440.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;3.返回「我的轻量」-域名，添加域名&lt;/p&gt;
&lt;h2&gt;步骤五：一键部署WordPress&lt;/h2&gt;
&lt;p&gt;1.进入宝塔管理平台，点击软件商店 - 一键部署 - Wordpress一键部署&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2024-01-12-154900.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;2.填写部署信息-提交（此处数据库账号密码截图保存或记住！！！）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2024-01-12-155628.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;3.安装最新版本PHP   点击软件商店-运行环境-PHP-8.0安装&lt;/p&gt;
&lt;p&gt;4.更改网站PHP版本   点击网站-设置-PHP版本-PHP-80-切换&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2024-01-12-160806.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;5.访问网站  http://该步骤填写的域名或公网IP/index.php（截图里的网站内容      如果访问失败使用公网IP  原因：域名未备案）&lt;img src=&quot;images/v2-3a20321cdb977ebe45140f6357832b04_r-e1705048290877.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;6.注册数据库（将本步骤截图的数据库账户密码填写至此）&lt;img src=&quot;images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2024-01-12-163242.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;7.填写用户信息（即管理员信息）&lt;img src=&quot;images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2024-01-12-163707.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;注册完成点击登录进入WordPress后台     (http://域名或公网IP/wp-login.php)&lt;/li&gt;
&lt;/ol&gt;
&lt;h1&gt;至此基本完成搭建，更多扩展等待着你的探索&lt;/h1&gt;
&lt;p&gt;声明：部分素材来自网络&lt;/p&gt;
</content:encoded></item><item><title>The South Wind——泰戈尔</title><link>https://minthana.github.io/blog/posts/the-south-wind-%E6%B3%B0%E6%88%88%E5%B0%94/</link><guid isPermaLink="true">https://minthana.github.io/blog/posts/the-south-wind-%E6%B3%B0%E6%88%88%E5%B0%94/</guid><pubDate>Sat, 06 Jan 2024 14:36:00 GMT</pubDate><content:encoded>&lt;p&gt;&lt;img src=&quot;images/DSC_0124-1024x683.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;我像麝鹿一样在林荫中奔走&lt;br /&gt;
为着自己的芳香而发狂&lt;br /&gt;
夜晚是五月正中的夜晚&lt;br /&gt;
清风是南国的清风&lt;br /&gt;
我迷了路,我游荡着&lt;br /&gt;
我寻求那得不到的东西&lt;br /&gt;
我得到我所没有寻求的东西&lt;br /&gt;
我自己的愿望的形象从我心中走出&lt;br /&gt;
跳起舞来&lt;br /&gt;
这闪光的形象飞掠过去&lt;br /&gt;
我想把它紧紧捉住&lt;br /&gt;
它躲开了又引着我飞走下去&lt;br /&gt;
我寻求那得不到的东西&lt;br /&gt;
我得到我所没有寻求的东西&lt;/p&gt;
</content:encoded></item></channel></rss>